{
  "/build-apps/add-time-picker-guide": [
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic Mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-03-08T15:33:21Z",
      "updated_at": "2021-03-07T00:02:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: New Relic APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. New Relic Mobile, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed New Relic Mobile, you can monitor its performance directly from your Android device. New Relic Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.83047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Android <em>app</em> UI | New Relic Documentation",
        "sections": "Android <em>app</em> UI",
        "tags": "Mobile <em>apps</em>",
        "body": " <em>picker</em> to choose a <em>time</em> range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android <em>app</em> to view your New Relic Synthetics data, including charts of your monitor&#x27;s availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Build a custom visualization for dashboards",
        "Add a table to your app",
        "Permissions for managing applications",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Build apps",
      "updated_at": "2021-03-11T01:51:44Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Build a custom visualization for dashboards 15 min Create custom data views Add a table to your app 30 min Add a table to your New Relic One app Permissions for managing applications   Learn about permissions for subscribing to apps Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.12482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a <em>time</em> <em>picker</em> to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic Mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-03-08T15:36:55Z",
      "updated_at": "2021-03-06T23:53:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: New Relic APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. New Relic Browser (iPhone and iPad). Provide overview dashboard, including average page load time, Browser Apdex, average throughput, and more. New Relic Infrastructure (iPhone only). New Relic Alerts (iPhone and iPad). Get alert and deployment notifications. New Relic Synthetics (iPhone only). New Relic Browser (iPhone and iPad). New Relic Mobile (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic Plugins (iPhone and iPad). New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. New Relic Synthetics You can use the iOS app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed New Relic Mobile, you can monitor its performance directly from your iPhone or iPad. New Relic Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy To make troubleshooting easier, New Relic's mobile apps only record the following information about you: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.38388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS mobile <em>app</em> | New Relic Documentation",
        "sections": "Introduction to iOS mobile <em>app</em>",
        "tags": "Mobile <em>apps</em>",
        "body": " Relic charts to move back and forth across the timeline. Select the <em>time</em> <em>picker</em> to choose a <em>time</em> range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end <em>time</em> other than now, slide the toggle from Ending Now to Custom Date. New Relic Synthetics You can use the iOS <em>app</em>"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Devices page",
        "Viewing the Devices page",
        "Viewing drill-down details",
        "For more help"
      ],
      "title": "Devices page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile App pages"
      ],
      "external_id": "b8bf0965c688601c352eda9c33b952a5a9e7ddae",
      "image": "https://docs.newrelic.com/static/9ecb707eee4236b41488d12707399210/c1b63/screen-mobile-devices_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/devices-page/",
      "published_at": "2021-03-11T10:56:14Z",
      "updated_at": "2021-03-11T10:56:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Devices page for New Relic Mobile provides performance details about the top devices using your mobile application, such as iPad, iPhone, iPod Touch, Android Tablet, etc. Charts compare the devices by: Interaction time HTTP request time Error rates and network failures Active user sessions From here you can drill down into details by a specific model (for example, iPhone 6, 6S, 7). Viewing the Devices page rpm.newrelic.com/mobile > (select an app) > App > Devices: Use this page to view, sort, or drill down into detailed information about the top five types of devices using your mobile app, including interaction and HTTP request times, error rates, and active users. To view performance details about your users' mobile devices: Go to rpm.newrelic.com/mobile > (select an app) > App > Devices. To select the mobile app versions or change the time period, use the Versions menu and time picker below the New Relic menu bar. Optional: Select the Sort by and Hide < 1% throughput options. To limit details to a specific device type (for example, iPad), select its name. Viewing drill-down details To drill down into detailed information, use any of New Relic's standard user interface functions and page functions to drill down into detailed information. In addition: To view a list of specific devices or models (for example, iPad mini, iPad Air, etc.), select the type (for example, iPad). To view details for a specific device or model, select its name from the expanded list. To view trace details a slow transaction (if available), select its link. For more information, see Interactions page. To return to the main Devices page, select the Close (X) button. rpm.newrelic.com/mobile > (select an app) > App > Devices > (select a device): This page provides drill-down details for the selected device, including http response time, network failures, active sessions, and slowest transaction traces (if available). For more help Additional documentation resources include: Errors page for mobile apps (detailed charts and information about errors with mobile apps) Versions analysis (seven-day report with a color-coded chart for mobile app usage, plus a table that summarizes mobile versions, date created, and averages) Monthly uniques report (bar charts showing the number of devices running your mobile app over the past 12 months)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.18744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Mobile <em>App</em> pages",
        "body": ", including interaction and HTTP request times, error rates, and active users. To view performance details about your users&#x27; mobile devices: Go to rpm.newrelic.com&#x2F;mobile &gt; (select an <em>app</em>) &gt; <em>App</em> &gt; Devices. To select the mobile <em>app</em> versions or change the <em>time</em> period, use the Versions menu and <em>time</em>"
      },
      "id": "60450de0196a67fe2c960f64"
    },
    {
      "sections": [
        "Connection types page"
      ],
      "title": "Connection types page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "55bcbe4e729ae265e295ccc01cf158f3ad66bb12",
      "image": "https://docs.newrelic.com/static/7645c44e4d34a98cf23f6250c9888a4d/8c557/connection-types.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/connection-types-page/",
      "published_at": "2021-03-11T07:26:44Z",
      "updated_at": "2021-03-11T07:26:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "one.newrelic.com > Mobile > (select an app) > Network > Connection types: Use this page to view, sort, or drill down into detailed information about your users' mobile network connection type by response time impact, network failures, and active traffic. The Connection Types page for Mobile monitoring includes charts that show your users' wireless network connection technologies and their response time impact, error rate, and active traffic for the selected time period. Data is grouped by technology generation: 2G, 3G, etc. Wifi and Unknown are also included in the connection types breakdown. From here you can drill down into specific wireless technologies like GPRS, HSDPA, and LTE. To view your users' mobile wireless connection types: Go to one.newrelic.com > Mobile > (select an app) > Network > Connection types. To change the information that appears (including response time, active devices, or network errors), select your choice from the Sort by menu. To select the mobile app versions or time period, use the Versions menu and time picker below the New Relic menu bar. To view details for a specific connection type, select its name. Use any of our standard user interface functions and page functions to drill down into detailed information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.00539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " devices, or network errors), select your choice from the Sort by menu. To select the mobile <em>app</em> versions or <em>time</em> period, use the Versions menu and <em>time</em> <em>picker</em> below the New Relic menu bar. To view details for a specific connection type, select its name. Use any of our standard user interface functions and page functions to drill down into detailed information."
      },
      "id": "604413dee7b9d26afa5799c4"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Automate workflows",
      "updated_at": "2021-03-11T01:48:25Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.0971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " Toolkit. Guides to automate workflows Quickly <em>tag</em> resources 5 min Add <em>tags</em> to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up <em>New</em> <em>Relic</em> using the Kubernetes operator 20"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Add labels/tags to synthetic monitors (deprecated)",
        "Important",
        "Requirements",
        "API examples",
        "Add a label to a monitor",
        "Get all monitors using a specific label",
        "Dissociate a label from a monitor"
      ],
      "title": "Add labels/tags to synthetic monitors (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Label examples"
      ],
      "external_id": "b5052279867282a5ecae208d273481d22b63f69b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis/",
      "published_at": "2021-03-11T10:42:02Z",
      "updated_at": "2021-03-11T10:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important On July 20, 2020, our tagging implementation replaced labels, which means that using the REST API for labels/tags is deprecated. For more information on this change, see this Explorers Hub post. To learn how to use tags, see Tags. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements The use of the REST API for labels/tags is deprecated. For current recommendations for how to add tags, see Tags. You can user the user key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'Api-Key:NEW_RELIC_USER_KEY' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Copy Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'Api-Key:NEW_RELIC_USER_KEY' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Copy Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'Api-Key:NEW_RELIC_USER_KEY' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.912476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add labels&#x2F;<em>tags</em> to synthetic monitors (deprecated)",
        "sections": "Add labels&#x2F;<em>tags</em> to synthetic monitors (deprecated)",
        "body": " The Synthetics REST API limits an account&#x27;s rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in <em>New</em> <em>Relic</em>, replace the monitor_uuid and category:label in the following example with your"
      },
      "id": "60440d9b196a673237960f66"
    },
    {
      "sections": [
        "Add browser monitoring to your Go apps",
        "Install with Go agent Browser API"
      ],
      "title": "Add browser monitoring to your Go apps",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Features"
      ],
      "external_id": "7d563ffafc7b16569d4e9e996996d8e56426ffc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/features/add-browser-monitoring-your-go-apps/",
      "published_at": "2021-03-11T10:09:02Z",
      "updated_at": "2021-03-11T10:09:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you installed New Relic's Go agent for your app, you can also use browser monitoring to monitor browser performance. To install the browser agent, use the copy and paste method, or use the Go agent API. Install with Go agent Browser API To enable support for browser monitoring, your HTML pages must include a JavaScript snippet that will load the browser agent and configure it with the correct application name. This snippet is available with the Transaction.BrowserTimingHeader method. Support for browser monitoring's timing headers is available with Go agent versions 2.5.0 or higher. Include the byte slice returned by Transaction.BrowserTimingHeader().WithTags() as early as possible in the <head> section of your HTML and after any <meta charset> tags. The JavaScript returned from Transaction.BrowserTimingHeader is request-specific. That is why it must be called on each request. func indexHandler(w http.ResponseWriter, req *http.Request) { io.WriteString(w, \"<html><head>\") // The New Relic browser javascript should be placed as high in the // HTML as possible. We suggest including it immediately after the // opening <head> tag and any <meta charset> tags. txn := newrelic.FromContext(req.Context()) hdr := txn.BrowserTimingHeader() // BrowserTimingHeader() will always return a header whose methods can // be safely called. if js := hdr.WithTags(); js != nil { w.Write(js) } io.WriteString(w, \"</head><body>browser header page</body></html>\") } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.04386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " indexHandler(w http.ResponseWriter, req *http.Request) { io.WriteString(w, &quot;&lt;html&gt;&lt;head&gt;&quot;) &#x2F;&#x2F; The <em>New</em> <em>Relic</em> browser javascript should be placed as high in the &#x2F;&#x2F; HTML as possible. We suggest including it immediately after the &#x2F;&#x2F; opening &lt;head&gt; <em>tag</em> and any &lt;meta charset&gt; <em>tags</em>. txn"
      },
      "id": "6044135328ccbc2d282c60af"
    },
    {
      "sections": [
        "Amazon VPC monitoring integration",
        "Features",
        "Activate",
        "Configuration and polling",
        "Find and use data",
        "Metric data",
        "VPC NAT Gateway data",
        "Tip",
        "VPC VPN Tunnel",
        "Inventory data"
      ],
      "title": "Amazon VPC monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "AWS integrations list"
      ],
      "external_id": "8b5f98e1853d95d8f563d8910d02abac829976cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/aws-integrations-list/aws-vpc-monitoring-integration/",
      "published_at": "2021-03-11T10:48:09Z",
      "updated_at": "2021-03-11T10:48:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations include an integration for reporting your Amazon VPC data to New Relic. This document explains how to activate the integration and describes the data reported. Features The Amazon Virtual Private Cloud (VPC) is a virtual network that utilizes the scalable infrastructure of Amazon Web Services (AWS). With New Relic's VPC integration, you can gain visibility into configuration event changes that are overlaid across your Amazon services. The Amazon VPC integration generates a feed of configuration/inventory changes that occur in your VPC. VPC data is available in pre-built dashboards, and you can create custom queries and charts in New Relic One. You can also create alert conditions to notify you about changes in the VPC. Additionally, Enhanced Amazon VPC Flow Logs enables you to capture information about IP traffic to and from network interfaces in your VPC. Activate To enable this integration follow standard procedures to Connect AWS services to New Relic. Configuration and polling You can change the polling frequency and filter data using configuration options. Default polling information for the Amazon VPC integration: Default New Relic polling interval: 15 minutes Amazon CloudWatch data interval: 1 minute Find and use data To find your integration data, go to one.newrelic.com > Infrastructure > AWS and select one of the VPC integration links. You can query and explore your data using the PrivateNetworkSample event type, with provider values of: VpcNatGateway VpcVpnTunnel By default, collection of VpcNatGateway, VpcVpnTunnel, and VpcVpnConnection data is disabled. This is because if you have many NAT gateways or many VPNs (connections and tunnels), it might lead to an increase on your CloudWatch bill. For this reason, the integration provides configuration settings to set whether you want to fetch that data. For more on how to use your data, see Understand integration data. Metric data VPC NAT Gateway data This integration collects the following data from PrivateNetworkSample with a provider value of VpcNatGateway: Tip For full descriptions, see Amazon VPC NAT Gateway Metrics and Dimensions. Name Description activeConnectionCount The total number of concurrent active TCP connections through the NAT gateway. bytesInFromDestination The number of bytes received by the NAT gateway from the destination. bytesInFromSource The number of bytes received by the NAT gateway from clients in your VPC. bytesOutToDestination The number of bytes sent out through the NAT gateway to the destination. bytesOutToSource The number of bytes sent through the NAT gateway to the clients in your VPC. connectionAttemptCount The number of connection attempts made through the NAT gateway. connectionEstablishedCount The number of connections established through the NAT gateway. errorPortAllocation The number of times the NAT gateway could not allocate a source port. idleTimeoutCount The number of connections that transitioned from the active state to the idle state. An active connection transitions to idle if it was not closed gracefully and there was no activity for the last 350 seconds. packetsDropCount The number of packets dropped by the NAT gateway. packetsInFromDestination The number of packets received by the NAT gateway from the destination. packetsInFromSource The number of packets received by the NAT gateway from clients in your VPC. packetsOutToDestination The number of packets sent out through the NAT gateway to the destination. packetsOutToSource The number of packets sent through the NAT gateway to the clients in your VPC. VPC VPN Tunnel This integration collects the following data from PrivateNetworkSample with a provider value of VpcVpnTunnel: Tip For full descriptions, see Amazon VPC VPN Metrics and Dimensions. Name Description tunnelState The state of the tunnel. 0 indicates DOWN and 1 indicates UP. tunnelDataIn The bytes received through the VPN tunnel. Each metric data point represents the number of bytes received after the previous data point. Use the Sum statistic to show the total number of bytes received during the period. tunnelDataOut The bytes sent through the VPN tunnel. Each metric data point represents the number of bytes sent after the previous data point. Use the Sum statistic to show the total number of bytes sent during the period. Inventory data This integration reports the following VPC configuration options and metadata as inventory data. For more about inventory data, see Understand integration data. Tip Tags (indicated with an *) are only fetched when tags collection is on. Inventory category Data aws/vpc/network-interface awsRegion subnetId status sourceDestCheck requesterManaged requesterId privateIpAddress privateDnsName networkInterfaceId macAddress ipv6Addresses securityGroups description availabilityZone attachmentInstanceId attachmentDeleteOnTermination attachmentStatus attachmentInstanceOwnerId publicIp publicDnsName tags * aws/vpc/endpoint awsRegion creationTimestamp policyDocumentMd5 routeTableIds serviceName state vpcId vpcEndpointId aws/vpc/nat-gateway awsRegion natGatewayId createTime natGatewayAddresses state subnetId vpcId aws/vpc/peering-connection awsRegion vpcPeeringConnectionId accepterVpcInfo requesterVpcInfo tags * aws/vpc/vpn/connection awsRegion vpnId state type category customerGatewayConfiguration vpnGatewayId customerGatewayId staticRoutesOnly tags * aws/vpc/vpn/tunnel awsRegion acceptedRouteCount outsideIpAddress status statusChange statusMessage aws/vpc/internet-gateway region internetGatewayId attachments tags * aws/vpc/network-acl region networkAclId associations entries isDefault vpcId tags * aws/vpc/route-table region routeTableId associations propagatingVgws routes vpcId tags * aws/vpc/security-group region description groupName groupId ipPermissions ipPermissionsEgress ownerId vpcId tags * aws/vpc/subnet region availabilityZone cidrBlock defaultForAz mapPublicIpOnLaunch subnetId state vpcId tags * aws/vpc/vpc region cidrBlock dhcpOptionsId enableDnsHostname enableDnsSupport instanceTenancy isDefault state vpcId tags *",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.468094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "<em>New</em> <em>Relic</em> infrastructure integrations include an integration for reporting your Amazon VPC data to <em>New</em> <em>Relic</em>. This document explains how to activate the integration and describes the data reported. Features The Amazon Virtual Private Cloud (VPC) is a virtual network that utilizes the scalable"
      },
      "id": "60450763196a678c49960f68"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-03-12T01:47:33Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.53605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "5efa999c196a67c4e1766461"
    }
  ],
  "/terms": [
    {
      "sections": [
        "New Relic One pricing: Definitions",
        "Account",
        "Commitment Term",
        "Customer Data",
        "Customer Properties",
        "Documentation",
        "GB Ingested",
        "Login Credentials",
        "Monthly Provisioned User",
        "Order",
        "Paid Terms of Service",
        "Product(s)",
        "Software",
        "Terms",
        "Third-Party Services",
        "Unpaid Terms of Service",
        "Usage Plan"
      ],
      "title": "New Relic One pricing: Definitions",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Product definitions"
      ],
      "external_id": "609575acd671fecf7899378157eabc57bc8d68e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions/",
      "published_at": "2021-03-11T07:02:43Z",
      "updated_at": "2021-03-11T07:02:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer’s websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‘Documentation’ page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer’s Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic’s customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 753.8185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Paid <em>Terms</em> of Service",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "6044e6e528ccbc26f22c6084"
    },
    {
      "sections": [
        "Developer Program Resources"
      ],
      "title": "Developer Program Resources | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "New Relic Developer edition"
      ],
      "external_id": "8a2f08905c7dcd10e50e975783ca3cf0071324c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources/",
      "published_at": "2021-03-08T15:34:10Z",
      "updated_at": "2021-03-07T14:48:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer, you are eligible to participate in New Relic’s Developer Program. Additional information and resources are available at New Relic’s Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 732.81445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you."
      },
      "id": "6044e7bb196a676d20960f4d"
    },
    {
      "sections": [
        "Preview access for New Relic One"
      ],
      "title": "Preview access for New Relic One | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Licenses",
        "Product or service licenses",
        "New Relic One"
      ],
      "external_id": "5a11f3d0ff23ad22ec459a0115a70ddbb2964d1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one/",
      "published_at": "2021-03-08T15:36:03Z",
      "updated_at": "2021-03-02T18:51:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 605.10767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "603e891464441f2af14e883b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/FutureStack_FS_2021_Mario_flower_dark.png?h=655eccb1&itok=8oM4fyBm",
      "url": "https://newrelic.com/futurestack/speakers/vidwan-katuri",
      "sections": [
        "Vidwan Katuri",
        "Meet Our Speakers",
        "Justin Eveland",
        "JD Weiner",
        "Mark Weitzel",
        "Mason Jones",
        "Colin MacNaughton",
        "Mike Neville-O'Neill",
        "Peter Espe",
        "Aaron Judy",
        "Rohit Kaul",
        "Naveen Chittoor",
        "Alec Isaacson",
        "Lew Cirne",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-03-06T00:50:40Z",
      "title": "Vidwan Katuri | New Relic",
      "updated_at": "2021-03-06T00:50:40Z",
      "type": "",
      "external_id": "81d94cae1dc013a2f201b26214a3e420b7d06c54",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Register Main navigation menu, 1 item Vidwan Katuri Director, Cloud Infra, 7-11 Meet Our Speakers Justin Eveland Software Engineer New Relic Learn more JD Weiner Manager of Operations Forbes Media LLC Learn more Mark Weitzel Vice President of Developer Platform and Ecosystem New Relic Learn more Mason Jones Senior Staff Site Reliability Engineer Credit Karma Learn more Colin MacNaughton Staff Engineer New Relic Learn more Mike Neville-O'Neill Senior Manager, Product Management New Relic Learn more Peter Espe Infrastructure Engineer Credit Karma Learn more Aaron Judy Chief of Innovation and AI Maricopa County Clerk of the Superior Court Learn more Rohit Kaul Senior Partner Solutions Consultant New Relic Learn more Naveen Chittoor Application Support Engineer Cox Communications Inc Learn more Alec Isaacson Pre-Sales Solutions Architect New Relic Learn more Lew Cirne CEO and Founder New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. Registration Opens March 1, 2021. #futurestack Add to Google Cal Download ICS Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 513.44244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Registration Opens March 1, 2021. #futurestack Add to Google Cal Download ICS Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "6042d1e028ccbc5aeb2c60cc"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/FutureStack_FS_2021_ghost_dark_0.png?h=f2247767&itok=Ck7VfZxt",
      "url": "https://newrelic.com/futurestack/speakers/mark-weitzel",
      "sections": [
        "Mark Weitzel",
        "Meet Our Speakers",
        "Jonan Scheffler",
        "Nicole van der Hoeven",
        "Bill Staples",
        "Sagar Thirumala",
        "Jemiah Sius",
        "Matthew Culmone",
        "Lew Cirne",
        "Sergio Rabiela",
        "Dan Rufener",
        "Nočnica Fee",
        "Micheal Caron",
        "Sandeep Parmarq",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-03-06T00:49:27Z",
      "title": "Mark Weitzel | New Relic",
      "updated_at": "2021-03-06T00:49:27Z",
      "type": "",
      "external_id": "b812fa8bd8cbd0c9824127961fa112be633ded69",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Register Main navigation menu, 1 item Mark Weitzel Vice President of Developer Platform and Ecosystem, New Relic on Twitter on LinkedIn Meet Our Speakers Jonan Scheffler Director, Developer Relations New Relic Learn more Nicole van der Hoeven Developer Advocate k6.io Learn more Bill Staples President and Chief Product Officer New Relic Learn more Sagar Thirumala Administrator Cox Communications Inc Learn more Jemiah Sius Senior Product Manager New Relic Learn more Matthew Culmone Senior Manager, Product Management New Relic Learn more Lew Cirne CEO and Founder New Relic Learn more Sergio Rabiela Vice President of Technology Beyond Finance, Inc Learn more Dan Rufener Principal Software Engineer New Relic Learn more Nočnica Fee Developer Advocate New Relic Learn more Micheal Caron Senior Technical Training Specialist New Relic Learn more Sandeep Parmarq Pre-Sales Solutions Architect New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. Registration Opens March 1, 2021. #futurestack Add to Google Cal Download ICS Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 513.4263,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Registration Opens March 1, 2021. #futurestack Add to Google Cal Download ICS Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "6042d19728ccbc8dd92c60a1"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "sections": [
        "Add custom data to mobile monitoring",
        "Choose a custom data type",
        "Add session-level custom attributes",
        "Record breadcrumbs",
        "Create custom interactions",
        "Record custom events"
      ],
      "title": "Add custom data to mobile monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile",
        "Maintenance"
      ],
      "external_id": "81d73d6610c6cc08cc21a5dbbb1ee1e507f6db16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile/maintenance/add-custom-data-new-relic-mobile/",
      "published_at": "2021-03-11T11:17:19Z",
      "updated_at": "2021-03-11T11:17:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic mobile monitoring includes a number of ways to customize and extend the data your mobile app reports. We refer to this type of implementation as \"custom instrumentation.\" This document explains how to get additional data into New Relic, and how to view that new data in the UI. Choose a custom data type You can use these options to create your own data types for custom instrumentation for your mobile apps. Using these four options, you can get a wide range of data based on your needs for your apps. Custom data options Description Session-level custom attributes In creating your own attributes, consisting of a key-value pair, you can add custom data for use in tracking session data. Custom breadcrumbs Useful for troubleshooting crash causes, custom breadcrumb events track the user's code-level path through the app by seeing which breadcrumb API calls were reached and reporting app status details from those moments. Custom interactions Custom interactions give you tracing power so you can debug method timings and improve network call efficiency. A common use of interactions is to understand the underlying activity associated with loading a particular app screen. Custom events You can instrument custom events to collect data about user activity as a user navigates through your app. That user activity will in turn trigger other data collection: a collection of breadcrumbs, auto-instrumented HTTP requests and errors, auto-instrumented interactions, and custom interactions. Add session-level custom attributes Custom attributes annotate (or \"tag\") your mobile monitoring data. A custom attribute consists of a key-value pair. For example, you might create the key userEmail with values such as alice@bigcorp.test and bob@example.com. The agent automatically attaches custom attributes to default mobile monitoring data, and to any breadcrumbs or custom events you create. You can use custom attributes to capture usage data that's relevant to your business. Common examples include account names or IDs, user emails, and subscription levels. You can then filter and facet in the Crash analysis page and via NRQL query. Setting custom attributes will add the key-value pair information at the session level. All default mobile monitoring events inherit these session-level custom attributes. As a best practice, use custom attributes to track a single value for a key that can be true across a session (for example, a user's subscription level, or whether SAML was used to log in). To track the change of a value over the course of a session, like a change in connection type, you would instead record a breadcrumb and its own custom attributes. To track a series of discrete user actions that occur across the course of a session, use custom events. To add custom attributes, see: Android: Use setAttribute() and incrementAttribute(). iOS: Use setAttribute() and incrementAttribute(). Record breadcrumbs Breadcrumbs track the state of your app as it runs, then report a snapshot of that state if your app crashes. This allows you to debug your mobile app crashes more easily. Custom interactions only inherit custom attributes created at the session level. Breadcrumbs will inherit those same session-level custom attributes, but optionally you can also report additional custom attributes specific to each recordBreadcrumb() API call. You can use breadcrumbs in several ways: You could record a breadcrumb event when your app receives an HTTP response, and also record the values in that response as custom attributes (for example, the response might tell the app what screen to display next or recording unique timestamps for each change in the course of a session). If the app crashes or throws errors, you will be able to see invalid data from the HTTP response. You could track the success of each step of your user login process, with perhaps a status attribute recording a success or failure key for each step. This would let you debug which step is causing issues. Once you have released a version of your app that creates MobileBreadcrumb custom events, you can see them in the crash event trail whenever they appear in the app's code path as part of a crashed session. You can also query them using NRQL and query either all breadcrumbs or just breadcrumbs from crashed sessions. This lets you see the frequency of app paths that include that particular breadcrumb. To add custom breadcrumbs, see: Android: Use recordBreadcrumb(). iOS: Use recordBreadcrumb(). Create custom interactions Our mobile monitoring agent begins instrumenting an interaction when it detects a screen load or partial screen load (such as fragments for Android or view controllers for iOS). New Relic automatically traces slow interactions, providing a complete, in-depth picture of a single slow interaction, including the methods that were called, what network requests were made, and the CPU and memory usage once that interaction started. Our mobile monitoring automatically selects data-rich traces. The specific criteria the agent looks for are interactions whose instrumented methods account for at least 30% of the overall interaction time. In addition to the auto-instrumentation, you can start a custom interaction to force the agent to start recording a trace beginning at that point in your app code and continuing across the subsequent methods and network calls. Custom interaction traces provide deep information. However, they increase the overhead of the agent compared to other custom data collection methods because of the large amount of data collected for the entire duration of an interaction. When associated with a crash, custom interactions show up in the crash event trail. You can also query them with NRQL for flexible analysis. Interactions are powerful for tracing but are less flexible in other ways than other custom data types: While custom breadcrumbs and custom events let you optimize your custom attributes to specific events, interactions can only inherit session-level attributes. You can also manually end a custom interaction. However, ensure that the interaction includes enough method activity to be recorded. If the agent does not detect any traced activity for 0.5 seconds, the agent stops the interaction tracing because it is assumed no interesting data remains. In addition, the agent can only trace one interaction at a time, so if a new interaction is triggered the current trace will automatically be stopped in preference for the new trace. To add custom interaction traces, see: Android: Use startInteraction() and endInteraction(). iOS: Create and complete interactions. You can also configure interaction tracing globally: Android: Disable entirely with withInteractionTracing(), or disable only auto-instrumented traces with withDefaultInteractions(). iOS: Disable entirely with NRFeatureFlag_InteractionTracing(), or disable only auto-instrumented traces with NRFeatureFlag_DefaultInteractions(). Record custom events Custom events are a powerful tool for reporting arbitrary user activity to New Relic. When associated with a crash, custom events show up in the crash event trail. You can also query them with NRQL for flexible analysis. Unlike custom interactions, custom events allow you to add custom attributes to a particular event within the user session. For example, you could record a custom event each time a user taps a button or accesses a certain feature, and then use NRQL to track how often that feature was used. Beyond a simple count, you can FACET on default mobile app attributes such as location, device, or carrier to analyze usage. Adding session-level custom attributes would let you further examine usage based on the criteria important to you, such as user subscription level or other user characteristics. Adding additional attributes for that custom event would allow you to track user behavior more closely: What data did they enter or what option did they select, for example. To add custom events, see: Android: Use recordCustomEvent(). iOS: Use recordCustomEvent().",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.39076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>custom</em> data to mobile monitoring",
        "sections": "Add session-level <em>custom</em> <em>attributes</em>",
        "body": " in the Crash analysis page and via <em>NRQL</em> query. Setting <em>custom</em> <em>attributes</em> will add the key-value pair information at the session level. All default mobile monitoring events inherit these session-level <em>custom</em> <em>attributes</em>. As a best practice, use <em>custom</em> <em>attributes</em> to track a single value for a key"
      },
      "id": "60450e5028ccbc3cfd2c60d2"
    },
    {
      "sections": [
        "add_custom_span_attribute (Python agent API)",
        "Syntax",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Adding custom attributes to background task",
        "Using custom span attribute to troubleshoot"
      ],
      "title": "add_custom_span_attribute (Python agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Python agent API"
      ],
      "external_id": "56801da179e90f928236e8ad3783df32f414af5a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/python-agent-api/addcustomspanattribute-python-agent-api/",
      "published_at": "2021-03-11T07:12:43Z",
      "updated_at": "2021-03-11T07:12:43Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.agent.add_custom_span_attribute(key, value) Copy Adds a custom attribute to a span event. Description This call records a custom attribute (a key/value pair attached to your span event). Attributes may be found in Distributed Tracing or in APM if a transaction trace is created by the parent transaction. Attributes can also be found and queried in New Relic One. Important Before you create custom attributes, review our list of reserved terms used by NRQL. Parameters Parameter Description key string Required. The key name. Only the first 255 characters are retained. value string, integer, float, boolean Required. The string value to add to the current span event. Only the first 255 characters are retained. Return values Returns True if attribute was added successfully.  Examples Adding custom attributes to background task An example of adding custom attributes to a background task: @newrelic.agent.background_task() def send_request(): with newrelic.agent.FunctionTrace(name='Trace'): newrelic.agent.add_custom_span_attribute('attribute', 'value') Copy Using custom span attribute to troubleshoot You can also use custom attributes to troubleshoot performance issues. For example, you might see occasional slow response times from a pool of memcache instances, but you don't know what instance is causing the problem. You might add an attribute to the span indicating the server, like so: # Set server_ip to be the current server processing the transaction newrelic.agent.add_custom_span_attribute(\"memcache_query_frontend_lookup\", server_ip) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.37158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Adding <em>custom</em> <em>attributes</em> to background task",
        "body": " by the parent transaction. <em>Attributes</em> can also be found and queried in New Relic One. Important Before you create <em>custom</em> <em>attributes</em>, review our list of reserved terms used by <em>NRQL</em>. Parameters Parameter Description key string Required. The key name. Only the first 255 characters are retained. value string"
      },
      "id": "604400d128ccbc356e2c609d"
    },
    {
      "sections": [
        "setCustomAttribute (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-03-11T09:25:20Z",
      "updated_at": "2021-03-11T09:25:20Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description The Browser API call adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the Browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavasScript/jQuery to get the values of the following HTML elements on the Drupal-generated pages for New Relic's Docs site: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.78133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-generated pages for New Relic&#x27;s Docs site: &lt;link rel=&quot;shortlink&quot; href=&quot;&#x2F;node&#x2F;1111&quot; &#x2F;&gt; &lt;h1&gt;Using <em>NRQL</em>&lt;&#x2F;h1&gt; New Relic reports them as <em>custom</em> <em>attributes</em>. This is useful to query PageView and PageAction events in New Relic One. var node_id = &#x27;&#x27;; node_id= jQuery(&quot;link[rel=&#x27;shortlink&#x27;]&quot;).attr(&quot;href&quot;); var"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "newrelic_add_custom_parameter (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Report a variable as the value"
      ],
      "title": "newrelic_add_custom_parameter (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "9f562ac35bc082317e33be4164651edf38016ccd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_parameter/",
      "published_at": "2021-03-11T06:57:21Z",
      "updated_at": "2021-03-11T06:57:20Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_parameter(string $key, scalar $value) Copy Attaches a custom attribute (key/value pair) to the current transaction and the current span (if enabled). Requirements Agent version 4.4.5.35 or higher. Description Add a custom attribute (a key and a value data pair) to the current web transaction. (The call name is newrelic_add_custom_parameter because \"custom attributes\" were previously called \"custom parameters.\") For example, you can add a customer's full name from your customer database. This attribute appears in any transaction trace that results from this transaction. You can also query the Transaction event for your custom attributes. Important Security recommendation—Review your Transaction attributes configuration. Any attribute include or exclude settings specific to Transaction events, should be applied to your Span attributes configuration or your Global Attributes configuration. Important If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL. Parameters Parameter Description $key string Required. The name of the custom attribute. Only the first 255 characters are retained. $value scalar Required. The value to associate with this custom attribute. If the value given is a float with a value of NaN, Infinity, denorm or negative zero, the behavior of this function is undefined. For other floating point values, the agent may discard 1 or more bits of precision (ULPs) from the given value. Return values Returns true if the parameter was added successfully. Examples Report a variable as the value ... if (extension_loaded('newrelic')) { // Ensure PHP agent is available // Record custom data about this web transaction newrelic_add_custom_parameter ('user_email', $user_email); } ... Copy - ->",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.72516,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Global <em>Attributes</em> configuration. Important If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em>. Parameters Parameter Description $key string Required. The name of the <em>custom</em> attribute. Only the first 255 characters are retained. $value scalar Required. The value"
      },
      "id": "6043c95064441f61fd378eef"
    },
    {
      "sections": [
        "add_custom_parameter (Python agent API)",
        "Syntax",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Adding custom parameters to background task",
        "Using custom parameters to troubleshoot"
      ],
      "title": "add_custom_parameter (Python agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Python agent API"
      ],
      "external_id": "50a4b6e0a9a3d3861931db87297012f3967a7193",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/python-agent-api/addcustomparameter-python-agent-api/",
      "published_at": "2021-03-11T07:12:43Z",
      "updated_at": "2021-03-11T07:12:43Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.agent.add_custom_parameter(key, value) Copy Adds a custom attribute to a transaction. Description This call records a custom attribute (a key/value pair attached to your transaction). (The call name is add_custom_parameter because \"custom attributes\" were previously called \"custom parameters.\") Attributes may be found in APM if the transaction is associated with an error or if a transaction trace is generated for that transaction. Attributes can also be found and queried in New Relic One. Important Before you create custom attributes, review our list of reserved terms used by NRQL. Parameters Parameter Description key string Required. The key name. Only the first 255 characters are retained. value string, integer, float, boolean Required. The string value to add to the current transaction. Only the first 255 characters are retained. Return values Returns True if attribute was added successfully.  Examples Adding custom parameters to background task An example of adding custom parameters to a background task: @newrelic.agent.background_task() def send_request(): response = requests.post('http://URL_path', headers=headers, data=data) newrelic.agent.add_custom_parameter('url_path_status_code', response.status_code) Copy Using custom parameters to troubleshoot You can also use custom parameters to troubleshoot performance issues. For example, you might see occasional slow response times from a pool of memcache instances, but you don't know what instance is causing the problem. You might add an attribute to the transaction indicating the server, like so: # Set server_ip to be the current server processing the transaction newrelic.agent.add_custom_parameter(\"memcache_query_frontend_lookup\", server_ip) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.10274,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Adding <em>custom</em> parameters to background task",
        "body": "Syntax newrelic.agent.add_<em>custom</em>_parameter(key, value) Copy Adds a <em>custom</em> attribute to a transaction. Description This call records a <em>custom</em> attribute (a key&#x2F;value pair attached to your transaction). (The call name is add_<em>custom</em>_parameter because &quot;<em>custom</em> <em>attributes</em>&quot; were previously called &quot;<em>custom</em>"
      },
      "id": "6043ff58196a679fe9960f79"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-03-12T01:46:22Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 428.4347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6046d422e7b9d27a66579a0b"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.9245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "601df6bb196a67eb59da2d81"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-03-11T03:15:01Z",
      "updated_at": "2021-03-11T03:15:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If this is a sub-account, the list shows only the sub-account users, not all the users in the master account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.59953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View or update user email <em>channels</em>",
        "sections": "View or update user email <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "&#x27;s <em>notification</em> <em>channel</em>. To add or update account users as <em>notification</em> channels for a policy: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click Policies, and then choose the policy you want to change. Optional: You can update <em>notification</em> channels for specific users. On the <em>Notification</em>"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.0341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "5efa999d196a67300c766404"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-03-12T01:49:20Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.05075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Automate workflows",
      "updated_at": "2021-03-11T01:48:25Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.41562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " min Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Getting started with <em>New</em> <em>Relic</em> and Terraform 30 min Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform Set up <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-03-12T01:46:22Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.47073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Add labels/tags to synthetic monitors (deprecated)",
        "Important",
        "Requirements",
        "API examples",
        "Add a label to a monitor",
        "Get all monitors using a specific label",
        "Dissociate a label from a monitor"
      ],
      "title": "Add labels/tags to synthetic monitors (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Label examples"
      ],
      "external_id": "b5052279867282a5ecae208d273481d22b63f69b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis/",
      "published_at": "2021-03-11T10:42:02Z",
      "updated_at": "2021-03-11T10:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important On July 20, 2020, our tagging implementation replaced labels, which means that using the REST API for labels/tags is deprecated. For more information on this change, see this Explorers Hub post. To learn how to use tags, see Tags. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements The use of the REST API for labels/tags is deprecated. For current recommendations for how to add tags, see Tags. You can user the user key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'Api-Key:NEW_RELIC_USER_KEY' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Copy Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'Api-Key:NEW_RELIC_USER_KEY' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Copy Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'Api-Key:NEW_RELIC_USER_KEY' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.818,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add labels&#x2F;<em>tags</em> to synthetic monitors (deprecated)",
        "sections": "Add labels&#x2F;<em>tags</em> to synthetic monitors (deprecated)",
        "tags": "<em>APIs</em>",
        "body": " specific values. curl -v -X POST -H &#x27;<em>Api</em>-<em>Key:NEW_RELIC_USER_KEY</em>&#x27; -H &#x27;Content-Type: application&#x2F;json&#x27; https:&#x2F;&#x2F;synthetics.newrelic.com&#x2F;synthetics&#x2F;<em>api</em>&#x2F;v4&#x2F;monitors&#x2F;monitor_uuid&#x2F;labels -d &#x27;category:label&#x27; Copy Get all monitors using a specific label To view a list of all monitors in <em>New</em> <em>Relic</em> that have"
      },
      "id": "60440d9b196a673237960f66"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-03-12T01:38:55Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-26T01:39:58Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.8469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Kubernetes manifest examples",
        "Configure",
        "Tip",
        "Example of custom configuration",
        "Docker: overwrite default configuration",
        "Kubernetes: overwrite default configuration",
        "Metric format",
        "Metric types",
        "Counter",
        "Gauge",
        "Timer",
        "Add tags (attributes)",
        "Add default tags that apply to all metrics",
        "Add metric-level tags",
        "Create alerts",
        "Alert example",
        "Find and use data",
        "Check the source code"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "85d86411ef83d98a2d2ab602f1259b71864e056d",
      "image": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/images/statsd-nrql-alert-condition-example.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2/",
      "published_at": "2021-03-12T01:52:21Z",
      "updated_at": "2021-03-10T01:41:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Copy Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ Copy After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" Copy service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd Copy For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. Tip To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$ _ NR_ACCOUNT_ID/events' _ address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Copy Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Copy To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Copy Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' Copy To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Copy Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Copy Here are explanations of these fields: Field name Description < metric name> string Required. Name of the metric. < value> string Required. The metric type: c = counter g = gauge ms = timer @ < sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. # < tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c Copy At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Copy Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g Copy If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second Copy The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles Copy The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Copy Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Copy Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> Copy In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Copy Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Copy Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Copy Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Copy Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' Copy For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.36539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tags</em> (attributes)",
        "body": "-format data into <em>New</em> <em>Relic</em>. You can also add any arbitrary <em>tags</em> (<em>key</em>-value pairs) to your data. Once your metrics are in <em>New</em> <em>Relic</em>, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric <em>API</em> and our Event <em>API</em> to ingest data. To use these APIs"
      },
      "id": "6043a32364441fa554378eee"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "sections": [
        "New Relic Flex: Build your own integration",
        "What is Flex?",
        "Requirements",
        "How does Flex work?",
        "Example config",
        "Learn more"
      ],
      "title": "New Relic Flex: Build your own integration",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Instrument everything",
        "Develop your own integrations"
      ],
      "external_id": "d9e77fa458eb408a90de1ebdd60891694ea6feb2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/flex-integration-tool-build-your-own-integration/",
      "published_at": "2021-03-11T08:47:42Z",
      "updated_at": "2021-03-11T08:47:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic provides integrations for many popular services and frameworks. If you have New Relic and want to report data from a service we don't have an integration for, there are several ways New Relic lets you create your own integration: With New Relic infrastructure monitoring, you can use our lightweight Flex tool (recommended, documented below) or, to build a complete on-host integration, see our Integrations SDK. Telemetry (metrics, traces) monitoring solutions: Use our Telemetry SDKs. Build a custom New Relic One application that uses your own JavaScript UI functionality. What is Flex? New Relic Flex is an application-agnostic, all-in-one tool that allows you to collect metric data from a wide variety of services. It comes bundled with our infrastructure agent. You can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text): you create a YAML config file, start the Infrastructure agent, and your data is reported to New Relic. Flex can send event and metric data to New Relic from a wide range of sources. Using a simple YAML config file, you can run HTTP/HTTPS requests, run shell commands, and parse file content. You can also use standard regex expressions to customize and control the data gathered from those inputs. See an example config. After collecting and cleaning up the data, you can then query Flex data in New Relic, create custom charts for it, and use that data in your dashboards. Requirements Flex comes bundled with our infrastructure agent. To use Flex, you need: Infrastructure agent version 1.10.7 or higher (update | check version) running on Linux, Windows, or Kubernetes. How does Flex work? Flex uses our infrastructure agent to execute commands that generate the data you want to report. Here's a brief overview of how Flex works to report data: You define the data you want to report in a YAML configuration file, located in the infrastructure agent package. See an example configuration: Example config The following is an example of a Flex configuration for monitoring the uptime of a Linux server. This configuration is placed in a file named flex-uptime.yml. This would be placed in the infrastructure agent's integration configuration section, located at /etc/newrelic-infra/integrations.d/flex-uptime.yml. integrations: - name: nri-flex config: name: linuxUptimeIntegration apis: - name: Uptime commands: - run: 'cat /proc/uptime' split: horizontal split_by: \\s+ set_header: [uptimeSeconds,idletimeSeconds] Copy Some notes on what this configuration does: run defines the command to execute. The name indicated by name: Uptime is appended with Sample to generate an event called UptimeSample. The name should not start with the ESX or PCF prefix. The split_by: \\s+ splits the fields based on the space character. The command generates attributes attached to the UptimeSample event. The attributes are named uptimeSeconds and idletimeSeconds. The infrastructure agent runs Flex at a frequency based on its own configuration (default: every 30 seconds) and sends the data to New Relic. You can then query your data, create custom charts with it, and add it to dashboards. Learn more The Flex integration comes bundled with the infrastructure agent. Learn more about requirements. To learn more, see our complete documentation on GitHub: README Tutorial",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.8667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Flex: Build <em>your</em> own integration",
        "sections": "New Relic Flex: Build <em>your</em> own integration",
        "tags": "Full-<em>Stack</em> Observability",
        "body": "New Relic provides integrations for many popular services and frameworks. If you have New Relic and want to report data from a service we don&#x27;t have an integration for, there are several ways New Relic lets you create <em>your</em> own integration: With New Relic infrastructure monitoring, you can use our"
      },
      "id": "6044e44f196a678d15960f6e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Automate workflows",
      "updated_at": "2021-03-11T01:48:25Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.58844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " Toolkit. Guides to <em>automate</em> workflows Quickly <em>tag</em> resources 5 min Add tags to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> 30 min See how easy it is to leverage automation in <em>your</em> DevOps environment! Set up New Relic using the Kubernetes operator 20"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity"
      ],
      "title": "NerdGraph tagging API tutorial | New Relic Documentation",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b62313b6fa10ab235c031feae23d6fe52163b703",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial/",
      "published_at": "2021-03-08T15:37:03Z",
      "updated_at": "2021-03-02T22:52:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can add tags to your data to help improve data organization and findability. Learn more about tagging at New Relic. This doc explains how to use our NerdGraph API to add and manage tags. For a guide to automating tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } Copy The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Copy Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Copy Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Copy Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace the entity’s entire set of tags with the provided tag set: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.70706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial | New Relic Documentation",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "body": " the <em>taggingDeleteTag</em>FromEntity mutation. The following example mutation removes the team <em>tag</em> from an entity: mutation { <em>taggingDeleteTag</em>FromEntity ( guid: &quot;ENTITY_GUID&quot;, <em>tag</em>Keys: [&quot;team&quot;]) { errors { message } } } Copy Delete specific <em>tag</em> values for an entity Instead of deleting an <em>entire</em> <em>tag</em> and all of its values, you can"
      },
      "id": "603ec1c6196a67eeada83d9a"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Use tags to filter the UI",
        "Custom queries and charts"
      ],
      "title": "Use tags to help organize and find your data | New Relic Documentation",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-03-08T15:31:48Z",
      "updated_at": "2021-03-02T22:32:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). And you can also add your own custom tags. You can use tags in the UI to filter down to relevant data, as shown here: Here you can see an accountId tag being used to filter workloads for a specific account. You can use tags to: Help organize data coming from a large number of sources and/or to a large number of New Relic accounts Identity teams, roles, environment, or regions to know who’s responsible for what (see example use cases) Better organize and search dashboards and workloads Tags are useful for organizing data at a high level. If you wanted to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events would be a better solution. Tip At New Relic, tags were previously called \"labels.\" You may sometimes see \"label\" used in our code; for example, some of our APM agent config files use a label config option for tags. Keep reading to learn more about tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, read the best practices below to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Be consistent with capitalization. For example, avoid using both env: staging and env: Staging (although tag searching is case-insensitive in the UI and API) Tips on cross-team implementation: One reason for using tags is to improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Keep this reference manual up-to-date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can apply tags via the UI and API or you can add tags using APM agent configuration: C SDK: not available Go .NET Node.js PHP Python Ruby Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Use tags to filter the UI Use the filter field at the top of the entity explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Entity explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries and charts As explained in Tag sources, some attributes are available as tags. You can query attributes and create custom charts using NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.85791,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find <em>your</em> data | New Relic Documentation",
        "sections": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "body": " reports that identify entities that are non-compliant with <em>your</em> <em>tagging</em> standards. <em>Tag</em> examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Add labels/tags to synthetic monitors (deprecated)",
        "Important",
        "Requirements",
        "API examples",
        "Add a label to a monitor",
        "Get all monitors using a specific label",
        "Dissociate a label from a monitor"
      ],
      "title": "Add labels/tags to synthetic monitors (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Label examples"
      ],
      "external_id": "b5052279867282a5ecae208d273481d22b63f69b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis/",
      "published_at": "2021-03-11T10:42:02Z",
      "updated_at": "2021-03-11T10:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important On July 20, 2020, our tagging implementation replaced labels, which means that using the REST API for labels/tags is deprecated. For more information on this change, see this Explorers Hub post. To learn how to use tags, see Tags. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements The use of the REST API for labels/tags is deprecated. For current recommendations for how to add tags, see Tags. You can user the user key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'Api-Key:NEW_RELIC_USER_KEY' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Copy Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'Api-Key:NEW_RELIC_USER_KEY' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Copy Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'Api-Key:NEW_RELIC_USER_KEY' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.27653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add labels&#x2F;<em>tags</em> to synthetic monitors (deprecated)",
        "sections": "Add labels&#x2F;<em>tags</em> to synthetic monitors (deprecated)",
        "body": "Important On July 20, 2020, our <em>tagging</em> implementation replaced labels, which means that using the REST API for labels&#x2F;tags is deprecated. For more information on this change, see this Explorers Hub post. To learn how to use tags, see Tags. You can make API calls for synthetic monitors"
      },
      "id": "60440d9b196a673237960f66"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Tip",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "4cc9878a6fd53a3602eedd978303457aab82ac4e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-03-08T15:36:39Z",
      "updated_at": "2021-03-02T20:35:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Tip To use our Telemetry SDKs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.35693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data | New Relic Documentation",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the <em>Metric</em> <em>API</em>, <em>Trace</em> <em>API</em>, Log <em>API</em>, and <em>Event</em> <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-03-08T15:33:53Z",
      "updated_at": "2021-03-06T21:14:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data | New Relic Documentation",
        "sections": "Report custom <em>event</em> data",
        "tags": "<em>Event</em> data sources",
        "body": " of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention."
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-580/",
      "sections": [
        "Java agent v5.8.0",
        "New features",
        "New OSS SDK",
        "Fixes"
      ],
      "published_at": "2021-03-11T03:27:07Z",
      "title": "Java agent v5.8.0",
      "updated_at": "2021-03-11T03:27:07Z",
      "type": "docs",
      "external_id": "a1ed5e73234f5b76169939e739446fd0c8c3ae05",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New features gRPC gRPC error reporting is now configurable Response codes, component type, and method type are now recorded as attributes. The agent now reports the gRPC status code rather than \"translating\" to HTTP status codes. Vert.x The Java agent now provides visibility into your applications built using the Vert.x 3.8. The agent instruments Vert.x Web, Vert.x Core, and Vert.x HTTP client. With this instrumentation, the agent will identify and name your transactions based on Vert.x web routing paths. The agent will also time web handlers, track async handlers, and external calls made with Vert.x HTTP client. XML custom instrumentation The custom XML instrumentation XSD has been enhanced to support now include support for specifying leaf tracers. Class Histogram A new Class Histogram extension is now available to report heap memory details as events. Jedis Added support for Jedis 3.0.0 and higher. You can now see your Jedis calls in breakdowns in the overview chart, entries in the Databases tab, and segments in transaction traces. Lettuce Instrumentation modules for Lettuce 4 and 5 are now available via the Java agent incubator. New OSS SDK We now have an open source Telemetry SDK for Java for sending telemetry data to New Relic. The current SDK supports sending dimensional metrics to the Metric API and spans to the Trace API. Fixes The Solr 7 instrumentation would not report Update JMX metrics. HttpURLConnection instrumentation produced External metrics only when network methods (getInputStream, getResponseCode) are called. MongoDB instrumentation would report duplicate metrics when applications invoked MongoClientOptions.build() more than once.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.53769,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java <em>agent</em> v5.8.0",
        "sections": "Java <em>agent</em> v5.8.0",
        "body": " <em>SDK</em> for Java for sending <em>telemetry</em> data to New Relic. The current <em>SDK</em> supports sending dimensional metrics to the <em>Metric</em> <em>API</em> and spans to the <em>Trace</em> <em>API</em>. Fixes The Solr 7 instrumentation would not report Update JMX metrics. HttpURLConnection instrumentation produced External metrics only when"
      },
      "id": "60444413196a67a317960f3f"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "a8978f1c0acce16e111b6680fa02b8f2b0fd4b04",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-03-11T08:47:43Z",
      "updated_at": "2021-03-10T02:08:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. New Relic provides a powerful GraphQL tool to explore the API with embedded schema definitions. To get started, go to api.newrelic.com/graphiql. Tip For sample queries and mutations, use our NerdGraph tutorials. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights API resources for Insights include: Resource Details Insert events API To report custom data use the Event insertion API. Query API To query your Insights data using NRQL-formatted queries, use the Query API. This API can also be used to retrieve subscription usage data. Dashboard API To create, read, update, and delete dashboards, use the Dashboard API. Other New Relic product APIs You can also report custom data from other New Relic features. For more information, see the API sections for other products. NerdGraph You can use NerdGraph (our GraphQL API) to query data with NRQL. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.89232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>Telemetry</em> <em>APIs</em> for core data types",
        "tags": "<em>APIs</em>",
        "body": " core data types (metrics, logs, traces, and events) into New Relic without the use of an installed <em>agent</em>. Data type Description <em>Trace</em> <em>API</em> Send distributed tracing data to New Relic. <em>Event</em> <em>API</em> Send <em>event</em> data to New Relic. <em>Metric</em> <em>API</em> Send metrics to New Relic from any source (including other"
      },
      "id": "6043a36e64441f965e378ef4"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications"
      ],
      "title": "Get data into New Relic | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "3fa26c40c4e8304f45c465d5565f6b428ba085da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-03-08T15:33:59Z",
      "updated_at": "2021-03-02T21:30:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.91733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications."
      },
      "id": "603eae7b196a671ea3a83dc7"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Build a custom visualization for dashboards",
        "Add a table to your app",
        "Permissions for managing applications",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Build apps",
      "updated_at": "2021-03-11T01:51:44Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Build a custom visualization for dashboards 15 min Create custom data views Add a table to your app 30 min Add a table to your New Relic One app Permissions for managing applications   Learn about permissions for subscribing to apps Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.49832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " Permissions for managing applications   Learn about permissions for subscribing to <em>apps</em> Create a custom map view 30 min Build an <em>app</em> to show page view data on a map <em>Publish</em> and <em>deploy</em> <em>apps</em> 30 min Start sharing the <em>apps</em> you build Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure and deploy",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "28df1194ff848b2c26e5c966843d2bf5f0adbf9e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment/",
      "published_at": "2021-03-11T07:59:34Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Copy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.02988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "6043d8da28ccbc08242c60a6"
    },
    {
      "sections": [
        "Install the Go agent in GAE flexible environment",
        "Important",
        "Build a custom runtime using Docker",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure a Dockerfile",
        "4. Build a Docker image",
        "5. Deploy Docker image to initialized GAE flexible environment",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Installation"
      ],
      "external_id": "9d2ddffb83697c6191c0b6abaed8839516b3aa54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment/",
      "published_at": "2021-03-11T07:58:24Z",
      "updated_at": "2021-03-11T07:58:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. Important The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go Copy 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . Copy 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Copy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Copy Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.041275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "2. Configure your <em>app.yaml</em>",
        "body": " the gcloud command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy 3. Configure a Dockerfile The Dockerfile"
      },
      "id": "6043cd7164441fc312378efe"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-03-12T01:47:32Z",
      "updated_at": "2020-12-04T01:59:58Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they’ve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren’t an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 50.083256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read on to learn about permissions"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/advanced-installation/install-new-relic-php-agent-gae-flexible-environment/",
      "sections": [
        "Install New Relic PHP agent in GAE flexible environment",
        "Important",
        "Build a custom runtime using Docker",
        "1. Set up the GAE project and install dependencies",
        "2. Extend the GAE image for PHP",
        "3. Configure your app.yaml",
        "4. Build a Docker image",
        "5. Deploy Docker image to initialized GAE flexible environment",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "published_at": "2021-03-08T15:32:21Z",
      "title": "Install New Relic PHP agent in GAE flexible environment | New Relic Documentation",
      "updated_at": "2021-03-07T00:18:23Z",
      "type": "docs",
      "external_id": "680be1913cb9c8bab2891d49820e2d54bf727eb9",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic APM's PHP agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic APM, Browser, and Insights. This document explains how to add New Relic to your GAE flex app by configuring a custom runtime, and gives an example of deploying a PHP app with Docker. Important The New Relic PHP agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the New Relic PHP agent, building a custom runtime, and deploying a single PHP application via Debian. For best results with the GAE flex environment, always use Debian. For more information about deploying and configuring your PHP app in the GAE flexible environment, see: Google App Engine's documentation for PHP Google App Engine's tutorials to deploy a PHP app 1. Set up the GAE project and install dependencies Follow standard procedures to install the New Relic PHP agent for your specific app server, and obtain your license key. Follow Google App Engine procedures for PHP to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Extend the GAE image for PHP In this example, the Dockerfile extends the generic PHP image with application files for a single application in Debian. You can add your New Relic license key directly to your Dockerfile, or use an environment variable in your docker run command. FROM gcr.io/google-appengine/php:latest ENV DOCUMENT_ROOT /app RUN DEBIAN_FRONTEND=noninteractive apt-get update; DEBIAN_FRONTEND=noninteractive apt-get -y install wget sudo RUN wget -O - https://download.newrelic.com/548C16BF.gpg | sudo apt-key add - RUN echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list RUN DEBIAN_FRONTEND=noninteractive apt-get update && DEBIAN_FRONTEND=noninteractive apt-get -y install newrelic-php5 RUN NR_INSTALL_KEY=\"new-relic-license-key\" NR_INSTALL_SILENT=true newrelic-install install Copy 3. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom runtime_config: document_root: . Copy 4. Build a Docker image The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. When building the Docker image, use the PHP image from Google App Engine. Standard Docker images from other providers may cause problems with GAE. To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . Copy 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy --project php-app-name Copy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the New Relic APM Overview page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic PHP agent logs to the Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 35.402233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "3. Configure your <em>app.yaml</em>",
        "body": " an <em>App</em> Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Extend the GAE image for PHP In this example, the Dockerfile extends the generic PHP image with application files for a single"
      },
      "id": "60441bcfe7b9d263675799ee"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "Important",
        "General requirements",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "ee49e0ca9bf17447e8349123bfb470ff9964c4fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-03-08T15:31:13Z",
      "updated_at": "2021-03-06T21:08:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.39777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data | New Relic Documentation",
        "sections": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " <em>Event</em> <em>API</em> (There are additional requirements when using the <em>Event</em> <em>API</em>.) Browser monitoring <em>agent</em> <em>APIs</em> (There are additional requirements with the <em>custom</em> PageAction <em>event</em>.) Mobile monitoring SDK General requirements When reporting <em>custom</em> <em>events</em> and attributes, follow these general requirements"
      },
      "id": "6043ef69e7b9d2da1f5799f8"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-03-08T15:33:53Z",
      "updated_at": "2021-03-06T21:14:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.93378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data | New Relic Documentation",
        "sections": "Value from <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser monitoring <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call"
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Important",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations",
        "Deprecated methods"
      ],
      "title": "Report mobile monitoring custom events and attributes | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "dba656da4a2978b01b6647a4a0011d08e6b9c4a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-03-08T15:36:40Z",
      "updated_at": "2021-03-06T21:03:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default Mobile events using the New Relic Mobile SDK. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple Mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the Mobile crash event trail. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default Mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations. Deprecated methods As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create custom events. The recordEvent methods for Android and iOS are deprecated. The deprecated recordEvent events do not have their own event type; they are recorded as a Mobile event type with a category attribute value of custom. recordCustomEvent creates an event with an eventType you can assign. But the eventType should only be used for one or two high-level event types, not for naming events. For example, you might have one event type Gestures, with many different names under that one type. For more context on this, see the recordCustomEvent query example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.56125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes | New Relic Documentation",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " and MobileHandledException <em>events</em>. These <em>events</em> are available for querying and also displayed in the Mobile crash <em>event</em> trail. For more on creating <em>custom</em> attributes and <em>custom</em> <em>events</em>, see: Android SDK <em>API</em> guide iOS SDK <em>API</em> guide NRQL query examples MobileRequestError examples MobileRequest examples Limits"
      },
      "id": "6043ee0de7b9d21975579a25"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Important",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute Browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "cabf27e5367fcf6473d105983c030b653e3bd9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-03-08T15:32:02Z",
      "updated_at": "2021-03-06T20:53:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 60 events per 30-second harvest cycle, per browser. After the 60-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.49698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes | New Relic Documentation",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " add to the PageView <em>event</em> are also automatically added to the PageAction <em>event</em>. There are two ways to add <em>custom</em> attributes to the PageView <em>event</em>: Use set<em>Custom</em>Attribute Browser <em>API</em> call To add a <em>custom</em> attribute to the PageView <em>event</em> via the Browser <em>agent</em>, use the set<em>Custom</em>Attribute Browser <em>API</em>"
      },
      "id": "6043ebbee7b9d227105799b2"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Important",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9a5edf6068acc3b7187d217bd7932f0478e5467c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-03-08T15:31:14Z",
      "updated_at": "2021-03-02T23:48:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.69173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes | New Relic Documentation",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " using the <em>Event</em> <em>API</em> (without need for APM). However, be aware that <em>custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding <em>custom</em> data with the APM <em>agent</em> <em>API</em>. Or, go directly to the full online course"
      },
      "id": "603ecece28ccbcc865eba7a0"
    }
  ],
  "/try-our-apis": [
    {
      "sections": [
        "Introduction to New Relic NerdGraph",
        "Tip",
        "Use the NerdGraph GraphiQL explorer",
        "Requirements and endpoints",
        "NerdGraph tutorials and examples",
        "NerdGraph terminology",
        "Make queries with the explorer",
        "Query account a New Relic user can access",
        "Query user, account, and NRQL in one NerdGraph GraphiQL request"
      ],
      "title": "Introduction to New Relic NerdGraph",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-03-11T03:15:01Z",
      "updated_at": "2021-03-11T03:15:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is New Relic's GraphQL-format API. Our NerdGraph is an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. Tip To use NerdGraph and APIs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use the NerdGraph GraphiQL explorer We have a GraphiQL explorer that lets you explore our schema, find definitions, and form calls. To use the explorer: You'll need a New Relic user key. Go to api.newrelic.com/graphiql (if you have New Relic data in EU, use api.eu.newrelic.com/graphiql) Requirements and endpoints To use NerdGraph, you need a New Relic user key. NerdGraph endpoints: Main endpoint: https://api.newrelic.com/graphql EU endpoint: For accounts with data in EU data center, use https://api.eu.newrelic.com/graphql. To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy NerdGraph tutorials and examples You can use NerdGraph to: Functionality Tutorials Query all the entities associated with your account. See the entities tutorial. Query, create, and update workloads associated with your account. See the workloads tutorial. Create, manage, and add tags to entities. For more information and examples, see the tagging tutorial. Query distributed tracing data. See the trace data tutorial. Fetch data when building a New Relic One app. See New Relic One app data querying and mutations. Understand upstream and downstream relationships with your services. See the relationships tutorial. Configure your New Relic cloud integrations. See cloud integration examples. Query event data using NRQL. See the NRQL tutorial. Watch video tutorials about NerdGraph. Go to the New Relic University tutorial Intro to New Relic NerdGraph. Or, go to the full online course New Relic APIs. NerdGraph terminology The New Relic GraphQL server explicitly defines the graph structure of NerdGraph. The following keywords are common to all GraphQL servers. Use these keywords to help build and understand your own queries. In addition: To understand how NerdGraph provides unified access to all the things you monitor with New Relic, see NerdGraph entities. To understand schema definitions: From the NerdGraph GraphiQL explorer, select Docs. Term Definition Queries Queries are basic requests that are intended to only fetch data, without any additional actions. Queries in the NerdGraph GraphiQL explorer are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations Mutations are requests that are intended to have additional actions, such as creating data or updating data on a server. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Make queries with the explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. In GraphQL, you ask for specific information in the graph structure of New Relic's data. You can follow the nodes of the graph to query exactly the data that you want. New fields are added seamlessly, and old fields can be marked as deprecated, which removes them from documentation and allows an eventual, graceful shutdown of that field. Query account a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one NerdGraph GraphiQL request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 794.6806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>NerdGraph</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>NerdGraph</em>",
        "tags": "<em>APIs</em>",
        "body": "<em>NerdGraph</em> is <em>New</em> <em>Relic</em>&#x27;s <em>GraphQL</em>-format <em>API</em>. Our <em>NerdGraph</em> is an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST <em>APIs</em> require loading from multiple URLs, <em>NerdGraph</em> calls get all the data you need"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 760.0621,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards <em>API</em> migration: from Insights <em>API</em> to <em>Nerdgraph</em>",
        "sections": "Dashboards <em>API</em> migration: from Insights <em>API</em> to <em>Nerdgraph</em>",
        "tags": "<em>New</em> <em>Relic</em> One",
        "body": " and understandable description of the <em>APIs</em>&#x27; data. By using <em>NerdGraph</em> Graphi<em>QL</em> explorer, you can discover <em>GraphQL</em> types and fields, along with a brief explanation. We want to facilitate your migration from the Insights <em>API</em> to the <em>new</em> <em>New</em> <em>Relic</em> One dashboards <em>API</em>. Find below some examples that illustrate how the old"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "Important",
        "User key",
        "Create a user key",
        "Edit a user key",
        "Delete a user key",
        "Tip",
        "License key",
        "Create a license key",
        "Edit a license key",
        "Delete a license API key",
        "Browser key",
        "Create a browser key",
        "Edit a browser key",
        "Delete a browser key",
        "REST API key",
        "Activate or change REST API key",
        "View REST API keys",
        "Delete REST API key",
        "Insights insert key",
        "Generate an Insights insert key",
        "Edit or delete an Insights insert key",
        "Insights query key",
        "Generate an Insights query key",
        "Edit or delete an Insights query key",
        "Admin key"
      ],
      "title": "New Relic API keys",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "8ee406a4146960d59a22c19023e226dbf8f931f8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/new-relic-api-keys/",
      "published_at": "2021-03-11T10:41:06Z",
      "updated_at": "2021-03-11T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Important Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (Also known as a \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (Also known as a \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Tip In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Important You can't manage or delete an original license key that was created when your account was created. For that, contact New Relic support. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Important You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. REST API key Important We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Important Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don’t need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says “Migrated from an admin user key” in the key table, so you’ll be able to find them easily.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 710.2288,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>API</em> keys",
        "sections": "<em>New</em> <em>Relic</em> <em>API</em> keys",
        "tags": "<em>APIs</em>",
        "body": " <em>API</em> keys&quot;) are required for <em>NerdGraph</em> (our <em>GraphQL</em> <em>API</em>), which allows you to query most <em>New</em> <em>Relic</em> data and do some types of configuration. User keys also let you use our REST <em>API</em>, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys"
      },
      "id": "6043fa3464441f1358378f3b"
    },
    {
      "sections": [
        "Event data retention (original pricing plan)",
        "Important",
        "Overview of event data retention",
        "Extend your event retention",
        "Insights Pro",
        "How number of events stored is calculated",
        "Insights Pro event overage example",
        "Disable/enable Transaction and Pageview event reporting",
        "Tip",
        "Flexible data retention",
        "How it works",
        "Manage retention via UI",
        "Master and sub-accounts",
        "Glossary",
        "Manage flexible retention via API",
        "List customizable retention event namespaces",
        "List active rules on an account",
        "Show active rule on an account/namespace pair",
        "Create a new rule",
        "Delete an existing rule",
        "Copy existing sub-account rules to other sub-accounts",
        "For more help"
      ],
      "title": "Event data retention (original pricing plan)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original data retention"
      ],
      "external_id": "76d1289aad7de08b355bb8c313f9e7a42a5779d8",
      "image": "https://docs.newrelic.com/static/3071b381c71a877c79b8c9881e57c26b/8cdda/Account_usage_flex-retention.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-data-retention/event-data-retention-original-pricing-plan/",
      "published_at": "2021-03-11T13:35:25Z",
      "updated_at": "2021-03-11T13:35:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This doc is for accounts on our original Product-based pricing. If you're on the newer pricing plan, see New Relic One pricing plan. Not sure which you're on? See Overview of pricing plans. New Relic products report a wide range of event data. Different products have different data retention periods, and different ways to extend event data retention. You can customize the length of your event data retention through flexible event retention. Overview of event data retention All New Relic product subscriptions come with a certain level of data retention that governs how long different types of data are retained. One type of data governed by data retention rules is event data. Event data is available in some UI charts and tables, and also available for querying via NRQL, our querying language. There are events reported from products by default, and there are custom events: each have their own retention rules, depending on the product and subscription level. Here are some examples of how different product subscriptions can affect event data retention: Free/Lite APM subscription: default-reported events available for 1 day. No custom events available. Pro APM subscription: default-reported events available for 8 days. Custom events available for 1 day (and able to be extended with Insight Pro). To see your subscriptions, go to the Account summary page. Extend your event retention Product Method APM, Browser, and Mobile Event data retention can be extended with a paid subscription to these products (see product data retention). To extend retention of both default-reported events and custom events further, you need an Insights Pro subscription. Infrastructure Event data retention can be extended with a paid Infrastructure subscription. See Infrastructure data retention rules. Synthetics Event data retention can be extended with a paid Synthetics subscription. See Synthetics data retention rules. Custom events Custom events reported by agent APIs or the Event API: Extension requires an Insights Pro subscription. Insights Pro Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. A paid Insights subscription is what governs the extension of event data retention for: Our APM, Browser, Mobile, and Serverless products Custom events that come from an agent API or from the Event API Important Note that having an Insights Pro subscription doesn't require use of the Insights UI (insights.newrelic.com) to query your data: there are other querying options available. To see the data retention governed by your Insights subscription, go to: account dropdown > Account settings > Usage > Event data retention. With an Insights Pro subscription, you can use flexible retention to customize how your event data is retained. This lets you keep only the data you need, for as long as you need it. How number of events stored is calculated This is an explanation of how the number of stored events are calculated by default for an Insights Pro subscription. (Note that with flexible retention, you have more fine-grained control over the retention period.) The events stored is calculated based on 1) total events stored over time (calculated based on the events generated per week) and 2) the weeks of data retention available. This equation can be represented like this: events stored = (events generated per week) * (weeks of retention) Copy An Insights Pro subscription provides a given number of weeks of data retention as well as a given number of events over that retention period. For example: (200M transactions per week) * (4 weeks of retention) = 800M events stored in Insights (16M transactions per week) * (50 weeks of retention) = 800M events stored in Insights For Insights Pro subscriptions, data is purged based on retention window, not volume. It is deleted from the system once it's past the retention window. For example: If your Insights license is for 800 million events with a 4 week retention period, your data would start being purged after it is older than four weeks. Temporary spikes in data exceeding your subscription level will still be recorded, but consistent overage should be solved by upgrading your subscription level or decreasing data collected. For customers without an Insights Pro subscription, New Relic may throttle or downsample events to a limit of not more than than 4,000 events per host per minute. Insights Pro event overage example In this example, you have an Insights Pro subscription with a license for 800 million events over 4 weeks, a rate of 200 million events per week. You have APM Pro, Browser Pro, and Mobile Enterprise. A fifth week of data is added via your subscriptions, bumping you to a total of 1 billion events stored within your plan: If you are using 975 million events, you are not over your retention. If you are using 1.25 billion events, you are over your retention. Disable/enable Transaction and Pageview event reporting Tip Owners or Admins The Insights Data summary UI page is used to see the types of events being reported. You can also use this page to enable and disable the reporting of PageView and Transaction events. To view Data summary: Go to insights.newrelic.com > Manage data. Select the Summary tab. Note: if you disable PageView or Transaction event reporting, this can affect some New Relic UI elements. You may see some empty charts on some UI pages that rely on this data. Go to insights.newrelic.com > Manage data > Summary. From the Summary tab, select Configure data sources. Toggle the appropriate switch on or off, then save. Toggling Transaction on or off will cause reporting agents to restart themselves. For more about configuring event reporting, see Event data retention. Flexible data retention With an Insights Pro subscription, you get access to flexible retention, which lets you define how some types of event data are retained. This lets you keep only the event data you need, for as long as you need it. You can manage your flexible retention through the UI or through our GraphQL API. Requirements to use this feature: An Insights Pro subscription or equivalent trial. Applies only for events governed by an Insights Pro subscription. To use this feature, you must be an account Owner or data retention add-on manager for your account. How it works To understand how standard event data retention works, first read Event data retention. With flexible retention, you specify the data retention for applicable event namespaces across your accounts. This gives you per-event namespace control of your data. The retention that you specify for an event namespace will be shared by all the event types under that namespace. If some namespaces are not relevant to you, you can avoid collecting their event data entirely. Your retention value can’t be lower than the included retention or higher than the default retention. You can control data retention either in our UI or by API. Manage retention via UI You can control data retention either using our GraphQL API or in the UI. To do this with the UI, go to Account Settings > Usage > Data management section. Your retention changes take effect within 24 hours after updating. Tip Want a demo of how the UI works? Check out our videos for UI overview and assigning a role. Go to rpm.newrelic.com > (account dropdown) > Account settings > Usage > Data management section: you can view your current retention plans, modify them, and perform overrides, all in the UI. Master and sub-accounts When it comes to master and sub-accounts with flexible retention, be aware of the following: Feature Description Account inheritance Retention set for a master account is inherited by all sub-accounts, unless a sub-account has its own custom retention override. Switch between accounts You can toggle between your master and sub-accounts by using the Account switcher in the data retention UI. Moving sub-accounts If a sub-account is moved to another master, it will adopt the retention settings of the new master account it’s under. However, if the sub-account has its own custom retention override, it’ll persist and ignore the current retention of its master account. Copy retention values from one sub-account to other sub-accounts From within a sub-account, select Copy retentions and use that sub-account as a source or template to apply those same namespace retention values to one or more other destination or target sub-accounts. Note: Source and destination sub-accounts must all be under the same master account. Glossary To understand the terms used with flexible retention, see the following: Term Description Event namespace An event's namespace corresponds to one or more event types that share a single data retention value. For more information, see Event namespaces (types). You can also use NerdGraph to get the list of customizable event namespaces. Retention value The number (in days) that specifies how long your event data is stored. Retention rule The event namespace and retention value pair that you specify to override the current retention. Licensed retention Retention period that’s determined in weeks by your Insights Pro subscription contract. Included retention Retention period for which your data is stored but not charged under the Insights Pro subscription. For details, see the data retention details for a specific product. Paid retention Retention period for which your data is stored and is charged under the Insights Pro subscription. By default, your licensed retention determines this value but Flexible retention lets you override it. Default retention Retention period that comes out of the box. This is based on the total of included retention plus licensed retention. Manage flexible retention via API You can control data retention with either NerdGraph (our GraphQL API) or in the UI. The following API examples show how to alter data retention via the NerdGraph GraphiQL explorer. Your retention changes take effect within 24 hours after updating. List customizable retention event namespaces To list the customizable retention event names spaces for your account, go to api.newrelic.com/graphiql and run the following: query { actor { account(id: YOUR_ACCOUNT_ID) { dataManagement { customizableRetention { eventNamespaces { namespace } } } } } } Copy List active rules on an account To list active rules on an account, go to api.newrelic.com/graphiql and run the following: query { actor { account(id: YOUR_ACCOUNT_ID) { dataManagement { eventRetentionRules { id deletedAt deletedById createdAt createdById retentionInDays namespace } } } } } Copy Show active rule on an account/namespace pair To show the active rule on a specific account/namespace pair, go to api.newrelic.com/graphiql and run the following: query { actor { account(id: YOUR_ACCOUNT_ID) { dataManagement { eventRetentionRule(namespace: \"APM\") { id deletedById deletedAt createdById createdAt retentionInDays namespace } } } } } Copy Create a new rule To create a new rule, go to api.newrelic.com/graphiql and run the following: mutation { dataManagementCreateEventRetentionRule(accountId: YOUR_ACCOUNT_ID, namespace: \"APM\", retentionInDays: 8) { id deletedById deletedAt createdById createdAt retentionInDays namespace } } Copy Delete an existing rule If you delete a rule applied to a sub-account, that sub-account will adopt the current retention value of its master account for the given namespace. If you delete a rule applied to a master account, the default retention value will re-apply for the given namespace. To delete an existing rule, go to api.newrelic.com/graphiql and run the following: mutation { dataManagementDeleteEventRetentionRule(accountId: YOUR_ACCOUNT_ID, namespace: \"APM\") { id deletedById deletedAt createdById createdAt retentionInDays namespace } } Copy Copy existing sub-account rules to other sub-accounts You can specify a sub-account to be the template or source account, and have other destination sub-accounts adopt the same namespace retention values of the source sub-account. Note: all sub-accounts must be within the same master account. To copy an existing set of retentions, go to api.newrelic.com/graphiql and run the following: mutation { dataManagementCopyRetentions( sourceAccountId: SOURCE_ACCOUNT_ID, destinationAccountIds: [DESTINATION_ACCOUNT_ID_1, DESTINATION_ACCOUNT_ID_2, DESTINATION_ACCOUNT_ID_3]) { success failure } } Copy Success and failure will return lists of destination account ids which were successful (or failed) in copying rules from the source account. For more help For details about the data retention of other products or integrations, see that specific documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 658.69977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Manage flexible retention via <em>API</em>",
        "body": ". This is based on the total of included retention plus licensed retention. Manage flexible retention via <em>API</em> You can control data retention with either <em>NerdGraph</em> (our <em>GraphQL</em> <em>API</em>) or in the UI. The following <em>API</em> examples show how to alter data retention via the <em>NerdGraph</em> Graphi<em>QL</em> explorer. Your retention"
      },
      "id": "6043f713e7b9d2ccee579a1d"
    },
    {
      "sections": [
        "NerdGraph NRQL tutorial",
        "Basic NRQL queries with NerdGraph",
        "Create embeddable charts",
        "Suggested facets",
        "Rules governing suggested facets",
        "Example of returning suggested attributes"
      ],
      "title": "NerdGraph NRQL tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b56b0e93848c3830a3d0767278e844700c958531",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-nrql-tutorial/",
      "published_at": "2021-03-11T11:44:16Z",
      "updated_at": "2021-03-11T11:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic NerdGraph GraphiQL explorer to make New Relic Query Language (NRQL) queries. To learn how to construct these queries and see responses, go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. This document explains some of the available functions for NRQL queries. Basic NRQL queries with NerdGraph To make NRQL queries using NerdGraph: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Pass the NRQL query as a string argument to the NRQL object, and include the results field in your NerdGraph query. For example, to get a count of all transaction events in the last hour, use the following query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This NerdGraph query example returns the following results: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your transaction data. Use the NerdGraph GraphiQL explorer to experiment with queries. Create embeddable charts In addition to returning raw data, you can fetch embeddable chart links for the data to use in an application. For example, instead of a single count of transaction, you can create a chart that illustrates a timeseries of bucketed counts over time. Add TIMESERIES to your query with embeddedChartUrl: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) from Transaction TIMESERIES\") { embeddedChartUrl } } } } Copy This NerdGraph query example returns the URL for the chart in the following response: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \" embeddedChartUrl \": \"https://chart-embed.service.newrelic.com/charts/EMBEDDABLE-CHART-ID\" } } } } } Copy If you view the embedded chart URL using any standard HTTP client, it returns an image showing a visualization of the response to the query you submitted. These charts follow the same embedded chart rules as embedded charts that are created elsewhere. To change the style of the data visualization, pass a chartType argument to embeddedChartUrl. Suggested facets When using NerdGraph to explore your data, you can use the suggestedFacets field to return suggested attributes for use in faceted NRQL queries. Rules governing suggested facets Here are some of the rules that govern what attributes are suggested: Built-in suggestions. Each event type comes with its own set of recommended attributes. These are attributes chosen by New Relic for their importance and popularity. Usage-based suggestions. Some attribute suggestions are based on the queries that have been frequently used by your account. These suggestions can include custom attributes. Role restriction. Restricted users do not have access to account-related facet suggestions. To disable the use of account data for determining suggested queries, contact Support. Example of returning suggested attributes Here's an example of returning suggested attributes for faceting transaction counts. The response suggests the host attribute. Faceting by host can reveal that one host is servicing more requests than other hosts. { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) from Transaction TIMESERIES\") { suggestedFacets { attributes } } } } } Copy This NerdGraph query example returns a response similar to this: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \" suggestedFacets \": [ \"attributes\": [\"host\"] ] } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 653.0161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> NRQL tutorial",
        "sections": "<em>NerdGraph</em> NRQL tutorial",
        "tags": "<em>APIs</em>",
        "body": "You can use the <em>New</em> <em>Relic</em> <em>NerdGraph</em> Graphi<em>QL</em> explorer to make <em>New</em> <em>Relic</em> Query Language (NRQL) queries. To learn how to construct these queries and see responses, go to the <em>NerdGraph</em> Graphi<em>QL</em> explorer at https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;graphiql. This document explains some of the available functions"
      },
      "id": "6044058c196a67976b960f3d"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "sections": [
        "Partial or missing logs for RDS, VPC, AWS Lambda",
        "Problem",
        "Solution"
      ],
      "title": "Partial or missing logs for RDS, VPC, AWS Lambda | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "Troubleshooting"
      ],
      "external_id": "66a81a2fa3b8b27bf6172c9bb2c3ecf28bbe13e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/troubleshooting/partial-or-missing-logs-rds-vpc-aws-lambda/",
      "published_at": "2021-03-08T15:31:43Z",
      "updated_at": "2021-03-07T17:25:43Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using NewRelic-log-ingestion, the lambda function for pushing logs from AWS to our RDS Enhanced Monitoring, VPC Flow Logs integrations, or early versions (alpha and beta) of monitoring for AWS Lambda. It is not working or it is sending partial data. Solution The NewRelic-log-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the New Relic CLI or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update the function using the New Relic CLI. You can also update the function manually: Avoid false positives in alerting: Follow UI procedures or API procedures to disable all alert conditions associated with monitoring integrations with AWS Lambda, RDS Enhanced Monitoring, and VPC Flow Logs. Remove the outdated lambda version of the lambda: Go to your AWS Lambda Console, and remove newrelic-log-ingestion. Be aware that this stops the RDS Enhanced Monitoring and the VPC Flow Logs integration until the next step is completed. Re-enable the service: Follow the instructions in RDS Enhanced Monitoring or VPC Flow Logs, or follow the step to configure CloudWatch logs to stream to New Relic Lambda. Check that your data is flowing through the new lambda.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 885.94727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Partial or missing logs for RDS, VPC, AWS Lambda | <em>New</em> <em>Relic</em> Documentation",
        "body": "-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the <em>New</em> <em>Relic</em> <em>CLI</em> or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update"
      },
      "id": "60450c97196a672ffa960f57"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-03-12T01:46:22Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 864.69446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple tags to one"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Automate workflows",
      "updated_at": "2021-03-11T01:48:25Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 777.6974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Secrets management",
        "Define secrets",
        "Important",
        "Tip",
        "Using environment variables",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "New Relic CLI Obfuscation"
      ],
      "title": "Secrets management | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Installation"
      ],
      "external_id": "8e05204a80a9475aee87d85a4be07cff710faa31",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management/",
      "published_at": "2021-03-08T15:36:57Z",
      "updated_at": "2021-03-02T21:32:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and New Relic CLI obfuscation are supported. Define secrets To use secrets in a configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the general configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. The secret object can be defined as a simple string or json object. Important If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault (you can define the object's name for the secret.) Let's assume that the stored object is a valid JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Copy Tip Both simple strings and valid JSON objects can be retrieved from variables. When using JSON objects make sure both keys and values are enclosed with double-quotes. Using environment variables Environment variables can be used into the variables section with the {{MY_ENV_VAR}} notation. When doing so, environment variables are expanded and their value is replaced at runtime. Use this method to avoid having sensitive values such as tokens or obfuscation keys included in the configuration file. When using environment variables in on-host integration configuration files the passthrough_environment setting must be defined. Secrets variables Define secrets in each configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms AWS KMS secret retrieval configuration vault Vault secret retrieval configuration cyberark-cli CyberArk command line interface configuration cyberark-api CyberArk REST API configuration obfuscated New Relic CLI obfuscation AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Copy Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Important Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server’s certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true Copy CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object Copy CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true Copy New Relic CLI Obfuscation Important We recommend using any of the supported secrets providers instead of the simple obfuscation when possible. See our guidelines below to define environment variables to avoid having the obfuscation key in configuration files. Tip Infrastructure Agent 1.14.0 or above is required You can use the New Relic CLI obfuscate command to obscure sensitive information in the infrastructure agent or any on-host integration configuration file. Steps: Install the New Relic CLI on any host (it can be your development host). Run the CLI obfuscate command in order to generate the obfuscated value: newrelic agent config obfuscate --value '<plain_text_config_value>' --key '<obfuscation_key>' Copy Copy the result of the cli command into the text argument in the obfuscated section as shown in the examples below. YAML key Description key Type: String The string used when obfuscating the clear-text value using New Relic CLI Default: none secret Type: String The output of the newrelic-cli command Default: none Integrations configuration example The following example will allow retrieving the Nginx user and password that has been obfuscated using the New Relic CLI: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy It's recommended to use environment variables for the obfuscation arguments as shown in the example below: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: {{OBFUSCATION_KEY}} secret: {{OBFUSCATION_TEXT}} instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy Agent configuration example This example allows retrieving a string that contains the proxy details (user, password and host): variables: obfuscated_proxy: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' proxy: ${obfuscated_proxy} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 692.44275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Secrets management | <em>New</em> <em>Relic</em> Documentation",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Obfuscation",
        "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and <em>New</em> <em>Relic</em> <em>CLI</em> obfuscation are supported. Define secrets"
      },
      "id": "603eaeeae7b9d28cdf2a07dd"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/infrastructure-release-notes/infrastructure-agent-release-notes/new-relic-infrastructure-agent-1140/",
      "sections": [
        "Infrastructure agent v1.14.0",
        "Notes",
        "Changed",
        "Added"
      ],
      "published_at": "2021-03-08T15:34:28Z",
      "title": "Infrastructure agent v1.14.0 | New Relic Documentation",
      "updated_at": "2021-03-07T00:35:59Z",
      "type": "docs",
      "external_id": "b9532e32dc1bf96d8e5843f57cc4c62127c35c0c",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Notes A new version of the agent has been released. Follow standard procedures to update the Infrastructure agent. New Relic recommends that you upgrade the agent regularly and at a minimum every 3 months. Changed Integration protocol v4: Log entity registration errors / warning only when debug is enabled. Fix logic that checks max entity batch in bytes. #224 Allow list of infrastructure event fields restructured as deny list so that additional fields can be included. #235 Updated HTTP API to support all kind of integration payload versions, added support for exposing integrations API via raw TCP socket. #268 Update curl version to fix CVEs Bundled integrations: Flex integration has been updated to version 1.3.7. For more information, see the nri-flex changelog. Docker integration has been updated to version 1.4.1. For more information, see the nri-docker changelog. Log forwarder: #255 Parser renamed to filter. #255 Removed deprecated folder parameter. Added Secrets management & environment variables support: #251 Agent configuration now supports secrets to manage sensitive settings (databind variables block). See Secrets Management documentation #260 #263 #266 Added environment-variables replacement support for agent & integration configuration files. Replacement of env-vars for agent config file using double curly braces {{ ENV_VAR }}. Env-vars replacement happens before YAML is parsed or databind (secrets/variables engine) runs. #258 Added New Relic CLI obfuscated support for secrets. See obfuscated provider in Secrets management documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 626.6688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Infrastructure agent v1.14.0 | <em>New</em> <em>Relic</em> Documentation",
        "body": "-variables replacement support for agent &amp; integration configuration files. Replacement of env-vars for agent config file using double curly braces {{ ENV_VAR }}. Env-vars replacement happens before YAML is parsed or databind (secrets&#x2F;variables engine) runs. #258 Added <em>New</em> <em>Relic</em> <em>CLI</em> obfuscated support for secrets. See obfuscated provider in Secrets management documentation."
      },
      "id": "60441fef196a679ade960f1f"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-03-12T01:46:22Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 428.4347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6046d422e7b9d27a66579a0b"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-02-06T01:55:17Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostModules directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_channel\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your module.tf and provider.tf to the stage for commit: bash Copy $ git add module.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.15424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "601df70628ccbce8510133b6"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-03-11T03:15:01Z",
      "updated_at": "2021-03-11T03:15:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If this is a sub-account, the list shows only the sub-account users, not all the users in the master account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.59953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View or update user email <em>channels</em>",
        "sections": "View or update user email <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "&#x27;s <em>notification</em> <em>channel</em>. To add or update account users as <em>notification</em> channels for a policy: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click Policies, and then choose the policy you want to change. Optional: You can update <em>notification</em> channels for specific users. On the <em>Notification</em>"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.0341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "5efa999d196a67300c766404"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-03-12T01:49:20Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.05075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/sparkline-table-row-cell/",
      "sections": [
        "SparklineTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Example 2",
        "Props",
        "shape",
        "Methods",
        "SparklineTableRowCell.render"
      ],
      "published_at": "2021-03-12T01:53:04Z",
      "title": "SparklineTableRowCell",
      "updated_at": "2021-03-12T01:53:03Z",
      "type": "developer",
      "external_id": "8a9151a59bd3d13851ec9b97e44f7ff073946e60",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table row cell showing a sparkline. Sparklines can either come from a NRQL query (thus providing accountId and query), or from a predefined data passed in the chart format. In either case, all props are 1:1 compatible with the <NrqlQuery> format type CHART. A common case to render one row per NRQL facet, is to perform the query outside of the table, then pass the result as items (returned data from a <NrqlQuery> is an array, that can be directly used as the input items of a table). Once rendering the sparkline, you need to re-wrap the data in an array, in order to build, from a series, a new entire set of data. Usage import { SparklineTableRowCell } from 'nr1' Copy Examples Example 1 1 function render() { 2 const items = [ 3 { 4 accountId: 1, 5 query: 6 \"SELECT count(*) FROM Transaction WHERE entityGuid = '…' TIMESERIES\", 7 }, 8 ]; 9 10 return ( 11 <Table> 12 <TableHeader> 13 <TableHeaderCell>Sparkline</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <SparklineTableRowCell 19 accountId={item.accountId} 20 query={item.query} 21 /> 22 </TableRow> 23 )} 24 </Table> 25 ); 26 } Copy Example 2 1 <NrqlQuery 2 accountId={1} 3 query=\"SELECT count(*) FROM Transaction FACET entityGuid TIMESERIES UNTIL 5 MINUTES AGO\" 4 > 5 {({ loading, error, data }) => { 6 if (loading || error) { 7 return null; 8 } 9 10 return ( 11 <Table items={data}> 12 <TableHeader> 13 <TableHeaderCell>Entity GUID</TableHeaderCell> 14 <TableHeaderCell>Transactions</TableHeaderCell> 15 </TableHeader> 16 17 {({ item }) => ( 18 <TableRow> 19 <TableRowCell>{item.metadata.name}</TableRowCell> 20 <SparklineTableRowCell data={[item]} /> 21 </TableRow> 22 )} 23 </Table> 24 ); 25 }} 26 </NrqlQuery>; Copy Props accountIdnumber Sets the account ID to perform the query. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. dataobject[] Data is an array of objects where each object represents a series to be drawn. Each series comprises visualization metadata and an array of data points. Example 1 1 const data = [ 2 { 3 metadata: { 4 id: 'series-1', 5 name: 'Serie 1', 6 color: '#a35ebf', 7 viz: 'main', 8 units_data: { 9 x: 'TIMESTAMP', 10 y: 'BYTES', 11 }, 12 }, 13 data: [ 14 { 15 x: 1615492975430, 16 y: 21400, 17 }, 18 { 19 x: 1615496575430, 20 y: 12200, 21 }, 22 { 23 x: 1615500175430, 24 y: 9300, 25 }, 26 { 27 x: 1615503775430, 28 y: 14500, 29 }, 30 { 31 x: 1615507375430, 32 y: 27500, 33 }, 34 { 35 x: 1615510975430, 36 y: 24700, 37 }, 38 ], 39 }, 40 { 41 metadata: { 42 id: 'series-2', 43 name: 'Serie 2', 44 color: '#85c956', 45 viz: 'main', 46 units_data: { 47 x: 'TIMESTAMP', 48 y: 'BYTES', 49 }, 50 }, 51 data: [ 52 { 53 x: 1615492975430, 54 y: 8800, 55 }, 56 { 57 x: 1615496575430, 58 y: 1400, 59 }, 60 { 61 x: 1615500175430, 62 y: 4600, 63 }, 64 { 65 x: 1615503775430, 66 y: 5200, 67 }, 68 { 69 x: 1615507375430, 70 y: 14100, 71 }, 72 { 73 x: 1615510975430, 74 y: 19300, 75 }, 76 ], 77 }, 78 { 79 metadata: { 80 id: 'events', 81 name: 'Events', 82 color: 'red', 83 viz: 'event', 84 }, 85 data: [ 86 { 87 x0: 1615496575430, 88 x1: 1615500175430, 89 }, 90 { 91 x0: 1615507375430, 92 x1: 1615507375430, 93 }, 94 ], 95 }, 96 ]; Copy onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined querystring NRQL query used for fetching data. The query is performed against the provided accountId. styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring Methods SparklineTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1837.6511,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " &lt;<em>TableHeaderCell</em>&gt;Sparkline&lt;&#x2F;<em>TableHeaderCell</em>&gt; 14 &lt;&#x2F;<em>TableHeader</em>&gt; 15 16 {({ item }) =&gt; ( 17 &lt;<em>TableRow</em>&gt; 18 &lt;Sparkline<em>TableRowCell</em> 19 accountId={item.accountId} 20 query={item.query} 21 &#x2F;&gt; 22 &lt;&#x2F;<em>TableRow</em>&gt; 23 )} 24 &lt;&#x2F;<em>Table</em>&gt; 25 ); 26 } Copy Example 2 1 &lt;NrqlQuery 2 accountId={1} 3 query=&quot;SELECT count"
      },
      "id": "5efa9906196a67b8837663fa"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-table-row-cell/",
      "sections": [
        "UserTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "UserTableRowCell.render"
      ],
      "published_at": "2021-03-12T01:48:26Z",
      "title": "UserTableRowCell",
      "updated_at": "2021-01-29T01:59:32Z",
      "type": "developer",
      "external_id": "765e8c8ba01ca8ae96c8e45e2223941812e17294",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular user. This cell takes the user object as its children, which is in turn compatible with the NerdGraph user object (needing, at the very least, the name and gravatar fields). Usage import { UserTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { name: 'John Doe', gravatar: 'https://secure.gravatar.com/avatar/79988df068cb4d952284a3395412dc4f', }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <UserTableRowCell value={item} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 name: 'John Doe', 5 gravatar: 6 'https://secure.gravatar.com/avatar/79988df068cb4d952284a3395412dc4f', 7 }, 8 ]; 9 10 return ( 11 <Table items={items}> 12 <TableHeader> 13 <TableHeaderCell>User</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <UserTableRowCell value={item} /> 19 </TableRow> 20 )} 21 </Table> 22 ); 23 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring valuerequiredshape User object, that requires (at least), the name and gravatar fields. This object matches with the user structure obtained from NerdGraph. shape namerequiredstring gravatarrequiredstring Methods UserTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 874.8136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " render() { const items = [ { name: &#x27;John Doe&#x27;, gravatar: &#x27;https:&#x2F;&#x2F;secure.gravatar.com&#x2F;avatar&#x2F;79988df068cb4d952284a3395412dc4f&#x27;, }, ]; return ( &lt;<em>Table</em> items={items}&gt; &lt;<em>TableHeader</em>&gt; &lt;<em>TableHeaderCell</em>&gt;User&lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em>&gt; &lt;User<em>TableRowCell</em> value={item"
      },
      "id": "5efa98d464441f3b815f7e72"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-title-table-row-cell/",
      "sections": [
        "EntityTitleTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "EntityTitleTableRowCell.render"
      ],
      "published_at": "2021-03-12T01:50:56Z",
      "title": "EntityTitleTableRowCell",
      "updated_at": "2021-01-29T01:56:48Z",
      "type": "developer",
      "external_id": "624657ff4b10659dfcb70e034f47ec8d28609706",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing the title of a particular entity. This cell takes the entity object as its children, which is in turn compatible with the NerdGraph entity object (needing, at the very least, the name and reporting fields). If alertable, you should also query for alertSeverity. Usage import { EntityTitleTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { name: 'Login service', alertSeverity: 'CRITICAL', reporting: true, }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 name: 'Login service', 5 alertSeverity: 'CRITICAL', 6 reporting: true, 7 }, 8 ]; 9 10 return ( 11 <Table items={items}> 12 <TableHeader> 13 <TableHeaderCell>User</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <EntityTitleTableRowCell value={item} /> 19 </TableRow> 20 )} 21 </Table> 22 ); 23 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring valuerequiredshape Entity object, that requires (at least), the name and reporting fields. This object matches with the user structure obtained from NerdGraph. shape namerequiredstring alertSeveritystring reportingrequiredboolean Methods EntityTitleTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 874.52246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&lt;&#x2F;<em>TableHeaderCell</em>&gt; 14 &lt;&#x2F;<em>TableHeader</em>&gt; 15 16 {({ item }) =&gt; ( 17 &lt;<em>TableRow</em>&gt; 18 &lt;EntityTitle<em>TableRowCell</em> value={item} &#x2F;&gt; 19 &lt;&#x2F;<em>TableRow</em>&gt; 20 )} 21 &lt;&#x2F;<em>Table</em>&gt; 22 ); 23 } Copy Props classNamestring Appends class names to the <em>component</em>. Should be used only for positioning and spacing purposes. onClickfunction Callback"
      },
      "id": "5efa98d4196a67923f766450"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table/",
      "sections": [
        "Table",
        "Usage",
        "Examples",
        "Basic",
        "Sorting",
        "Query with Table",
        "Props",
        "Methods",
        "Table.render"
      ],
      "published_at": "2021-03-12T01:48:26Z",
      "title": "Table",
      "updated_at": "2021-01-29T01:59:31Z",
      "type": "developer",
      "external_id": "878b3ab08dbd0a7df42558a970648013adde957f",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table with a fixed header and rows. The table implements the following features: Flexible layout: table headers accept a variety of sizes to enable fluid and fixed layouts. You can find more information on how to customize your columns checking TableHeaderCell. Sorting: items passed can be internally sorted by the table according to the current sorting state of the table. You can find more information about sorting by checking TableHeaderCell. Row selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. Row actions: contextual actions can be triggered per row, enabling users to achieve functionality over them. You can find more information on how to add them in TableRow. Custom pre-defined cells: some very common patterns for cells (entity title, metrics, etc.) are already provided by the platform, so that you only need to return it as part of your row. Virtualization: cells are only rendered if they are shown on screen. This enables the table to work with a large dataset with almost no performance penalty. Usage import { Table } from 'nr1' Copy Examples Basic class Example extends React.Component { _getActions() { return [ { label: 'Action 1', disabled: true, onClick: (evt, { item, index }) => { alert(`Action 1:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); }, }, { label: 'Action 2', onClick: (evt, { item, index }) => { alert(`Action 2:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); }, }, ]; } _getItems() { return [ { name: 'Melton Garcia', gender: 'Male', company: 'Comtest', phone: '+1 (867) 477-3284', selected: true, }, { name: 'Finley Mendez', gender: 'Male', company: 'Anarco', phone: '+1 (817) 438-3205', selected: false, }, { name: 'Coleen Salinas', gender: 'Female', company: 'Macronaut', phone: '+1 (962) 419-3856', selected: true, }, ]; } render() { return ( <Table items={this._getItems()} selected={({ item }) => item.selected} onSelect={(evt, { item }) => (item.selected = evt.target.checked)} > <TableHeader> <TableHeaderCell value={({ item }) => item.name} width=\"50%\"> Name </TableHeaderCell> <TableHeaderCell value={({ item }) => item.gender}> Gender </TableHeaderCell> <TableHeaderCell value={({ item }) => item.company}> Company </TableHeaderCell> <TableHeaderCell value={({ item }) => item.phone} width=\"fit-content\" alignmentType={TableRowCell.ALIGNMENT_TYPE.RIGHT} > Phone </TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow actions={this._getActions()}> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.gender}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.phone}</TableRowCell> </TableRow> )} </Table> ); } } 1 class Example extends React.Component { 2 _getActions() { 3 return [ 4 { 5 label: 'Action 1', 6 disabled: true, 7 onClick: (evt, { item, index }) => { 8 alert(`Action 1:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); 9 }, 10 }, 11 { 12 label: 'Action 2', 13 onClick: (evt, { item, index }) => { 14 alert(`Action 2:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); 15 }, 16 }, 17 ]; 18 } 19 20 _getItems() { 21 return [ 22 { 23 name: 'Melton Garcia', 24 gender: 'Male', 25 company: 'Comtest', 26 phone: '+1 (867) 477-3284', 27 selected: true, 28 }, 29 { 30 name: 'Finley Mendez', 31 gender: 'Male', 32 company: 'Anarco', 33 phone: '+1 (817) 438-3205', 34 selected: false, 35 }, 36 { 37 name: 'Coleen Salinas', 38 gender: 'Female', 39 company: 'Macronaut', 40 phone: '+1 (962) 419-3856', 41 selected: true, 42 }, 43 ]; 44 } 45 46 render() { 47 return ( 48 <Table 49 items={this._getItems()} 50 selected={({ item }) => item.selected} 51 onSelect={(evt, { item }) => (item.selected = evt.target.checked)} 52 > 53 <TableHeader> 54 <TableHeaderCell value={({ item }) => item.name} width=\"50%\"> 55 Name 56 </TableHeaderCell> 57 <TableHeaderCell value={({ item }) => item.gender}> 58 Gender 59 </TableHeaderCell> 60 <TableHeaderCell value={({ item }) => item.company}> 61 Company 62 </TableHeaderCell> 63 <TableHeaderCell 64 value={({ item }) => item.phone} 65 width=\"fit-content\" 66 alignmentType={TableRowCell.ALIGNMENT_TYPE.RIGHT} 67 > 68 Phone 69 </TableHeaderCell> 70 </TableHeader> 71 72 {({ item }) => ( 73 <TableRow actions={this._getActions()}> 74 <TableRowCell>{item.name}</TableRowCell> 75 <TableRowCell>{item.gender}</TableRowCell> 76 <TableRowCell>{item.company}</TableRowCell> 77 <TableRowCell>{item.phone}</TableRowCell> 78 </TableRow> 79 )} 80 </Table> 81 ); 82 } 83 } Copy Sorting class Example extends React.Component { constructor() { super(...arguments); this.state = { column_0: TableHeaderCell.SORTING_TYPE.ASCENDING, }; } _getItems() { return [ { name: 'Melton Garcia', gender: 'Male', company: 'Comtest', phone: '+1 (867) 477-3284', selected: true, }, { name: 'Finley Mendez', gender: 'Male', company: 'Anarco', phone: '+1 (817) 438-3205', selected: false, }, { name: 'Coleen Salinas', gender: 'Female', company: 'Macronaut', phone: '+1 (962) 419-3856', selected: true, }, ]; } _onClickTableHeaderCell(key, event, sortingData) { this.setState({ [key]: sortingData.nextSortingType }); } render() { return ( <Table items={this._getItems()} selected={({ item }) => item.selected} onSelect={(evt, { item }) => (item.selected = evt.target.checked)} > <TableHeader> <TableHeaderCell value={({ item }) => item.name} sortable sortingType={this.state.column_0} sortingOrder={1} onClick={this._onClickTableHeaderCell.bind(this, 'column_0')} > Name </TableHeaderCell> <TableHeaderCell value={({ item }) => item.gender} sortable sortingType={this.state.column_1} sortingOrder={0} onClick={this._onClickTableHeaderCell.bind(this, 'column_1')} > Gender </TableHeaderCell> <TableHeaderCell value={({ item }) => item.company} sortable sortingType={this.state.column_2} sortingOrder={2} onClick={this._onClickTableHeaderCell.bind(this, 'column_2')} > Company </TableHeaderCell> <TableHeaderCell value={({ item }) => item.phone}> Phone </TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.gender}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.phone}</TableRowCell> </TableRow> )} </Table> ); } } 1 class Example extends React.Component { 2 constructor() { 3 super(...arguments); 4 5 this.state = { 6 column_0: TableHeaderCell.SORTING_TYPE.ASCENDING, 7 }; 8 } 9 10 _getItems() { 11 return [ 12 { 13 name: 'Melton Garcia', 14 gender: 'Male', 15 company: 'Comtest', 16 phone: '+1 (867) 477-3284', 17 selected: true, 18 }, 19 { 20 name: 'Finley Mendez', 21 gender: 'Male', 22 company: 'Anarco', 23 phone: '+1 (817) 438-3205', 24 selected: false, 25 }, 26 { 27 name: 'Coleen Salinas', 28 gender: 'Female', 29 company: 'Macronaut', 30 phone: '+1 (962) 419-3856', 31 selected: true, 32 }, 33 ]; 34 } 35 36 _onClickTableHeaderCell(key, event, sortingData) { 37 this.setState({ [key]: sortingData.nextSortingType }); 38 } 39 40 render() { 41 return ( 42 <Table 43 items={this._getItems()} 44 selected={({ item }) => item.selected} 45 onSelect={(evt, { item }) => (item.selected = evt.target.checked)} 46 > 47 <TableHeader> 48 <TableHeaderCell 49 value={({ item }) => item.name} 50 sortable 51 sortingType={this.state.column_0} 52 sortingOrder={1} 53 onClick={this._onClickTableHeaderCell.bind(this, 'column_0')} 54 > 55 Name 56 </TableHeaderCell> 57 <TableHeaderCell 58 value={({ item }) => item.gender} 59 sortable 60 sortingType={this.state.column_1} 61 sortingOrder={0} 62 onClick={this._onClickTableHeaderCell.bind(this, 'column_1')} 63 > 64 Gender 65 </TableHeaderCell> 66 <TableHeaderCell 67 value={({ item }) => item.company} 68 sortable 69 sortingType={this.state.column_2} 70 sortingOrder={2} 71 onClick={this._onClickTableHeaderCell.bind(this, 'column_2')} 72 > 73 Company 74 </TableHeaderCell> 75 <TableHeaderCell value={({ item }) => item.phone}> 76 Phone 77 </TableHeaderCell> 78 </TableHeader> 79 80 {({ item }) => ( 81 <TableRow> 82 <TableRowCell>{item.name}</TableRowCell> 83 <TableRowCell>{item.gender}</TableRowCell> 84 <TableRowCell>{item.company}</TableRowCell> 85 <TableRowCell>{item.phone}</TableRowCell> 86 </TableRow> 87 )} 88 </Table> 89 ); 90 } 91 } Copy Query with Table 1 <EntitiesByDomainTypeQuery entityDomain=\"APM\" entityType=\"APPLICATION\"> 2 {({ error, data, fetchMore }) => { 3 if (!data.entities.length && error) { 4 return 'Error!'; 5 } 6 return ( 7 <Table items={data.entities} rowCount={data.count} onLoadMore={fetchMore}> 8 <TableHeader> 9 <TableHeaderCell value={({ item }) => item.name}> 10 name 11 </TableHeaderCell> 12 <TableHeaderCell value={({ item }) => item.id}> 13 entityGuid 14 </TableHeaderCell> 15 <TableHeaderCell value={({ item }) => item.accountId}> 16 accountId 17 </TableHeaderCell> 18 </TableHeader> 19 {({ item }) => ( 20 <TableRow> 21 <EntityTitleTableRowCell value={item} /> 22 <TableRowCell>{item.guid}</TableRowCell> 23 <TableRowCell>{item.accountId}</TableRowCell> 24 </TableRow> 25 )} 26 </Table> 27 ); 28 }} 29 </EntitiesByDomainTypeQuery>; Copy Props children(node|function)[] Contents of the table. Table can only contain as children <TableHeader> and a function returning <TableRow>s. function () => undefined classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. compactboolean DEFAULT false Establishes whether the table should render in compact mode (compact mode has narrower rows). In general, use the standard mode, since compact is reserved for data representation, e.g. in a dashboard. itemsany[] DEFAULT [] The items to be used when rendering. They are required when rendering items with a render callback. Each item can have any structure and type possible, and will the corresponding one will be provided when rendering each element list. mainColumnnumber DEFAULT 0 Column containing the main data identifying the row. Often the first column (index 0) is the relevant one, but actions (like favorites) could be placed before it. onLoadMorefunction Callback fired when more items must be loaded. This happens when you're lazy loading the items and the items that are about to render cannot be found in the items array. This callback should be used to fetch/load the missing items from the backend or other sources. The returned Promise should be resolved once item data has finished loading. It will be used to determine when to refresh the list with the newly-loaded data. This callback may be called multiple times in reaction to a single scroll event. function ( cursor : {Object // Items to load. ) => undefined onSelectfunction Function called when the user clicks over a row checkbox. It is called with the event of the checkbox, as well as with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. When the user selects or unselects the header checkbox (select / unselect all), the callback will be called once for every item, representing individual clicks over each row. The header checkbox state is automatically controlled by the table. function () => undefined rowCountnumber Number of rows. By default it's equal to length of array passed in the items prop. You should specify the rowCount when you know the total number of items but you want to lazy load them while scrolling. selectedfunction Function that returns whether a row is selected. It needs to return a boolean representing the state of the row. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. function ( args : {Object ) => undefined spacingTypeenum[] Spacing property. Spacing is defined as a tuple of zero to four values, which follow the same conventions as CSS properties like margin or padding. To omit a value, use SPACING_TYPE.OMIT. <Array of <One of Table.SPACING_TYPE.EXTRA_LARGE , Table.SPACING_TYPE.LARGE , Table.SPACING_TYPE.MEDIUM , Table.SPACING_TYPE.NONE , Table.SPACING_TYPE.OMIT , Table.SPACING_TYPE.SMALL , > > styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. Methods Table.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 863.4811,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Table</em>",
        "sections": "<em>Table</em>",
        "body": "={<em>TableRowCell</em>.ALIGNMENT_TYPE.RIGHT} &gt; Phone &lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em> actions={this._getActions()}&gt; &lt;<em>TableRowCell</em>&gt;{item.name}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.gender}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.company}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.phone}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;&#x2F;<em>TableRow</em>&gt; )} &lt;&#x2F;<em>Table</em>"
      },
      "id": "5efa98d428ccbcebbd307dfb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/metric-table-row-cell/",
      "sections": [
        "MetricTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "MetricTableRowCell.render"
      ],
      "published_at": "2021-03-12T01:52:04Z",
      "title": "MetricTableRowCell",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "b3f3bb23254c69af9c2c0f5350018bae35f5506c",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular metric. The metric is formatted according to the unit passed. Units are 1:1 compatible with the ones supported by <NrqlQuery> format type CHART. Unit and prefix formatting is automatically picked for you so that it is consistent with the rest of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { MetricTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { value: 123456789, }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <MetricTableRowCell type={MetricTableRowCell.TYPE.BITS} value={item.value} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 value: 123456789, 5 }, 6 ]; 7 8 return ( 9 <Table items={items}> 10 <TableHeader> 11 <TableHeaderCell>User</TableHeaderCell> 12 </TableHeader> 13 14 {({ item }) => ( 15 <TableRow> 16 <MetricTableRowCell 17 type={MetricTableRowCell.TYPE.BITS} 18 value={item.value} 19 /> 20 </TableRow> 21 )} 22 </Table> 23 ); 24 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring typeenum DEFAULT MetricTableRowCell . TYPE . UNKNOWN Unit of the provided metric. Will be used for auto-formatting the numerical value. <One of MetricTableRowCell.TYPE.APDEX , MetricTableRowCell.TYPE.BITS , MetricTableRowCell.TYPE.BITS_PER_MS , MetricTableRowCell.TYPE.BITS_PER_SECOND , MetricTableRowCell.TYPE.BYTES , MetricTableRowCell.TYPE.BYTES_PER_MS , MetricTableRowCell.TYPE.BYTES_PER_SECOND , MetricTableRowCell.TYPE.COUNT , MetricTableRowCell.TYPE.HERTZ , MetricTableRowCell.TYPE.MS , MetricTableRowCell.TYPE.PAGES_PER_SECOND , MetricTableRowCell.TYPE.PERCENTAGE , MetricTableRowCell.TYPE.REQUESTS_PER_SECOND , MetricTableRowCell.TYPE.SECONDS , MetricTableRowCell.TYPE.TIMESTAMP , MetricTableRowCell.TYPE.UNKNOWN , > valuerequirednumber Metric value, always in the shape of a number. Methods MetricTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 846.0654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "}&gt; &lt;<em>TableHeader</em>&gt; &lt;<em>TableHeaderCell</em>&gt;User&lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em>&gt; &lt;Metric<em>TableRowCell</em> type={Metric<em>TableRowCell</em>.TYPE.BITS} value={item.value} &#x2F;&gt; &lt;&#x2F;<em>TableRow</em>&gt; )} &lt;&#x2F;<em>Table</em>&gt; ); } 1 function render() { 2 const items = [ 3 { 4 value: 123456789, 5 }, 6 ]; 7 8 return ( 9 &lt;<em>Table</em>"
      },
      "id": "5efa98d5e7b9d2c0397bab3c"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Automate workflows",
      "updated_at": "2021-03-11T01:48:25Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 6637.658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " <em>using</em> <em>Helm</em> <em>charts</em> 20 min Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> <em>Use</em> <em>New</em> <em>Relic</em> to diagnose problems 30 min Learn to diagnose problems <em>using</em> <em>New</em> <em>Relic</em>."
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Introduction to the Kubernetes integration",
        "Get started: Install the Kubernetes integration",
        "Tip",
        "Why it matters",
        "Navigate all your Kubernetes events",
        "Bring your cluster logs to New Relic",
        "Check the source code"
      ],
      "title": "Introduction to the Kubernetes integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Get started"
      ],
      "external_id": "c641d1367f1f8fd2b589a2707112759becae609b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration/",
      "published_at": "2021-03-12T01:49:26Z",
      "updated_at": "2021-03-10T01:58:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Kubernetes integration gives you full observability into the health and performance of your environment, no matter whether you run Kubernetes on-premises or in the cloud. With our cluster explorer, you can cut through layers of complexity to see how your cluster is performing, from the heights of the control plane down to applications running on a single pod. one.newrelic.com > Kubernetes cluster explorer: The cluster explorer is our powerful, fully visual answer to the challenges associated with running Kubernetes at a large scale. You can see the power of the Kubernetes integration in the cluster explorer, where the full picture of a cluster is made available on a single screen: nodes and pods are visualized according to their health and performance, with pending and alerting nodes in the innermost circles. Predefined alert conditions help you troubleshoot issues right from the start. Clicking each node reveals its status and how each app is performing. Get started: Install the Kubernetes integration We have an automated installer to help you with many types of installations: servers, virtual machines, and unprivileged environments. It can also help you with installations in managed services or platforms, but you'll need to review a few preliminary notes before getting started. Here's what the automated installer does: Asks for the cluster name and namespace of the integration. Asks for additional setup options, such as Kube state metrics. Asks for the installation method: manifest file or Helm. Generates either the manifest or Helm chart. Read the install docs Start the installer Tip If your New Relic account is in the EU region, access the automated installer from one.eu.newrelic.com. Why it matters Governing the complexity of Kubernetes can be challenging; there's so much going on at any given moment, with containers being created and deleted in a matter of minutes, applications crashing, and resources being consumed unexpectedly. Our integration helps you navigate Kubernetes abstractions across on-premises, cloud, and hybrid deployments. In New Relic, you can build your own charts and query all your Kubernetes data, which our integration collects by instrumenting the container orchestration layer. This gives you additional insight into nodes, namespaces, deployments, replica sets, pods, and containers. one.newrelic.com > Dashboards: Using the chart builder you can turn any query on Kubernetes data to clear visuals. With the Kubernetes integration you can also: Link your APM data to Kubernetes to measure the performance of your web and mobile applications, with metrics such as request rate, throughput, error rate, and availability. Monitor services running on Kubernetes, such as Apache, NGINX, Cassandra, and many more (see our tutorial for monitoring Redis on Kubernetes). Create new alert policies and alert conditions based on your Kubernetes data, or extend the predefined alert conditions. These features are in addition to the data New Relic already reports for containerized processes running on instrumented hosts. Navigate all your Kubernetes events The Kubernetes events integration, which is installed separately, watches for events happening in your Kubernetes clusters and sends those events to New Relic. Events data is then visualized in the cluster explorer. To set it up, check the Kubernetes events box in step 3 of our install wizard, or follow the instructions. one.newrelic.com > Kubernetes cluster explorer > Events: Browse and filter all your Kubernetes events, and dig into application logs and infrastructure data. Bring your cluster logs to New Relic Our Kubernetes plugin for log monitoring can collect all your cluster's logs and send them to our platform, so that you can set up new alerts and charts. To set it up, check the Log data box in step 3 of our install wizard, or follow the instructions. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or you can create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.32059,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Bring your cluster logs to <em>New</em> <em>Relic</em>",
        "body": " data. Bring your cluster logs to <em>New</em> <em>Relic</em> Our Kubernetes plugin for log monitoring can collect all your cluster&#x27;s logs and send them to our platform, so that you can <em>set</em> <em>up</em> <em>new</em> alerts and <em>charts</em>. To <em>set</em> it <em>up</em>, check the Log data box in step 3 of our install wizard, or follow the instructions"
      },
      "id": "6043a212196a678d86960f46"
    },
    {
      "sections": [
        "Get outage information (status.newrelic.com)",
        "Subscribe to status.newrelic.com",
        "Update subscription preferences"
      ],
      "title": "Get outage information (status.newrelic.com)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "97ea6b2597ebb4a2eca901d2332b6d49b3b4c156",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-outage-information-statusnewreliccom/",
      "published_at": "2021-03-11T07:03:44Z",
      "updated_at": "2021-03-11T07:03:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If New Relic experiences an outage, we provide updates on our status page, status.newrelic.com. During an incident, the status page specifies what is impacted, the extent of the impact, and our progress in resolving the issue. Subscribe to status.newrelic.com If you use the New Relic platform and want to be notified about some incidents, subscribe to notifications for our status page. Using the subscription process, narrow your notifications to only the regions, categories, and impacts that matter to your usage of New Relic; and avoid oversubscribing to notifications on incidents impacting features or services you don’t use. To subscribe to notifications: Go to status.newrelic.com. Select Subscribe to updates. Choose between email and SMS updates: For email updates: Enter your email address and select Manage notifications. For SMS updates: Specify your country, enter your phone number, and select Manage notifications. From the Subscription preferences page, select the regions, categories, and impacts for which you want to receive notifications. To save your changes and subscribe to notifications, select Submit. Update subscription preferences Once subscribed to status.newrelic.com, follow the same steps to make changes to your subscription preferences.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.56215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Update</em> subscription preferences",
        "tags": "<em>Using</em> <em>New</em> <em>Relic</em>",
        "body": "If <em>New</em> <em>Relic</em> experiences an outage, we provide updates on our status page, status.newrelic.com. During an incident, the status page specifies what is impacted, the extent of the impact, and our progress in resolving the issue. Subscribe to status.newrelic.com If you <em>use</em> the <em>New</em> <em>Relic</em> platform"
      },
      "id": "60445d5c196a67e4b1960f4c"
    },
    {
      "sections": [
        "Our EU and US region data centers",
        "Requirements",
        "Regions and availability",
        "Regions and account hierarchy",
        "Hierarchy example for partnership accounts",
        "Create an EU region account",
        "API endpoints for EU region accounts",
        "Access New Relic One",
        "Billing and pricing",
        "Operational access and processing",
        "Verify your account is based in EU region"
      ],
      "title": "Our EU and US region data centers",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "38baae8599707418dbb5d42e05001e202b1bd28c",
      "image": "https://docs.newrelic.com/static/d22ffcc8535edcfb0d8bc64ff3444874/c1b63/Eu_account_hierarchy.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers/",
      "published_at": "2021-03-11T04:42:38Z",
      "updated_at": "2021-03-11T04:42:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's global data hosting structure consists of two regions: the European Union (EU) region and the United States (US) region. Selecting your preferred region during the account setup process allows you to specify the region where your performance monitoring data will be hosted. You can also create accounts in each region. Requirements Access to the New Relic EU region requires the latest agent version. For new customers: Install the most recent agent version. For existing customers: Update to the most recent agent version. Minimum agent version required: C SDK 1.0.0 or higher Go 2.0.0 or higher Java 4.0.0 or higher .NET 8.0.0 or higher Node.js 3.0.0 or higher PHP 8.0.0.204 or higher Python 3.0.0.89 or higher Ruby 5.0.0.342 or higher Regions and availability Your choice of data center is not limited by your geographic location. You can choose to create an account with data hosted in either the EU or US region, regardless of where you or your systems reside. You can also create accounts in each region. New Relic offers almost all the same active products, features, support offerings, and performance levels in the EU region as what is offered in the US region. Exceptions: The following are not supported with an EU region account: Infinite Tracing is not available. APM's weekly performance reports are not available. The Plugins product is unavailable and is not supported. Deprecated products and features are not available. New Relic's Incident Intelligence service operates solely in the U.S. Whether you store your data in New Relic’s US region data center or New Relic’s EU region data center, by using New Relic Incident Intelligence, you consent that New Relic may move your data to, and process your data in, the US region. Regions and account hierarchy You can create accounts in each region. If your data is currently being hosted in the US region, you must create a new account to store data in the EU region. You cannot view EU data from a US account, or US data from an EU account. The data collected remains separate. The data cannot be aggregated or migrated between accounts. For standard accounts, you can only have one master account. For more information, see Manage apps or users with sub-accounts. For partnership accounts, no changes to the partnership owner account are required. However, data cannot be shared across regions, so a partnership requires a master account for each region. Hierarchy example for partnership accounts With partnership accounts, a new master account must be created for any data to be host in the EU region. This hierarchy illustrates how global accounts are structured with partnership owner accounts. Data is not aggregated beyond the master account. Example hierarchy for partnership organizations. Because data cannot be shared across regions, a partnership will require a master account for each region. Create an EU region account To create a New Relic account in the EU region: Go to the New Relic signup page. OR If you have a specific offer from a New Relic partner, follow that link directly. Follow the online steps to create your account. From the Select your region dropdown, select European Union. Agree to the Terms of Service. When you receive an email confirmation message, select the link to confirm your account and sign in to New Relic. Then install or update to the most recent agent version. API endpoints for EU region accounts If you have an EU region account, use the appropriate endpoints to access the following New Relic APIs: API EU endpoint Browser source maps API sourcemaps.service. eu .newrelic.com Copy Infrastructure Alert API infra-api. eu .newrelic.com Copy Dashboard API rpm. eu .newrelic.com/api/explore/dashboards/list Copy Insert API insights-collector. eu01 .nr-data.net Copy Insights Query API insights-api. eu .newrelic.com Copy Mobile apps rpm. eu .newrelic.com/mobile Copy NerdGraph GraphiQL API api. eu .newrelic.com/graphiql Copy Partner API The partner API is a global API with no regional data differences. Use this endpoint for both EU and US accounts: rpm.newrelic.com/api/v2/partners/ Copy REST API api. eu .newrelic.com Copy Synthetics API synthetics. eu .newrelic.com/synthetics/api Copy Trace API trace-api. eu .newrelic.com/trace/v1 Copy Metric API metric-api. eu .newrelic.com/metric/v1 Copy Log API log-api. eu .newrelic.com/log/v1 Copy Access New Relic One If your accounts report data to the EU data center, use the following link to go to New Relic One: one.eu.newrelic.com. Billing and pricing New Relic's account billing process and pricing options are the same for both the EU and US regions. Operational access and processing Customer Data is hosted in the region selected during account creation. All other information, including account information (such as license subscription information, billing, and internal monitoring) is hosted in the US region and replicated in the EU region. New Relic may access and process Customer Data in the United States and such other jurisdictions where New Relic has affiliates and subsidiaries, including as may be necessary to maintain, secure, or perform the services, to provide technical support, or as necessary to comply with law or a binding order of a government body. Customer Data from existing New Relic accounts cannot be transferred or shared across regions, and new data generated cannot be shared with existing accounts, even in partnership accounts. Verify your account is based in EU region Use either of these options to verify whether your account data is hosted in the EU region's data center: In APM, mouse over the application name to view the URL. If it begins with rpm.eu.newrelic.com/, it is an EU-based account. Check your New Relic license key. If it begins with EU, it is an EU-based account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.23471,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Access <em>New</em> <em>Relic</em> One",
        "tags": "<em>Using</em> <em>New</em> <em>Relic</em>",
        "body": " operates solely in the U.S. Whether you store your data in <em>New</em> <em>Relic</em>’s US region data center or <em>New</em> <em>Relic</em>’s EU region data center, by <em>using</em> <em>New</em> <em>Relic</em> Incident Intelligence, you consent that <em>New</em> <em>Relic</em> may move your data to, and process your data in, the US region. Regions and account hierarchy You can"
      },
      "id": "6044586c64441f844b378edd"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "Tip",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs) | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8s@2x-ed6795cfdb010c5eabb1cfe9c83a82a9.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-03-08T15:34:35Z",
      "updated_at": "2021-03-02T20:47:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. Tip To use CPMs and synthetic monitoring, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a Scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a Simple Browser or Scripted Browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a Runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and Memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.09787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized private minions (CPMs) | <em>New</em> <em>Relic</em> Documentation",
        "sections": "Install and <em>update</em> CPM versions",
        "body": " environment. The CPM will auto-detect its environment to select the appropriate operating mode. Tip To <em>use</em> CPMs and synthetic monitoring, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign <em>up</em> to create your free account in only a few seconds. Then ingest <em>up</em> to 100GB of data"
      },
      "id": "603ea47f28ccbcf987eba775"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "a8e6eb8132628da407bf24eeeca752931f4a09df",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/",
      "published_at": "2021-03-12T01:46:22Z",
      "updated_at": "2021-03-09T01:49:21Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 655.45764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6046d422e7b9d27a66579a0b"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-02-06T01:55:17Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostModules directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_channel\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your module.tf and provider.tf to the stage for commit: bash Copy $ git add module.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.15424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "601df70628ccbce8510133b6"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.9245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "601df6bb196a67eb59da2d81"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-03-11T03:15:01Z",
      "updated_at": "2021-03-11T03:15:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If this is a sub-account, the list shows only the sub-account users, not all the users in the master account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.59953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View or update user email <em>channels</em>",
        "sections": "View or update user email <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "&#x27;s <em>notification</em> <em>channel</em>. To add or update account users as <em>notification</em> channels for a policy: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click Policies, and then choose the policy you want to change. Optional: You can update <em>notification</em> channels for specific users. On the <em>Notification</em>"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-03-12T01:49:20Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.05075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.6786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.6786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 468.50937,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.99945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.79184,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Build a custom visualization for dashboards",
        "Add a table to your app",
        "Permissions for managing applications",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Build apps",
      "updated_at": "2021-03-11T01:51:44Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Build a custom visualization for dashboards 15 min Create custom data views Add a table to your app 30 min Add a table to your New Relic One app Permissions for managing applications   Learn about permissions for subscribing to apps Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.68097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and <em>add</em> it to a dropdown menu in an application <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. <em>Add</em> a time picker to your app"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "New Relic Global Performance data sets",
        "Important",
        "Access valuable data and try out New Relic",
        "Get started with the Public API Performance dashboard"
      ],
      "title": "New Relic Global Performance data sets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "ed1b2c2cdfb59dae247d2690bd470a93b585c9e8",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/new-relic-global-performance-data-sets/",
      "published_at": "2021-03-11T07:03:43Z",
      "updated_at": "2021-03-11T07:03:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic’s Global Performance data sets, a part of the Telemetry Data Platform, offer immediate access to meaningful, large-scale, aggregated telemetry data. Global Performance data sets data are useful for: Existing New Relic customers who want to gain general monitoring and troubleshooting insights from a curated collection of aggregated, real-world data. Newcomers who want to get a feel for New Relic’s dashboards and data tools and view real data visualizations in order to make informed decisions about how to add their own data to New Relic. This resource provides information about the Global Performance data sets, how they work, what they do, and current options for accessing Global Performance data. Public API Performance dashboard Important Please note: Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Access valuable data and try out New Relic Our first Global Performance data set, Public API Performance, offers a large body of real-world, real-time data about the performance of public APIs including AWS, Google, and more as experienced by New Relic customers (as authorized). Because this data is already flowing through New Relic, you can access it within seconds of activating your account, and test drive New Relic dashboarding and querying capabilities in the process. There’s no need to connect your own data sources to New Relic first, although we recommend you do so because adding your own data is easy, free, and the best way to understand how New Relic can serve your business needs. Get started with the Public API Performance dashboard To help you get started using Public API Performance data, we've created a Public API Performance dashboard. This dashboard provides both actionable general insights and analytics and also an example of how you might apply dashboarding capabilities to your own data. Both new and existing customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see Explore the Public API Performance dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.2103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Global Performance <em>data</em> sets",
        "sections": "New Relic Global Performance <em>data</em> sets",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " insights from a curated collection of aggregated, real-world <em>data</em>. Newcomers who want to get a feel for New Relic’s dashboards and <em>data</em> tools and view real <em>data</em> visualizations in order to make informed decisions about how to <em>add</em> their own <em>data</em> to New Relic. This resource provides information about"
      },
      "id": "60445920196a673eee960f25"
    },
    {
      "sections": [
        "Filter New Relic One dashboards by facets",
        "Why use facet filtering?",
        "Requirements",
        "Example use of facet filtering",
        "Facet linking with the FACET CASES clause"
      ],
      "title": "Filter New Relic One dashboards by facets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "107c9537e64d2568fcba3ec6a717b84684c24a41",
      "image": "https://docs.newrelic.com/static/8190f8c9ef92e92ca0996c32b91b53a5/c1b63/facetfiltering01bis.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/filter-new-relic-one-dashboards-facets/",
      "published_at": "2021-03-11T04:43:59Z",
      "updated_at": "2021-03-11T04:43:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can filter your New Relic One dashboards by faceted attributes, making your dashboards more interactive and easy to use. Why use facet filtering? In New Relic One dashboards, for NRQL queries containing a FACET clause and meeting other chart-type requirements, you can set up the faceted attributes to filter the current dashboard or a related, linked dashboard. By letting you quickly filter your dashboards, and link to pre-filtered dashboards, your dashboards are more interactive and easy to use. This feature is available when adding a new chart to a dashboard or when editing a chart on an existing dashboard. To see this feature in action, see the example use case. Requirements Requirements to use this feature: Must be in New Relic One dashboards. Will not work on a standalone chart in the query builder. NRQL query must contain a FACET clause. Available only for bar charts, heat maps, pie charts, and tables. Example use of facet filtering Let's say you create the following facet-containing NRQL query for an existing dashboard in New Relic One: one.newrelic.com > Dashboards: For queries containing a FACET clause and meeting chart-type requirements, you can set those attributes to be used as an easy dashboard filter. You can set the attribute to filter the current dashboard you're on, or filter a related dashboard that you select. If you select Filter the current dashboard, that chart will be used to filter the current dashboard by the available userAgentName attributes. Here's a view of selecting one of those attributes to filter that dashboard. Notice that the chosen attribute appears as a filter in the search bar at the top. one.newrelic.com > Dashboards: When you select an attribute you've set up for facet filtering, it filters the current dashboard. For more about this feature, see the Explorers Hub post on facet filtering. Facet linking with the FACET CASES clause FACET CASES is a NRQL function that allows to group facets based on conditions. We support multiple cases in the same facet. For example, let's say you query your applications, but you don't know which have been migrated to cloud and which haven't. SELECT filter(count(*), WHERE duration > 1) as 'On-premises', filter(count(*), WHERE duration < .06) as 'AWS' FROM Transaction WHERE appName NOT LIKE '%Tower%' FACET appName LIMIT 5 since 5 minutes ago Copy By using FACET cases, you can add the condition and obtain the status of the migration: SELECT count(*) FROM Transaction WHERE appName NOT LIKE '%Tower%' facet cases(WHERE appName = 'WebPortal' OR appName = 'Plan Service' as '% of Hosts On-Prem', WHERE appName != 'WebPortal' AND appName != 'Plan Service' as '% of Hosts in Cloud') since 10 minutes ago limit 100 Copy Then, using facet linking, you can filter your dashboards by those facets.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.5941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " on an existing dashboard. To see this feature in action, see the example use case. Requirements Requirements to use this feature: Must be in New Relic One dashboards. Will not work on a standalone chart in the <em>query</em> builder. NRQL <em>query</em> must contain a FACET clause. Available only for bar charts, heat maps"
      },
      "id": "60445d1e28ccbc23082c60af"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Tip",
        "Why it matters",
        "See your dashboards across all New Relic",
        "Get started with dashboards",
        "Create a dashboard",
        "Import a dashboard",
        "Clone a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-03-08T15:35:46Z",
      "updated_at": "2021-03-07T04:41:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Tip To use dashboards and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. Chart all the events and attributes from everywhere across our platform. For more information, see our documentation on default data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. See your dashboards across all New Relic New Relic One dashboards have full backwards compatibility with the original New Relic platform, so any dashboard you have created in Insights will be automatically available in dashboards from day one. Reciprocally, when you add a new dashboard, it is also created in Insights. No further action is needed. With New Relic One you can also view dashboards across your organization using cross-account search. Tip Switching to New Relic One from Insights? See our transition guide. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our entity explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By cloning an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the entity explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Clone a dashboard Clone any dashboard by clicking the Clone dashboard button that appears when you hover over any dashboard row in the index. You can clone any dashboard regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word \"copy\". For example, if you clone a dashboard named this is my dashboard, the clone will be created as this is my dashboard copy. The clone has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your cloned dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can clone it. Private: Only you can see the dashboard. When you create a dashboard using the Create a dashboard button or by cloning another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.42833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> scrubber",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " also create a new dashboard: By cloning an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the <em>data</em> explorer or the <em>query</em> builder: <em>Add</em> any chart you create from our querying features to a new or an existing dashboard. From the entity"
      },
      "id": "603ec16028ccbc8d07eba78d"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-03-08T15:30:38Z",
      "updated_at": "2021-03-06T16:11:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's guid, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Add a new page. Pages allow you to better organize your dashboards. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. Access the query builder to see or edit the query associated to the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.71434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> new content to your dashboard",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " Relic One. <em>Add</em> new content to your dashboard There are multiple ways to <em>add</em> new content to your dashboard: From the <em>data</em> explorer and <em>query</em> builder features. Use the + <em>Add</em> to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the <em>query</em> builder, or to <em>add</em>"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Build a custom visualization for dashboards",
        "Add a table to your app",
        "Permissions for managing applications",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Build apps",
      "updated_at": "2021-03-11T01:51:44Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Build a custom visualization for dashboards 15 min Create custom data views Add a table to your app 30 min Add a table to your New Relic One app Permissions for managing applications   Learn about permissions for subscribing to apps Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.54837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.37024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights&#x27; 3-across limit Easier creation of dashboards with multiple pages (previously called <em>data</em> <em>apps</em> in Insights). Your Insights <em>data</em> <em>apps</em> are preserved as multi-page dashboards in <em>New</em> <em>Relic</em> <em>One</em>. Improved"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 278.83646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and understandable description of the APIs&#x27; <em>data</em>. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the <em>new</em> <em>New</em> <em>Relic</em> <em>One</em> dashboards API. Find below some examples that illustrate how the old"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 277.6668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of <em>data</em> for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.85228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system <em>components</em>. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any <em>data</em> in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom <em>data</em>. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 496.9451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 496.9451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 464.08884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 440.80072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 440.5951,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.6786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.6786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-03-12T01:48:26Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 485.08975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 468.50937,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.99945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Build a custom visualization for dashboards",
        "Add a table to your app",
        "Permissions for managing applications",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Build apps",
      "updated_at": "2021-03-11T01:51:44Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Build a custom visualization for dashboards 15 min Create custom data views Add a table to your app 30 min Add a table to your New Relic One app Permissions for managing applications   Learn about permissions for subscribing to apps Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 850.6858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, <em>query</em>, and mutate data using Nerd<em>Storage</em> 45 min Nerd<em>Storage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-03-11T00:18:44Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 773.3892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store data in an encrypted <em>storage</em> solution with NerdStorageVault",
        "sections": "Store data in an encrypted <em>storage</em> solution with NerdStorageVault",
        "body": ": Personal access tokens License keys API keys Third-party secrets Nerd<em>Storage</em>Vault is currently only available in the alpha release of the nr1-community component library and is not available in the <em>New</em> <em>Relic</em> <em>One</em> core <em>components</em> library. The feature uses AES-256 encryption."
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 771.91455,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " features result in incompatibilities between <em>New</em> <em>Relic</em> <em>One</em> and Insights charts. Also: Dashboards with multiple pages are no longer called Data <em>apps</em>. When you create a <em>New</em> <em>Relic</em> <em>One</em> dashboard that has multiple pages and go back to Insights, it will be located in the Data <em>apps</em> section. Some admin-related <em>UI</em>"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 747.9109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability <em>platform</em>, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads | New Relic Documentation",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-03-08T15:31:58Z",
      "updated_at": "2021-03-02T18:20:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. A Workload looks like this: Important components in the New Relic One workload UI. The screenshot numbers are important parts of the workload UI we'd like to describe to you: The Overview tab shows the most relevant entity performance and alert data that you need to operate the workload. View of workload components. This is useful for understanding the workload’s architecture, especially if the workload’s entities change over time because they are dynamically defined. Important charts. These are charts with key metrics for each entity type, such as number of requests, response time and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level. Workload status. You can configure the status to inform about how your workload is performing, based on the individual alerting status of the entities in your workload. Open violations. You can filter the workload to only the alerting entities to make it easier to troubleshoot the most important issues. Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. The Entities tab shows the entities that make up the workload. If you’ve used queries to dynamically select entities, the workload entities will change over time. Edit workload. Edit the workload to define the entities that are part of the workload and to link dashboards to the workload. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's GUID and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Apps > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 740.3998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use workloads | <em>New</em> <em>Relic</em> Documentation",
        "sections": "How the dynamic <em>query</em> logic works",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "To view workloads, go to <em>one</em>.newrelic.com and find them on the Explorer. A Workload looks like this: Important <em>components</em> in the <em>New</em> <em>Relic</em> <em>One</em> workload <em>UI</em>. The screenshot numbers are important parts of the workload <em>UI</em> we&#x27;d like to describe to you: The Overview tab shows the most relevant entity"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.6786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.6786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 468.50937,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.99945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.79184,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-03-12T01:46:23Z",
      "updated_at": "2020-12-04T01:59:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 351.74783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " in your terminal: bash Copy $ <em>nr1</em> nerdpack:publish Step 2 of 4 Close your local New Relic <em>One</em> development tab, and open New Relic <em>One</em>. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic <em>One</em> <em>catalog</em>, click the launcher for your new application. When your new application opens, notice"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation | New Relic Documentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-03-08T15:36:49Z",
      "updated_at": "2021-03-02T20:41:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.14447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.1498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you’re looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 μs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is “loading” its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.66895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>nr1</em> <em>cli</em>",
        "body": " <em>visualizations</em>, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series&#x27;s <em>visual</em> style"
      },
      "id": "5fdab9f1e7b9d2e1e8df9221"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.143234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to New Relic <em>One</em> from Insights",
        "sections": "Transition to New Relic <em>One</em> from Insights",
        "tags": "New Relic <em>One</em>",
        "body": " experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your <em>visualizations</em> Try out New Relic <em>One</em> It&#x27;s easy to try out and switch to New Relic <em>One</em>. We recommend reading the recommendations before you do. Then, to view your Insights dashboards"
      },
      "id": "6044171164441f454a378ee2"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 496.9451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 496.9451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 464.08884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 440.80072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 440.5951,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 496.9451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 496.9451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 464.08884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 440.80072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 440.5951,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across apps, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-03-08T15:36:42Z",
      "updated_at": "2021-03-02T23:06:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.87286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> your dashboard visualizations",
        "body": " an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user <em>permissions</em>, which include the <em>Nerdpack</em> <em>manager</em> role, you can add a visualization to a dashboard as described in the following section. The process for creating"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "sections": [
        "CoCreateInstance errors: No profiler log",
        "Problem",
        "Important",
        "Solution",
        "Check for profiler CLSID errors.",
        "Verify the New Relic assemblies.",
        "Verify the w3wp.exe environment details.",
        "Check for profiler logs.",
        "Resolve the permissions error."
      ],
      "title": "CoCreateInstance errors: No profiler log",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "8a40fa040abbd895cc219a2dece0d9be92a9a27e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/cocreateinstance-errors-no-profiler-log/",
      "published_at": "2021-03-11T02:33:50Z",
      "updated_at": "2021-03-11T02:33:50Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After you generate traffic and wait a few minutes, your .NET application does not report data to New Relic. In addition, there is no New Relic profiler log for your .NET app. Important If you are an Azure Websites user experiencing CoCreateInstance errors, get support at support.newrelic.com. Solution To verify whether New Relic has the necessary permissions and resolve the problem, follow these troubleshooting steps. Check for profiler CLSID errors. To verify whether the permissions error is due to profiler errors: Check your application event log for errors like this: NET Runtime version 4.0.30319.296 - Loading profiler failed during CoCreateInstance. Profiler CLSID: '{FF68FEB9-E58A-4B75-A2B8-90CE7D915A26}' Copy Compare the CLSID in the error to New Relic's CLSIDs: 71DA0A04-7777-4EC6-9643-7D28B46A8A41 FF68FEB9-E58A-4B75-A2B8-90CE7D915A26 Copy Do one of the following: If the CLSID does not match, uninstall the other profiler. If the CLSID does match, continue with this procedure to check the profiler logs for CoCreateInstance permissions errors. Verify the New Relic assemblies. To verify that the New Relic assemblies are attached to the w3wp.exe process: On the server where your app is installed, download the Microsoft Windows Sysinternals Process Explorer. Unzip the file and run procexp.exe as an Administrator. Select View > Show Lower Pane, then select View > Lower Pane View > DLLs. Generate some traffic to your app. To update the process list, select View > Refresh Now. In the top pane, select your service or w3wp instance (typically nested under a svchost.exe process). In the bottom pane, look for assemblies whose names begin with NewRelic, including: NewRelic.Agent.Core.dll NewRelic.Profiler.dll NewRelic.Agent.IL.dll NewRelic.ICSharpCode.SharpZipLib.dll NewRelic.Json.dll NewRelic.Log.dll Copy If you do not find any assemblies, get support at support.newrelic.com Verify the w3wp.exe environment details. Verify that the w3wp.exe environment details are this: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=C:\\Program Files\\New Relic\\.NET Agent\\ Copy Check for profiler logs. Check for profiler logs in %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Make sure there are no profiler logs for the web app you are troubleshooting. If you have a simple or default site installation, ignore any profiler logs for other web apps. Resolve the permissions error. If all the above conditions are present, you have a permissions error. Use any of these options to resolve the permissions error as applicable: Available options Resolve permissions errors Set permissions for the Everyone group. Adjust permissions in the following folders for the Everyone group to give the group all permissions except Full Control: C:\\Program Files\\New Relic\\.NET Agent\\ Copy C:\\Program Files (x86)\\New Relic\\.NET Agent\\ Copy Set permissions for individual users. If your security policies do not allow adjusting permissions for the Everyone group, then adjust permissions for individual users. Record the users under which your application runs, then adjust permissions for each of those users. Set permissions using the PowerShell script. To add permissions to HKLM\\SOFTWARE\\New Relic by using the PowerShell script: $key = \"HKLM:\\SOFTWARE\\New Relic\" $acl = Get-Acl $key $AddACL = New-Object System.Security.AccessControl.RegistryAccessRule (\"Everyone\",\"FullControl\",\"ObjectInherit,ContainerInherit\",\"None\",\"Allow\") $acl.SetAccessRule($AddACL) $acl |Set-Acl -Path $key Copy For 32-bit apps, the path would be HKLM:\\SOFTWARE\\Wow6432Node\\New Relic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.14703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Resolve the <em>permissions</em> error.",
        "body": " for other web <em>apps</em>. Resolve the <em>permissions</em> error. If all the above conditions are present, you have a <em>permissions</em> error. Use any of these options to resolve the <em>permissions</em> error as applicable: Available options Resolve <em>permissions</em> errors Set <em>permissions</em> for the Everyone group. Adjust <em>permissions</em>"
      },
      "id": "6043d832196a676500960f80"
    },
    {
      "sections": [
        "No data and registry key permission issues",
        "Problem",
        "Solution",
        "Important",
        "To grant the Everyone user access to the registry key:",
        "To grant individual app pool identities access to the registry key:",
        "Tip",
        "Cause"
      ],
      "title": "No data and registry key permission issues",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "0841acdb1cd845abd30ee0c344da0e0130343c88",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-data-registry-key-permission-issues/",
      "published_at": "2021-03-11T02:34:52Z",
      "updated_at": "2021-03-11T02:34:51Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic for your .NET app and waiting five minutes, data still does not appear in the New Relic UI. Solution Important Check with your system administrator before changing permissions. Ensure the app pool identity has read access to the New Relic registry key located at: HKLM\\SOFTWARE\\New Relic\\.NET Agent\\ Copy Grant all users on the system access to this registry key, or allow only the app pool identity to access the key. To grant the Everyone user access to the registry key: As Admin, open the Windows registry. Select Computer > HKEY_LOCAL_MACHINE > Software > New Relic. Right-click .NET Agent, then select Permissions. If you do not see an Everyone user in the Group or user names list, create the user: Select Add. Then, from Select Users or Groups: In the Enter the object name to select field, type Everyone. Select OK. In the Group or user names list, select Everyone. Then, in the Permissions for table, select the Allow checkbox for Read permissions. To grant individual app pool identities access to the registry key: Determine your app pool identity, which uses this standard format: IIS AppPool\\APP_POOL_NAME Copy As admin, open the Windows registry. Select Computer > HKEY_LOCAL_MACHINE > Software > New Relic. Right-click .NET Agent, then select Permissions. From the Permissions for .NET Agent dialog, select Add. Then, from Select Users or Groups: In the Enter the object name to select field, type your app pool identity (for example, IIS AppPool\\APP_POOL_NAME). Select OK. In the Group or user names list, select your new app pool identity. Then, in the Permissions for table, select the Allow checkbox for Read permissions. From the command line, perform an IISRESET. If updating permissions does not resolve the problem, follow the .NET agent's troubleshooting procedures for missing data. Tip To prevent this problem from happening with future installs, uninstall WSM 3.3.5.0. If you do not want to make changes to your registry, uninstall WSM and .NET, then reinstall the latest versions. Cause A common reason why data does not appear is because the New Relic .NET agent cannot access its registry keys. You may see registry permission errors in your profiler logs at: %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs\\ Copy For example, you may see: [Info] ... Logger initialized [Error] ... Unable to find New Relic Home directory in registry or environment. [Error] ... An exception was thrown while initializing the profiler. Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.4019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data and registry key <em>permission</em> issues",
        "sections": "No data and registry key <em>permission</em> issues",
        "body": "Problem After generating traffic for your .NET <em>app</em> and waiting five minutes, data still does not appear in the New Relic UI. Solution Important Check with your system administrator before changing <em>permissions</em>. Ensure the <em>app</em> pool identity has read access to the New Relic registry key located"
      },
      "id": "6043f856196a67cefd960f39"
    },
    {
      "sections": [
        "Insights dashboard permissions",
        "Important",
        "Permission levels",
        "Set the dashboard permission level"
      ],
      "title": "Insights dashboard permissions",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Manage dashboards"
      ],
      "external_id": "a5b5256b3f55535ade9acdcaa63e3930550e64cf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/manage-dashboards/insights-dashboard-permissions/",
      "published_at": "2021-03-11T08:52:27Z",
      "updated_at": "2021-03-11T08:52:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Insights has three levels of permissions for your dashboards, controlling how visible and editable they are. Permission levels The dashboard permissions are: Private to just me: If you created the dashboard, you're the only one who can view and edit it. This is the most secure option. Visible to others in my account: Everyone can view the dashboard, but only you can edit it. Editable by others in my account (default): Everyone can edit the dashboard. This includes deleting it. This table describes user roles as they relate to dashboard permissions. For more information, see: Add-on roles and permissions Permissions for deleting dashboards Permission level Creator Users Admins Owners Private to just me View, edit, delete None None None Visible to others in my account View, edit, delete View View, delete View, delete Editable by others in my account View, edit, delete View, edit, delete View, edit, delete View, edit, delete Set the dashboard permission level To set the permission level for a dashboard: Select a specific dashboard, then click Edit. Select the new permission level, then click Done editing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.167465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Insights dashboard <em>permissions</em>",
        "sections": "Insights dashboard <em>permissions</em>",
        "tags": "<em>Manage</em> dashboards",
        "body": " our Explorers Hub post. Insights has three levels of <em>permissions</em> for your dashboards, controlling how visible and editable they are. Permission levels The dashboard <em>permissions</em> are: Private to just me: If you created the dashboard, you&#x27;re the only one who can view and edit it. This is the most"
      },
      "id": "6043ee5664441f8231378f06"
    },
    {
      "sections": [
        "Determine permissions requirements (Java)",
        "Problem",
        "Solution"
      ],
      "title": "Determine permissions requirements (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "05ca8e4c4fbc4743afd0d47926aea805631f71e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/determine-permissions-requirements-java/",
      "published_at": "2021-03-11T07:48:47Z",
      "updated_at": "2021-03-11T07:48:47Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need to determine what system permissions you need to install and use the New Relic Java agent. Solution The process owner must meet the following permissions requirements for Java: The owner of the Java process to which the -javaagent option will be passed must have read permissions for the java agent JAR. This is because Java is what is being executed, and Java needs to read the newrelic.jar. The process owner requires write/execute permissions for the directory in which the log directory will be created and execute permissions for all parent directories of the log directory. This parent directory could be any of the following: The directory in which the newrelic.jar lives. This is the default location in which the New Relic java agent will create its logs directory. The location specified by the log_file_path system property also passed into the JVM StdOut if you have specified this location with the NEW_RELIC_LOG environment variable If the New Relic log directory already exists, the process owner must have write/execute access in this directory so the java process can traverse into the directory and create the java agent log file. The process owner must have write/execute access to the temp directory for the Java process. This may be the default directory for temporary Java files (specified system-wide), or it may be one specific to the process, particularly if you are running an application server as these often specify and configure a discrete temp directory location.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.81891,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Determine <em>permissions</em> requirements (Java)",
        "sections": "Determine <em>permissions</em> requirements (Java)",
        "body": "Problem You need to determine what system <em>permissions</em> you need to install and use the New Relic Java agent. Solution The process owner must meet the following <em>permissions</em> requirements for Java: The owner of the Java process to which the -javaagent option will be passed must have read <em>permissions</em>"
      },
      "id": "6044103f64441fd2db378ef3"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of Browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-03-11T03:19:34Z",
      "updated_at": "2021-03-11T03:19:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.49426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "tags": "Query your <em>data</em>",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop"
      ],
      "published_at": "2021-03-12T01:38:43Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-03-10T01:38:31Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.04605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the <em>Data</em> Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and visualizations.",
        "body": " a sandbox account you’ll get familiar with <em>NRQL</em> <em>syntax</em>, work with the Query Builder to build your own queries and charts, and create <em>data</em> rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-03-08T15:35:27Z",
      "updated_at": "2021-03-02T18:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.44934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "tags": "Query your <em>data</em>",
        "body": " high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar <em>data</em> but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em>"
      },
      "id": "603e8a2528ccbc56e5eba774"
    },
    {
      "sections": [
        "Use integration data in New Relic dashboards",
        "Get started with integration data",
        "Example NRQL queries",
        "AWS EBS query example",
        "Azure Service Bus query example",
        "Azure Functions query example",
        "Azure VMs query example",
        "NGINX query example",
        "MySQL query example",
        "Inventory change query example",
        "Tip",
        "Tips for using different data types",
        "Metric data tips",
        "Event data tips",
        "Inventory data tips"
      ],
      "title": "Use integration data in New Relic dashboards | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Integrations",
        "Infrastructure integrations",
        "Get started"
      ],
      "external_id": "b236b0fae29853de085d0430fdec27fba74c15d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/infrastructure-integrations/get-started/use-integration-data-new-relic-dashboards/",
      "published_at": "2021-03-08T15:35:24Z",
      "updated_at": "2021-03-07T17:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Most data generated by integrations is available in New Relic One dashboards, where you can query your data using NRQL and build custom dashboards. The following tips and sample queries were created for New Relic-built integrations, but most will also apply to integrations built with the Integrations SDK. For a general look at how to find and use integration data, see Understand integration data. Get started with integration data Here are some tips for finding and exploring your integration data in New Relic: From the one.newrelic.com > Infrastructure > Third-party services page, select an integration dashboard. There, you can view the NRQL queries that generated a chart. For examples of NRQL queries for integration data, see the example queries. Use the data explorer or the dashboards to explore and understand the available data. Read the documentation for a specific integration to learn about the reported data. When you create a useful query you'd like to add to your Insights dashboard, select Add to dashboard. Example NRQL queries Here are some examples of NRQL queries that use integration data: AWS EBS query example Here's a NRQL query for the AWS EBS service, showing the total write time metric over the past day, faceted by displayName: select average('provider.volumeTotalWriteTime.Sum') from BlockDeviceSample WHERE provider = 'EbsVolume' AND providerAccountId = '72' facet displayName TIMESERIES SINCE 1 day ago Copy Azure Service Bus query example Here's an Insights NRQL query for the number of messages in an Azure Service Bus topic queue, faceted by name: SELECT average(activeMessages) from AzureServiceBusTopicSample TIMESERIES 5 minutes since 6 hours ago FACET displayName Copy Azure Functions query example Here's an Insights NRQL query for Azure Functions, showing the count of executed functions over the past six hours: SELECT sum('functionExecutionCount.Total') FROM AzureFunctionsAppSample WHERE providerAccountId = '125' SINCE 6 hour ago TIMESERIES auto FACET displayName Copy Azure VMs query example Here's an Insights NRQL query for Azure VMs that compares the count of VM events over the past thirty minutes with the same time a week ago: SELECT count(*) FROM AzureVirtualMachineSample SINCE 30 MINUTES AGO COMPARE WITH 1 WEEK AGO WHERE provider = 'AzureVirtualMachine' TIMESERIES Copy NGINX query example Here's an example of a query that you might run on your NGINX integration data and place in an Insights dashboard. This query creates a chart showing the average value of NGINX requests per second over time: SELECT average('requestsPerSecond') as 'Requests' FROM NginxSample TIMESERIES until 1 minutes ago Copy For more on how to create queries, see NRQL syntax. MySQL query example Here's an example of a query that you might run on your MySQL integration data. This query generates a chart showing active MySQL connections over time: SELECT average('connectionsActive') as 'Active Connections' FROM MysqlSample TIMESERIES until 1 minutes ago Copy For more on how to create queries, see NRQL syntax. Inventory change query example Here's an example of a query that groups inventory change events from the last day by the type of change: SELECT count(*) from InfrastructureEvent where format='inventoryChange' facet changeType since 1 day ago Copy Tip You can also perform these queries using dimensional metrics. Tips for using different data types Integrations can generate metric, event, and inventory data, all of which are available for querying in New Relic Insights. Here are some tips for using the different types of integration data in Insights: Metric data tips Tips for finding and using integration metric data in Insights: All integration data is attached to a data type known as an event (not to be confused with events reported by integrations, which represent important activity in your host/service). This means that all integration data can be found via the data explorer. For more about these two basic New Relic data types, see New Relic data collection. Metric values are treated as attributes: key-value pairs attached to an event. For example, the MySQL integration has an 'active connections' metric; this would be found by querying the connectionsActive attribute of the MysqlSample event. For general information about metrics, see Integration metric data. Event data tips Here are some tips for finding and using integration event data in Insights: Most integration events are inventory change events. When inventory is changed, it generates an InfrastructureEvent with a format value of inventoryChange. Integration data can be found via the data explorer. For general information about events, see Integration event data. Inventory data tips Here are some tips for finding and using integration inventory data in Insights: For general information about inventory data, see Integration inventory data. Some inventory data is added as attributes (key-value pairs) to Insights data. For example, the AWS EC2 integration collects awsRegion as inventory data; this would be found in Insights by querying the awsRegion attribute of the ComputeSample event type and provider Ec2Instance. When inventory data changes, an Insights InfrastructureEvent event type is generated with a format value of inventoryChange. See the query examples for an example of querying this data. For more on using NRQL queries, see Intro to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.88487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use integration <em>data</em> in New Relic dashboards | New Relic Documentation",
        "sections": "Use integration <em>data</em> in New Relic dashboards",
        "body": ", see <em>NRQL</em> <em>syntax</em>. MySQL query example Here&#x27;s an example of a query that you might run on your MySQL integration <em>data</em>. This query generates a chart showing active MySQL connections over time: SELECT average(&#x27;connectionsActive&#x27;) as &#x27;Active Connections&#x27; FROM MysqlSample TIMESERIES until 1 minutes ago Copy"
      },
      "id": "60450a39196a67d7dc960f7c"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "Important",
        "General requirements",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "ee49e0ca9bf17447e8349123bfb470ff9964c4fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-03-08T15:31:13Z",
      "updated_at": "2021-03-06T21:08:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.04169,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em> | New Relic Documentation",
        "sections": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": " for supported <em>data</em> types, naming <em>syntax</em>, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute <em>data</em> types Attribute"
      },
      "id": "6043ef69e7b9d2da1f5799f8"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.03299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.41028,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-03-11T11:44:15Z",
      "updated_at": "2021-03-11T11:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API keys, see REST API keys. https://rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.44134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s REST API <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s REST API <em>Explorer</em>",
        "tags": "API <em>Explorer</em> v2",
        "body": ":&#x2F;&#x2F;rpm.newrelic.com&#x2F;api&#x2F;<em>explore</em>: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "New Relic Global Performance data sets",
        "Important",
        "Access valuable data and try out New Relic",
        "Get started with the Public API Performance dashboard"
      ],
      "title": "New Relic Global Performance data sets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "ed1b2c2cdfb59dae247d2690bd470a93b585c9e8",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/new-relic-global-performance-data-sets/",
      "published_at": "2021-03-11T07:03:43Z",
      "updated_at": "2021-03-11T07:03:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic’s Global Performance data sets, a part of the Telemetry Data Platform, offer immediate access to meaningful, large-scale, aggregated telemetry data. Global Performance data sets data are useful for: Existing New Relic customers who want to gain general monitoring and troubleshooting insights from a curated collection of aggregated, real-world data. Newcomers who want to get a feel for New Relic’s dashboards and data tools and view real data visualizations in order to make informed decisions about how to add their own data to New Relic. This resource provides information about the Global Performance data sets, how they work, what they do, and current options for accessing Global Performance data. Public API Performance dashboard Important Please note: Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Access valuable data and try out New Relic Our first Global Performance data set, Public API Performance, offers a large body of real-world, real-time data about the performance of public APIs including AWS, Google, and more as experienced by New Relic customers (as authorized). Because this data is already flowing through New Relic, you can access it within seconds of activating your account, and test drive New Relic dashboarding and querying capabilities in the process. There’s no need to connect your own data sources to New Relic first, although we recommend you do so because adding your own data is easy, free, and the best way to understand how New Relic can serve your business needs. Get started with the Public API Performance dashboard To help you get started using Public API Performance data, we've created a Public API Performance dashboard. This dashboard provides both actionable general insights and analytics and also an example of how you might apply dashboarding capabilities to your own data. Both new and existing customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see Explore the Public API Performance dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.19258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see <em>Explore</em> the Public API Performance dashboard."
      },
      "id": "60445920196a673eee960f25"
    },
    {
      "sections": [
        "Filter New Relic One dashboards by facets",
        "Why use facet filtering?",
        "Requirements",
        "Example use of facet filtering",
        "Facet linking with the FACET CASES clause"
      ],
      "title": "Filter New Relic One dashboards by facets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "107c9537e64d2568fcba3ec6a717b84684c24a41",
      "image": "https://docs.newrelic.com/static/8190f8c9ef92e92ca0996c32b91b53a5/c1b63/facetfiltering01bis.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/filter-new-relic-one-dashboards-facets/",
      "published_at": "2021-03-11T04:43:59Z",
      "updated_at": "2021-03-11T04:43:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can filter your New Relic One dashboards by faceted attributes, making your dashboards more interactive and easy to use. Why use facet filtering? In New Relic One dashboards, for NRQL queries containing a FACET clause and meeting other chart-type requirements, you can set up the faceted attributes to filter the current dashboard or a related, linked dashboard. By letting you quickly filter your dashboards, and link to pre-filtered dashboards, your dashboards are more interactive and easy to use. This feature is available when adding a new chart to a dashboard or when editing a chart on an existing dashboard. To see this feature in action, see the example use case. Requirements Requirements to use this feature: Must be in New Relic One dashboards. Will not work on a standalone chart in the query builder. NRQL query must contain a FACET clause. Available only for bar charts, heat maps, pie charts, and tables. Example use of facet filtering Let's say you create the following facet-containing NRQL query for an existing dashboard in New Relic One: one.newrelic.com > Dashboards: For queries containing a FACET clause and meeting chart-type requirements, you can set those attributes to be used as an easy dashboard filter. You can set the attribute to filter the current dashboard you're on, or filter a related dashboard that you select. If you select Filter the current dashboard, that chart will be used to filter the current dashboard by the available userAgentName attributes. Here's a view of selecting one of those attributes to filter that dashboard. Notice that the chosen attribute appears as a filter in the search bar at the top. one.newrelic.com > Dashboards: When you select an attribute you've set up for facet filtering, it filters the current dashboard. For more about this feature, see the Explorers Hub post on facet filtering. Facet linking with the FACET CASES clause FACET CASES is a NRQL function that allows to group facets based on conditions. We support multiple cases in the same facet. For example, let's say you query your applications, but you don't know which have been migrated to cloud and which haven't. SELECT filter(count(*), WHERE duration > 1) as 'On-premises', filter(count(*), WHERE duration < .06) as 'AWS' FROM Transaction WHERE appName NOT LIKE '%Tower%' FACET appName LIMIT 5 since 5 minutes ago Copy By using FACET cases, you can add the condition and obtain the status of the migration: SELECT count(*) FROM Transaction WHERE appName NOT LIKE '%Tower%' facet cases(WHERE appName = 'WebPortal' OR appName = 'Plan Service' as '% of Hosts On-Prem', WHERE appName != 'WebPortal' AND appName != 'Plan Service' as '% of Hosts in Cloud') since 10 minutes ago limit 100 Copy Then, using facet linking, you can filter your dashboards by those facets.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.5903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "60445d1e28ccbc23082c60af"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360/",
      "sections": [
        "Java agent v3.36.0",
        "Improvements",
        "Fixes"
      ],
      "published_at": "2021-03-11T03:30:39Z",
      "title": "Java agent v3.36.0",
      "updated_at": "2021-03-11T03:30:39Z",
      "type": "docs",
      "external_id": "620b9aa4068c44bd29515f153020db735791cd39",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.09694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page"
      },
      "id": "60445ebc196a676dd6960f5e"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.18881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "newrelic_add_custom_tracer (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "c3a4f57bd2b02aa46f896e6e54ef818bac7d66b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer/",
      "published_at": "2021-03-11T06:57:21Z",
      "updated_at": "2021-03-11T06:57:21Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_tracer(string $function_name) Copy Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Copy Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Copy Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Copy Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.235725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "body": "&quot; for <em>methods</em>. Both <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument"
      },
      "id": "6043c950196a67e23d960f2d"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-03-11T02:31:15Z",
      "updated_at": "2021-03-11T02:31:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.405952,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "function_trace (Python agent API)",
        "Syntax",
        "Description",
        "Important",
        "Alternate call forms",
        "The context manager",
        "The wrapper",
        "Path-based wrapping",
        "Parameters",
        "Parameters for decorator",
        "Parameters for context manager",
        "Wrapper parameters",
        "Path-based wrapping parameters",
        "Examples",
        "function_trace example",
        "Context manager example",
        "Wrapper example"
      ],
      "title": "function_trace (Python agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Python agent API"
      ],
      "external_id": "8c0c11c34a9d98922a56321682f20c2bfd63c3e4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/python-agent-api/functiontrace-python-agent-api/",
      "published_at": "2021-03-11T07:06:57Z",
      "updated_at": "2021-03-11T07:06:56Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.agent.function_trace(name=None, group=None, label=None, params=None, terminal=False) Copy Used to instrument functions, methods, generators, and coroutines that aren't instrumented by default. Description function_trace is a decorator for adding to functions, methods, generators, and coroutines. Adding this decorator lets you collect additional transaction information (including transaction trace information). (An alternate way to instrument functions without having to touch your app code is to list them in the config file.) function_trace does not give you a full profile of all the functions that happen in a decorated function. What it does is add the decorated function as a node in the New Relic UI and capture the time spent in that function. If you need more detail about what is going on in that function, you would need to also apply the function trace to the function's child functions. The function_trace decorator can be used on generators and coroutines with agent version 2.102.0.85 or higher. Timing of these objects begins when consumption starts, and ends when the object is exhausted or goes out of scope. This is a change from earlier versions where the metric represented the time taken to create the generator or coroutine object itself. You can use the decorator in conjunction with existing decorators, including those for static and class methods. When nesting multiple decorators, have the function_trace decorator as the outermost decorator. Important For any decorators that are being wrapped, use functools.wraps() from the Python standard library in their implementation. (Or, otherwise ensure that the decorator propagates the correct name attributes of the innermost wrapped object required to allow correct name introspection.) If this is not done, then when the metric is reported, the name of the nested decorator function (not the innermost wrapped function) will be used. Alternate call forms For setups where you cannot use the decorator, these alternate call forms are available: The context manager The FunctionTrace context manager is used when the parameters to be passed cannot be determined before runtime. (For example, you may not know the name of a function at import time.) When using the context manager to name a metric, you must always supply the name and the metric path prefix. The FunctionTrace class implements the context manager and is used in conjunction with the with statement. The FunctionTrace class is the lowest level primitive available for tracing time against a transaction. The with statement defines the bounds of what is timed and not a single function. Thus, the context manager could be applied to an arbitrary block of code. The block of code could therefore contain calls to multiple functions, or it could be a self-contained block of code implementing a time-oriented algorithm that you want to track. Important Avoid tracing blocks of code that are called an excessive number of times. For example, do not use it within the context of a loop that executes many times. The data generated will incur a performance overhead. A better solution is to enclose the loop. The wrapper If you know in advance where the specific functions you want to trace are, you could use the function_trace decorator. However, if you don't know all the functions that need to be traced (for example, if they're being looked up dynamically as part of a routing system), then you must use the FunctionTraceWrapper to wrap the function at the time of registration or at the time of calling. Path-based wrapping wrap_function_trace is used for wrapping functions outside of the code they're declared in. For example: you might use this to instrument library code that you don't want to modify. For more about the differences between these call formats, see Different call formats. Parameters Parameters for decorator newrelic.agent.function_trace(name=None, group=None, label=None, params=None, terminal=False) Copy This call includes these parameters: Parameter Description name string Optional. The function name. If not set, defaults to the captured name of the function. group string Optional. The group represents the naming structure for the name parameter. This is used in the UI for segregating the transaction types. If not supplied, the group will default to Function in expectation that the name is of the form module:class.function or module:function and represents the name of the function being executed. If you are creating a custom group, it's recommended you prefix it with Python/. label string Optional. Adds a callout-style flag to the segment in a transaction trace. Default is None. params dict Optional. Custom parameters to add to the segment in transaction traces. terminal boolean Optional. If true, no children segments will be recorded. Default is False. Parameters for context manager newrelic.agent.FunctionTrace(name, group=None, label=None, params=None, terminal=False) Copy Parameters for the context manager includes all of the parameters from function_trace. The name parameter is required and not optional. Parameter Description name string Required. The function name. Wrapper parameters newrelic.agent.FunctionTraceWrapper(wrapped, name=None, group=None, label=None, params=None, terminal=False) Copy Parameters for the wrapper include all parameters for function_trace and a wrapped parameter: Parameter Description wrapped function Required. The function being wrapped. Path-based wrapping parameters newrelic.agent.wrap_function_trace(module, object_path, name=None, group=None, label=None, params=None, terminal=False) Copy Parameters include all parameters for function_trace and these parameters: Parameter Description module object Required. The module containing the function to be instrumented. object_path string The path to the location of the function. Examples function_trace example An example of using the function_trace decorator: import newrelic.agent class _Database(UserDict.DictMixin): ... @newrelic.agent.function_trace() def _commit(self): ... @newrelic.agent.function_trace() def open(file, flag=None, mode=0666): ... Copy An example of using the function_trace decorator with native coroutines: import newrelic.agent class _Database(UserDict.DictMixin): ... @newrelic.agent.function_trace() async def _commit(self): ... @newrelic.agent.function_trace() async def open(file, flag=None, mode=0666): ... Copy Context manager example An example of using the FunctionTrace context manager: import newrelic.agent def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() function = getattr(self, 'on_' + endpoint) with newrelic.agent.FunctionTrace( endpoint, 'Python/EndPoint'): return function(request, **values) except HTTPException as e: return e Copy Wrapper example An example of using the FunctionTraceWrapper: URL routing with Werkzeug yields a name that is used first to dynamically look up a method of a class using getattr() and the result then invoked: def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() return getattr(self, 'on_' + endpoint)(request, **values) except HTTPException as e: return e Copy If you want to trace the endpoint function, you can rewrite this as: import newrelic.agent def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() function = getattr(self, 'on_' + endpoint) function = newrelic.agent.FunctionTraceWrapper(function) return function(request, **values) except HTTPException as e: return e Copy If you want to name the metric after the endpoint name (rather than naming the metric based on the identifier for the function being called), you can supply the name to use plus an alternate metric path prefix when the FunctionTraceWrapper object is created. import newrelic.agent def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() function = getattr(self, 'on_' + endpoint) function = newrelic.agent.FunctionTraceWrapper( function, name=endpoint, group='Python/EndPoint') return function(request, **values) except HTTPException as e: return e Copy For this example, if the endpoint were called help, the final metric would be: Python/EndPoint/help Copy In the performance breakdown for a transaction, the category would be Python and the segment name EndPoint/help. That segment name would also appear in slow transaction traces as the node name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 30.34975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the metric represented the time taken to create the generator or coroutine object itself. You can use the decorator in conjunction with existing decorators, including those for <em>static</em> and class <em>methods</em>. When nesting multiple decorators, have the function_trace decorator as the outermost decorator. Important"
      },
      "id": "6044019928ccbc62462c6081"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 305.28076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards API migration: from Insights API to <em>Nerdgraph</em>",
        "sections": "From REST endpoints to GraphQL <em>queries</em>&#x2F;<em>mutations</em>",
        "body": " REST endpoints map to the new GraphQL queries or <em>mutations</em>. List (GET) -&gt; entitySearch <em>query</em> Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "NerdGraph API: Examples | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-03-08T15:31:12Z",
      "updated_at": "2021-03-06T22:12:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 278.3932,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples | New Relic Documentation",
        "sections": "<em>Mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Use NerdGraph to manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "Use NerdGraph to manage license keys and user keys | New Relic Documentation",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-03-08T15:37:26Z",
      "updated_at": "2021-03-02T19:49:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.83923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and user keys | New Relic Documentation",
        "sections": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "tags": "<em>NerdGraph</em>",
        "body": " to let you rotate keys for security purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. Notes about this functionality: All <em>mutations</em> can accept multiple keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    },
    {
      "sections": [
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph cloud integrations API tutorial | New Relic Documentation",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-03-08T15:33:04Z",
      "updated_at": "2021-03-07T01:15:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.5237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations API tutorial | New Relic Documentation",
        "sections": "<em>NerdGraph</em> cloud integrations API tutorial",
        "tags": "<em>NerdGraph</em>",
        "body": "This document provides examples of how to use New Relic <em>NerdGraph</em> to <em>query</em> and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the <em>NerdGraph</em> GraphiQL explorer, you can also <em>query</em> NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph API: NRQL condition alerts",
        "Tip",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Use cursor pagination",
        "Request type-specific fields",
        "Filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions"
      ],
      "title": "NerdGraph API: NRQL condition alerts | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "85399f92d659094c72d6565f258061a0161e751d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts/",
      "published_at": "2021-03-08T15:30:20Z",
      "updated_at": "2021-03-06T22:42:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. Tip The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } Copy NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } Copy NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Copy Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } Copy Tip The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } Copy List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } Copy In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } Copy In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Copy Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Copy Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Copy Update the description This will walk you through the procedure to create a description for a NRQL alert condition. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } Copy Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } Copy Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Copy Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Copy Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.97269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: NRQL condition alerts | New Relic Documentation",
        "sections": "Update <em>mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": "You can manage alerts conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and <em>mutations</em> you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps"
      },
      "id": "60440540196a678165960f6a"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Automate workflows",
      "updated_at": "2021-03-11T01:48:25Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.90219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the <em>Kubernetes</em> <em>operator</em> 20"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Recommended ECS alert conditions",
        "Recommended alert conditions"
      ],
      "title": "Recommended ECS alert conditions | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Integrations",
        "Elastic Container Service integration",
        "Understand use data"
      ],
      "external_id": "334d80a75b3ef0a7b6125bf2a15f643ea46d7282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions/",
      "published_at": "2021-03-08T15:32:58Z",
      "updated_at": "2021-03-02T18:07:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.02032,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em> | New Relic Documentation",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80% for 5 minutes Restart count <em>NRQL</em>: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: &gt; 5 for 5 minutes"
      },
      "id": "603e7eee64441f0f674e889f"
    },
    {
      "sections": [
        "Streaming alerts: key terms and concepts",
        "Tip",
        "Why it matters",
        "Streaming alerts tools",
        "Loss of signal detection",
        "Gap filling",
        "Aggregation window",
        "Offset evaluation"
      ],
      "title": "Streaming alerts: key terms and concepts | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "1e971c3a992c0fed2c73d582fa78ee61dd369cbb",
      "image": "https://docs.newrelic.com/static/ee6e2e7f5d1fd4e68688994872aa6330/59000/streaming_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts/",
      "published_at": "2021-03-08T15:34:09Z",
      "updated_at": "2021-03-07T01:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The streaming alerts platform checks for violations based on data that’s present or missing in the stream of data coming into New Relic. The stream of data that comes into New Relic is called a signal. You can control what part of the signal is alerted on through NRQL conditions. These NRQL condition alerts are processed by the streaming algorithm. The NRQL query provides the signal filter for all of your incoming data. Tip You can read more about the streaming alerts platform in this Explorers Hub post. Why it matters Alerts violations are easy when they're caused by a specific event happening, but trickier when looking for events not happening. Only data that matches the conditions of the NRQL WHERE clause is alerted on. As data streams into New Relic, it's filtered by the NRQL condition. Before data is evaluated, it must meet the criteria defined by the NRQL query's WHERE clause. Instead of evaluating that data immediately for violations, the NRQL alert conditions collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it's processed. Once the aggregation window plus the offset time have elapsed, New Relic groups the aggregated data into a single data point. Alerts then evaluates the data point using the NRQL condition in order to determine whether it meets the violation threshold criteria. Even if a data point meets the criteria for a violation, a violation isn't triggered. A violation is only triggered when data points consistently meet the threshold criteria over a period of time. This is the threshold duration. If the data points are in violation for an entire threshold duration, we'll send you a notification based on your policy settings. All of these configurable delays give you more control over how you're alerted on sporadic and missing data. Streaming alerts tools Streaming alerts provide a set of tools you can use to more effectively alert on your streaming data, giving you greater control and reducing the number of false alerts notifications. They are: Loss of signal detection Gap filling Aggregation window duration customization Offset evaluation Tip This article covers these tools at a conceptual level. You'll find direct instructions on how to use these tools in Create NRQL alert conditions. Loss of signal detection Loss of signal occurs when no data matches the NRQL condition over a specific period of time. A loss of signal is caused by different things. The WHERE clause in your NRQL query can filter out data before it's evaluated for violations. It could also mean a service or entity is offline or a periodic job has failed to run and no data is being sent to New Relic. In order to avoid unnecessary notifications, you can choose how long to wait before you're notified by a loss of signal violation. You can use loss of signal detection to open violations and be notified when a signal is lost. Alternately, you can use a loss of signal to close violations for ephemeral services or sporadic data, such as error counts. Gap filling Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. The default is None. Gaps in streaming data can be caused by network or host issues, a signal may be sparse, or some signals, such as error counts, may only have data when something is wrong. By filling the gaps with known values, the alert evaluation process can process those gaps and determine how they should affect the loss of signal evaluation. Aggregation window In order to make loss of signal detection more effective and to reduce unnecessary notifications, you can customize aggregation windows to the duration that you need. An aggregation window is a specific block of time. We gather data points together in an aggregation window, before using the aggregation function to evaluate the data. A longer aggregation window gives straggling data points more time to arrive before evaluating that data. When a data point arrives, its timestamp is used to put it in the proper aggregation window. You can set your aggregation window to anything between 1 second and 15 minutes. The default is 1 minute. Offset evaluation For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. The offset time value is the number of aggregation windows you want to use. The duration for each window is set in the Aggregation window field. For example, if your aggregation window is 1 minute and your Offset evaluation is 3, then a straggling data point will have about 3 minutes to arrive before it might be dropped. In other words, streaming alerts will always keep 3 aggregation windows in the queue, waiting 1 minute before evaluating each window and adding a new one. The current default is 3.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.25194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Streaming <em>alerts</em>: key terms and concepts | New Relic Documentation",
        "sections": "Streaming <em>alerts</em>: key terms and concepts",
        "tags": "<em>Alerts</em> and Applied Intelligence",
        "body": ". Instead of evaluating that data immediately for violations, the <em>NRQL</em> <em>alert</em> <em>conditions</em> collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it&#x27;s processed. Once the aggregation window plus the offset time have"
      },
      "id": "604427ca28ccbc87142c60a5"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/7ca56bff2292c37f14a7b98e3e919e36/c1b63/new-relic-alerts-baseline-thresholds.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-03-08T15:32:52Z",
      "updated_at": "2021-03-06T22:59:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trend s, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: APM: Application metric baseline Browser: Metric baseline NRQL (and then choose a baseline type threshold) Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.81213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em> | New Relic Documentation",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": " that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for <em>NRQL</em> <em>alert</em> <em>conditions</em>.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    },
    {
      "sections": [
        "View entity health status and find entities without alert conditions",
        "Important",
        "Exceptions",
        "Color-coded health status",
        "Health status transitions",
        "Example: App without conditions",
        "Example: App with conditions",
        "Tip"
      ],
      "title": "View entity health status and find entities without alert conditions | New Relic Documentation",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "50a06dcfd8c44f4e5f5c7b5535ab0472710d3a25",
      "image": "https://docs.newrelic.com/static/e9ca85d8e1b3cf5d1ab549e0a3955990/38cea/032715crop-events-no-v3_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions/",
      "published_at": "2021-03-08T15:30:23Z",
      "updated_at": "2021-03-06T23:12:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With alerts you can easily tell whether an entity (the target for the notification) has one or more conditions associated with it: If yes, its health status indicator on the selected index (APM, Browser, etc.) will be color-coded to the current state. To view a summary of current alert violations, mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. Important To learn more about how conditions and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn't apply for: NRQL alert conditions Infrastructure entities Dashboards Entities targeted by labels Color-coded health status The index automatically appears when you select the product from the New Relic menu bar. For example, to view the index of APM apps, go to one.newrelic.com, then click APM. The Applications index lists all APM product entities and their current health status. Color Health status Green The entity is operational. We are collecting data that you can view in the appropriate UI. No alert violations are currently reported for it. Yellow The entity is degraded. A warning threshold has been violated. Red A critical threshold has been violated: Notifications have been sent based on the selected incident rollup preference. The incident appears in the Incidents index. Gray The entity's status is unknown. We're not receiving alerts data for the entity. This could mean alerts are muted, not set up, or the reporting system is down. Health status transitions The following table describes the different health status transitions an entity can endure: From... To... Transition explanation Gray Green The entity is evaluated for at least one condition, and the results show there are no violations present. Green / Red Gray Possible explanations: The last condition associated to the entity has been deleted and therefore there's no status to report. The last condition associated to the entity has been disabled and therefore there's no status to report. The entity has stopped reporting data. There's a New Relic platform issue. Check the New Relic status page for updates. Green Yellow / Red There's at least one open violation at the time the entity is undergoing the evaluation. Yellow / Red Green The last open violation associated to the entity has been closed. Example: App without conditions Here's an example of an app listed on the APM index that is not associated with any conditions. Its color-coded health status is light grey, which indicates no alert conditions are set up for that entity. Go to one.newrelic.com, then click Entity explorer: This example shows an app that currently isn't associated with any alerts conditions. Its grey status icon means it doesn't have any conditions. Follow standard procedures to add it to an existing condition or to create a new condition for it. Example: App with conditions Here's an example of an app listed on the APM index that is associated with one or more conditions. Its color-coded health status is green, because we are collecting data for it, and currently there are no Warning (yellow) or Critical (red) violations. Go to one.newrelic.com, then click Entity explorer: This example shows an app that has one or more conditions. Its color-coded health status (green) shows the app hasn't reached any threshold violations. Tip To view the index listing currently open incidents across all products, not just this entity, select View all violations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.42896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View entity health status and find entities without <em>alert</em> <em>conditions</em> | New Relic Documentation",
        "sections": "View entity health status and find entities without <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": ", mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. Important To learn more about how <em>conditions</em> and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn&#x27;t apply for: <em>NRQL</em> <em>alert</em>"
      },
      "id": "60440c47e7b9d2c8105799ea"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.03088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.41028,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-03-11T11:44:15Z",
      "updated_at": "2021-03-11T11:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API keys, see REST API keys. https://rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.44134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s REST API <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s REST API <em>Explorer</em>",
        "tags": "API <em>Explorer</em> v2",
        "body": ":&#x2F;&#x2F;rpm.newrelic.com&#x2F;api&#x2F;<em>explore</em>: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "New Relic Global Performance data sets",
        "Important",
        "Access valuable data and try out New Relic",
        "Get started with the Public API Performance dashboard"
      ],
      "title": "New Relic Global Performance data sets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "ed1b2c2cdfb59dae247d2690bd470a93b585c9e8",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/new-relic-global-performance-data-sets/",
      "published_at": "2021-03-11T07:03:43Z",
      "updated_at": "2021-03-11T07:03:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic’s Global Performance data sets, a part of the Telemetry Data Platform, offer immediate access to meaningful, large-scale, aggregated telemetry data. Global Performance data sets data are useful for: Existing New Relic customers who want to gain general monitoring and troubleshooting insights from a curated collection of aggregated, real-world data. Newcomers who want to get a feel for New Relic’s dashboards and data tools and view real data visualizations in order to make informed decisions about how to add their own data to New Relic. This resource provides information about the Global Performance data sets, how they work, what they do, and current options for accessing Global Performance data. Public API Performance dashboard Important Please note: Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Access valuable data and try out New Relic Our first Global Performance data set, Public API Performance, offers a large body of real-world, real-time data about the performance of public APIs including AWS, Google, and more as experienced by New Relic customers (as authorized). Because this data is already flowing through New Relic, you can access it within seconds of activating your account, and test drive New Relic dashboarding and querying capabilities in the process. There’s no need to connect your own data sources to New Relic first, although we recommend you do so because adding your own data is easy, free, and the best way to understand how New Relic can serve your business needs. Get started with the Public API Performance dashboard To help you get started using Public API Performance data, we've created a Public API Performance dashboard. This dashboard provides both actionable general insights and analytics and also an example of how you might apply dashboarding capabilities to your own data. Both new and existing customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see Explore the Public API Performance dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.19258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see <em>Explore</em> the Public API Performance dashboard."
      },
      "id": "60445920196a673eee960f25"
    },
    {
      "sections": [
        "Filter New Relic One dashboards by facets",
        "Why use facet filtering?",
        "Requirements",
        "Example use of facet filtering",
        "Facet linking with the FACET CASES clause"
      ],
      "title": "Filter New Relic One dashboards by facets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "107c9537e64d2568fcba3ec6a717b84684c24a41",
      "image": "https://docs.newrelic.com/static/8190f8c9ef92e92ca0996c32b91b53a5/c1b63/facetfiltering01bis.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/filter-new-relic-one-dashboards-facets/",
      "published_at": "2021-03-11T04:43:59Z",
      "updated_at": "2021-03-11T04:43:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can filter your New Relic One dashboards by faceted attributes, making your dashboards more interactive and easy to use. Why use facet filtering? In New Relic One dashboards, for NRQL queries containing a FACET clause and meeting other chart-type requirements, you can set up the faceted attributes to filter the current dashboard or a related, linked dashboard. By letting you quickly filter your dashboards, and link to pre-filtered dashboards, your dashboards are more interactive and easy to use. This feature is available when adding a new chart to a dashboard or when editing a chart on an existing dashboard. To see this feature in action, see the example use case. Requirements Requirements to use this feature: Must be in New Relic One dashboards. Will not work on a standalone chart in the query builder. NRQL query must contain a FACET clause. Available only for bar charts, heat maps, pie charts, and tables. Example use of facet filtering Let's say you create the following facet-containing NRQL query for an existing dashboard in New Relic One: one.newrelic.com > Dashboards: For queries containing a FACET clause and meeting chart-type requirements, you can set those attributes to be used as an easy dashboard filter. You can set the attribute to filter the current dashboard you're on, or filter a related dashboard that you select. If you select Filter the current dashboard, that chart will be used to filter the current dashboard by the available userAgentName attributes. Here's a view of selecting one of those attributes to filter that dashboard. Notice that the chosen attribute appears as a filter in the search bar at the top. one.newrelic.com > Dashboards: When you select an attribute you've set up for facet filtering, it filters the current dashboard. For more about this feature, see the Explorers Hub post on facet filtering. Facet linking with the FACET CASES clause FACET CASES is a NRQL function that allows to group facets based on conditions. We support multiple cases in the same facet. For example, let's say you query your applications, but you don't know which have been migrated to cloud and which haven't. SELECT filter(count(*), WHERE duration > 1) as 'On-premises', filter(count(*), WHERE duration < .06) as 'AWS' FROM Transaction WHERE appName NOT LIKE '%Tower%' FACET appName LIMIT 5 since 5 minutes ago Copy By using FACET cases, you can add the condition and obtain the status of the migration: SELECT count(*) FROM Transaction WHERE appName NOT LIKE '%Tower%' facet cases(WHERE appName = 'WebPortal' OR appName = 'Plan Service' as '% of Hosts On-Prem', WHERE appName != 'WebPortal' AND appName != 'Plan Service' as '% of Hosts in Cloud') since 10 minutes ago limit 100 Copy Then, using facet linking, you can filter your dashboards by those facets.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.5903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "60445d1e28ccbc23082c60af"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 370.28534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "5efa999d196a67300c766404"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-02-06T01:55:17Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostModules directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_channel\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your module.tf and provider.tf to the stage for commit: bash Copy $ git add module.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.15424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "601df70628ccbce8510133b6"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.9245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "601df6bb196a67eb59da2d81"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-03-11T03:15:01Z",
      "updated_at": "2021-03-11T03:15:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If this is a sub-account, the list shows only the sub-account users, not all the users in the master account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.59953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View or update user email <em>channels</em>",
        "sections": "View or update user email <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "&#x27;s <em>notification</em> <em>channel</em>. To add or update account users as <em>notification</em> channels for a policy: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click Policies, and then choose the policy you want to change. Optional: You can update <em>notification</em> channels for specific users. On the <em>Notification</em>"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules"
      ],
      "published_at": "2021-03-12T01:49:20Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.05075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.03299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.03088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-03-11T11:44:15Z",
      "updated_at": "2021-03-11T11:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API keys, see REST API keys. https://rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.44134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s REST API <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s REST API <em>Explorer</em>",
        "tags": "API <em>Explorer</em> v2",
        "body": ":&#x2F;&#x2F;rpm.newrelic.com&#x2F;api&#x2F;<em>explore</em>: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "New Relic Global Performance data sets",
        "Important",
        "Access valuable data and try out New Relic",
        "Get started with the Public API Performance dashboard"
      ],
      "title": "New Relic Global Performance data sets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "ed1b2c2cdfb59dae247d2690bd470a93b585c9e8",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/new-relic-global-performance-data-sets/",
      "published_at": "2021-03-11T07:03:43Z",
      "updated_at": "2021-03-11T07:03:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic’s Global Performance data sets, a part of the Telemetry Data Platform, offer immediate access to meaningful, large-scale, aggregated telemetry data. Global Performance data sets data are useful for: Existing New Relic customers who want to gain general monitoring and troubleshooting insights from a curated collection of aggregated, real-world data. Newcomers who want to get a feel for New Relic’s dashboards and data tools and view real data visualizations in order to make informed decisions about how to add their own data to New Relic. This resource provides information about the Global Performance data sets, how they work, what they do, and current options for accessing Global Performance data. Public API Performance dashboard Important Please note: Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Access valuable data and try out New Relic Our first Global Performance data set, Public API Performance, offers a large body of real-world, real-time data about the performance of public APIs including AWS, Google, and more as experienced by New Relic customers (as authorized). Because this data is already flowing through New Relic, you can access it within seconds of activating your account, and test drive New Relic dashboarding and querying capabilities in the process. There’s no need to connect your own data sources to New Relic first, although we recommend you do so because adding your own data is easy, free, and the best way to understand how New Relic can serve your business needs. Get started with the Public API Performance dashboard To help you get started using Public API Performance data, we've created a Public API Performance dashboard. This dashboard provides both actionable general insights and analytics and also an example of how you might apply dashboarding capabilities to your own data. Both new and existing customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see Explore the Public API Performance dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.19258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data",
        "body": " customers should be able to view Global Performance data in the Public API Performance dashboard quickly and easliy. To start using this dashboard, see <em>Explore</em> the Public API Performance dashboard."
      },
      "id": "60445920196a673eee960f25"
    },
    {
      "sections": [
        "Filter New Relic One dashboards by facets",
        "Why use facet filtering?",
        "Requirements",
        "Example use of facet filtering",
        "Facet linking with the FACET CASES clause"
      ],
      "title": "Filter New Relic One dashboards by facets",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "107c9537e64d2568fcba3ec6a717b84684c24a41",
      "image": "https://docs.newrelic.com/static/8190f8c9ef92e92ca0996c32b91b53a5/c1b63/facetfiltering01bis.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/filter-new-relic-one-dashboards-facets/",
      "published_at": "2021-03-11T04:43:59Z",
      "updated_at": "2021-03-11T04:43:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can filter your New Relic One dashboards by faceted attributes, making your dashboards more interactive and easy to use. Why use facet filtering? In New Relic One dashboards, for NRQL queries containing a FACET clause and meeting other chart-type requirements, you can set up the faceted attributes to filter the current dashboard or a related, linked dashboard. By letting you quickly filter your dashboards, and link to pre-filtered dashboards, your dashboards are more interactive and easy to use. This feature is available when adding a new chart to a dashboard or when editing a chart on an existing dashboard. To see this feature in action, see the example use case. Requirements Requirements to use this feature: Must be in New Relic One dashboards. Will not work on a standalone chart in the query builder. NRQL query must contain a FACET clause. Available only for bar charts, heat maps, pie charts, and tables. Example use of facet filtering Let's say you create the following facet-containing NRQL query for an existing dashboard in New Relic One: one.newrelic.com > Dashboards: For queries containing a FACET clause and meeting chart-type requirements, you can set those attributes to be used as an easy dashboard filter. You can set the attribute to filter the current dashboard you're on, or filter a related dashboard that you select. If you select Filter the current dashboard, that chart will be used to filter the current dashboard by the available userAgentName attributes. Here's a view of selecting one of those attributes to filter that dashboard. Notice that the chosen attribute appears as a filter in the search bar at the top. one.newrelic.com > Dashboards: When you select an attribute you've set up for facet filtering, it filters the current dashboard. For more about this feature, see the Explorers Hub post on facet filtering. Facet linking with the FACET CASES clause FACET CASES is a NRQL function that allows to group facets based on conditions. We support multiple cases in the same facet. For example, let's say you query your applications, but you don't know which have been migrated to cloud and which haven't. SELECT filter(count(*), WHERE duration > 1) as 'On-premises', filter(count(*), WHERE duration < .06) as 'AWS' FROM Transaction WHERE appName NOT LIKE '%Tower%' FACET appName LIMIT 5 since 5 minutes ago Copy By using FACET cases, you can add the condition and obtain the status of the migration: SELECT count(*) FROM Transaction WHERE appName NOT LIKE '%Tower%' facet cases(WHERE appName = 'WebPortal' OR appName = 'Plan Service' as '% of Hosts On-Prem', WHERE appName != 'WebPortal' AND appName != 'Plan Service' as '% of Hosts in Cloud') since 10 minutes ago limit 100 Copy Then, using facet linking, you can filter your dashboards by those facets.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.5903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "60445d1e28ccbc23082c60af"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-03-12T01:46:23Z",
      "updated_at": "2020-12-04T01:59:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.92654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "!&quot; application The <em>CLI</em> allows you to run a local version of <em>New</em> <em>Relic</em> <em>One</em>. You can develop your application locally before you publish it in <em>New</em> <em>Relic</em> <em>One</em>. If you followed all the steps in the <em>CLI</em> quick start, you now have files under a <em>new</em> directory named after your <em>nerdpack</em> project. Here&#x27;s how you edit"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Build a custom visualization for dashboards",
        "Before you begin",
        "Create a new visualization",
        "Render the visualization in local development",
        "Important",
        "Advanced nerdpack configuration",
        "Deploy and use your visualization",
        "Summary"
      ],
      "title": "Build a custom visualization for dashboards",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "5e17f1f0db2020342ced37e95dbcb94489b5ca73",
      "image": "https://developer.newrelic.com/static/cf9bafc3fc03f7562e4f969cafcd7659/30c01/visualization-apps-navigation.png",
      "url": "https://developer.newrelic.com/build-apps/build-visualization/",
      "published_at": "2021-03-12T01:47:31Z",
      "updated_at": "2021-02-27T01:48:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create custom data views",
      "body": "Building your own visualizations for New Relic dashboards enables you and your organization to query data from any source and display it on your dashboard. In this guide, you'll learn how to use the CLI to generate a visualization file structure, run it locally where you can quickly test and iterate, and then deploy it for use in a dashboard. Before you begin To get started, make sure you have a New Relic account. To complete this guide, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. Create a new visualization In this first set of steps you will use the CLI to quickly generate the boilerplate for a new visualization. Step 1 of 3 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 3 Start with a new Nerdpack. If you just installed the New Relic One CLI, then you have a new Nerdpack project directory (called something like my-awesome-nerdpack). If you need to create one, run nr1 create and select the nerdpack option. bash Copy $ nr1 create --type nerdpack --name my-awesome-nerdpack Step 3 of 3 Navigate to the root of your Nerdpack project and run the nr1 create command, selecting the visualization option. bash Copy $ cd my-awesome-nerdpack $ nr1 create --type visualization --name my-awesome-visualization As a result, you have a new visualization directory matching the name you gave your visualization. It is located in the visualizations directory in the root of your Nerdpack project. The files created provide an example visualization – a radar chart populated by a basic NRQL query. The nr1.json file provides metadata. The configuration key in this metadata defines the prop-input fields to be shown in the UI. These are the fields users will fill in to create an instance of the visualization. Supported input types are: boolean string number json nrql: a single NRQL query string. namespace: a group of input fields to be displayed together under a shared heading in the prop-editing UI. collection: a repeatable group of input fields to be displayed together under a shared heading in the prop-editing UI. The nrqlQueries entry is an example of a collection type. The index.js file is where you define the React component that receives the props and renders the visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. If your visualization queries data over a time range and you want it to utilize the platform time range setting, you will need to utilize the timeRange value from PlatformStateContext. The timeRange can be passed directly to the NrqlQuery component. Setting the NrqlQuery component's pollInterval prop to NrqlQuery.AUTO_POLL_INTERVAL automatically handles calculating an appriate data polling interval. <PlatformStateContext.Consumer> {({timeRange}) => ( <NrqlQuery timeRange={timeRange} pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} > ... Copy Render the visualization in local development Now run the generated visualization locally, and view it in Custom Visualizations. There you can quickly test changes to your code. Step 1 of 7 Start the local Node server for your Nerdpack. bash Copy $ nr1 nerdpack:serve Important To see changes to the nr1.json file take effect, restart the local Node server. Changes to the definition of the configuration field will not show up in the prop configuration side bar of the Custom Visualizations UI until you stop the local Node server and start it back up. Step 2 of 7 In a browser, open https://one.newrelic.com/?nerdpacks=local. This url is also shown in the terminal when the Node server starts. The nerdpacks=local query string will direct the UI to load your new visualization artifact from the local Node server. Advanced nerdpack configuration See the advanced nerdpack configuration section for detailed information about how your local Node server is proxied to the browser and how you can override webpack configuration if needed. Step 3 of 7 Open the Apps page, and navigate to Custom Visualizations, which you will find favorited by default. Step 4 of 7 In the Custom Visualizations listing, find and click on the tile for your visualization. If the tile is not showing up or it is not indicating that it is running locally, restart the Node server and refresh the browser. When you select your locally running visualization, the visualization hosted by your local Node server is rendered with prop-configuration inputs. Here you can take advantage of the features outlined in the following steps. Step 5 of 7 You can set prop values and see the visualization update automatically. The prop inputs are listed as defined in the prop definitions located in the nr1.json file in the visualization folder (for example ./visualizations/my-awesome-visualization/nr1.json). Fill in values for the props and see the visualization update automatically. As you change props in the sidebar, a render cycle of your visualization's React component is triggered. Step 6 of 7 Modify the visualization's Javascript code and see the result automatically update in the UI. For example, you can change the value for fillOpacity on the Radar component in index.js. Upon save, you will see the page automatically update. fillOpacity={1.0} visualizations/your-visualization/index.js Copy Step 7 of 7 To add more props, you must update the configuration field in the nr1.json file for your visualization and restart the local Node server. The props you define in the configuration field allow New Relic One to cleanly display a prop-editing UI for users interacting with your visualization. See above for more information about the configuration field. Deploy and use your visualization When your visualization is ready to be added to a dashboard, just follow these steps. Step 1 of 2 Open and follow the guide to publish and deploy the Nerdpack to New Relic One and subscribe accounts to it. Step 2 of 2 Then you can add your visualization to a dashboard. Summary Congratulations on completing the steps in this example! You've learned how to: Create a visualization and run it locally Quickly test and iterate on visualization code changes in Custom Visualizations Deploy a visualization Add a custom visualization to a dashboard",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 363.90894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a <em>new</em> visualization",
        "tags": "nr1 <em>cli</em>",
        "body": "Building your own visualizations for <em>New</em> <em>Relic</em> dashboards enables you and your organization to query data from any source and display it on your dashboard. In this guide, you&#x27;ll learn how to use the <em>CLI</em> to generate a visualization <em>file</em> <em>structure</em>, run it locally where you can quickly test"
      },
      "id": "6039a4dbe7b9d262492a07c4"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Undeploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2021-03-12T01:47:32Z",
      "updated_at": "2021-02-27T01:54:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Undeploy your app You can also manually undeploy an app. Undeploying an app is detaching a Nerdpack version from a specific channel. Before undeploying, you need to unsubscribe your account from the deployed Nerdpack, then specify the UUID of the Nerdpack you've unsubscribed as the one to undeploy. Step 1 of 3 To get a list of deployed Nerdpacks that your account is subscribed to, run nr1 subscription:list. Step 2 of 3 Copy the UUID of the Nerdpack that you want to unsubscribe and pass it to the nerdpack-id option of the unsubscribe command: nr1 nerdpack:unsubscribe --nerdpack-id=<UUID> Copy You should get a result like this: Unsubscribed account <your account ID> from the nerdpack <Nerdpack UUID>. Step 3 of 3 Unsubscribe the Nerdpack UUID used in step 2: nr1 nerdpack:undeploy --nerdpack-id=<UUID> -t STABLE Copy You should get the result Undeployed nerdpack <Nerdpack UUID> from the STABLE channel. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.9954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": " This guide requires the following: A <em>New</em> <em>Relic</em> <em>One</em> app or <em>Nerdpack</em> <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> A <em>Nerdpack</em> manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to <em>New</em> <em>Relic</em> <em>One</em> to test it out. Step 1 of 1 In the parent root folder of your"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-03-12T01:47:32Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 327.72998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": ". At the end of the Quick start, you have a project consisting of the following: A <em>Nerdpack</em> - The package containing all the files required by your application. It contains two types of files that you customize to build your app: <em>Nerdlets</em>, and the <em>launcher</em>. <em>One</em> or more <em>Nerdlet</em> files - A specific UI view"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you’re looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 μs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is “loading” its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.92438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>New</em> <em>Relic</em> data",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "In your application, you can display data in charts, like those used elsewhere in <em>New</em> <em>Relic</em>&#x27;s user interface. The <em>New</em> <em>Relic</em> <em>One</em> SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from <em>New</em> <em>Relic</em> or some other source, you supply"
      },
      "id": "5fdab9f1e7b9d2e1e8df9221"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.87677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em>’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built <em>new</em> features for dashboards: All <em>New</em> <em>Relic</em> <em>One</em> dashboards"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.87677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in <em>New</em> <em>Relic</em> <em>One</em>. For more details about this migration and how you can easily plan for this transition, see"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 239.893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Explorer: View performance across apps, services, hosts",
        "Tip",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Important",
        "Filter entities using the filterbar",
        "Entity data retention"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e1029a5f385863d0feffa2a6ebedcc417bbc9fbf",
      "image": "https://docs.newrelic.com/static/418c556bcaa53ce2b71a5b5fdfee88d8/be86f/new-relic-one-entity-alert-status-red.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/",
      "published_at": "2021-03-09T03:40:22Z",
      "updated_at": "2021-03-09T03:40:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it’s more than just observing the metrics: understand the root of what’s happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system’s doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. Want to learn more? See the video (it's only 45 seconds!): Short guide to using the New Relic Explorer. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don’t need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic’s profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. Tip You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Important Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Tip Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn’t return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.70325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "sections": "<em>New</em> <em>Relic</em> Explorer: View performance across <em>apps</em>, services, hosts",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. Tip To use <em>New</em> <em>Relic</em> <em>One</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account"
      },
      "id": "603ec1f928ccbca50ceba7b6"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.53809,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Build a custom visualization for dashboards",
        "Add a table to your app",
        "Permissions for managing applications",
        "Create a custom map view",
        "Publish and deploy apps",
        "Set up your development environment"
      ],
      "published_at": "2021-03-12T01:46:22Z",
      "title": "Build apps",
      "updated_at": "2021-03-11T01:51:44Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Build a custom visualization for dashboards 15 min Create custom data views Add a table to your app 30 min Add a table to your New Relic One app Permissions for managing applications   Learn about permissions for subscribing to apps Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 774.9171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the <em>NerdGraphQuery</em> <em>component</em> to an application 20 minutes The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Drop data using NerdGraph",
        "Requirements",
        "Create drop data rule",
        "Caution",
        "NRQL restrictions",
        "Example drop rules",
        "Drop two event types",
        "Drop events meeting certain criteria",
        "Drop sensitive attributes while maintaining the rest of the data",
        "Verify your drop rule works",
        "View rules",
        "Delete drop rules",
        "Audit drop rule history",
        "Cautions when dropping data",
        "Learn more"
      ],
      "title": "Drop data using NerdGraph",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "4f58e64a7fa1922c4d794a3f64808819931af4c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/data-management/drop-data-using-nerdgraph/",
      "published_at": "2021-03-11T01:16:35Z",
      "updated_at": "2021-03-11T01:16:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of data in New Relic, you can drop (not report) that data. You might want to do this: To filter out unimportant, low-value data To filter out potentially sensitive data If you choose to drop data, only new data will be affected. Existing data cannot be edited or deleted. Requirements You must have a user role with permissions for dropping data. Currently the following types of data can be targeted for data dropping: APM-reported events Browser-reported events Mobile-reported events Synthetics-reported events Custom events (like those generated by the APM agent APIs or the Event API) Log data Trace spans Dimensional metrics, with these caveats: Billing impacts: for New Relic One pricing, dropped data is not billable. For original pricing, dropped data is billable. For metrics generated by the events-to-metrics service: drop rules won't work but these metrics can be stopped or attributes pruned by disabling or re-configuring the events-to-metric rule. Support for additional types are planned for the future. Create drop data rule Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, please review caution information below. To drop data, create a NerdGraph-format drop rule that includes: A NRQL string that specifies what data types to drop An action type specifying how to apply the NRQL string You can form and make the call in the NerdGraph explorer. There are two ways to drop data: Drop entire data types or a data subset (with optional filter). This uses the DROP_DATA action type and uses NRQL of the form: SELECT * FROM DATA_TYPE_1, DATA_TYPE_2 (WHERE OPTIONAL_FILTER) Copy For this type of drop rule, you cannot use anything other than * in the SELECT clause. Drop attributes from data types (with optional filter). This uses the DROP_ATTRIBUTES action type and uses NRQL of the form: SELECT dropAttr1, dropAttr2 FROM DATA_TYPE (WHERE OPTIONAL_FILTER) Copy For this type of drop rule, you must pass in a non-empty list of raw attributes names. NRQL restrictions Not all NRQL clauses make sense for generating drop rules. You can provide a WHERE clause to select data with specific attributes. Other features such as TIMESERIES, COMPARE WITH, FACET, and other clauses cannot be used. The two action types have these restrictions: DROP_DATA can use only SELECT *. DROP_ATTRIBUTES requires use of SELECT with \"raw\" attributes (attributes with no aggregator function applied). This also means you cannot use SELECT *. Additionally, there are some attributes that are integral to their data type and cannot be dropped (such as timestamp on event data). If you include them, registration will fail. Example drop rules Here are some example drop rules: Drop two event types Let's say you notice you have some event types being sent to New Relic that are not important to you. Also, stopping the source from sending those event types quickly is unrealistic, requiring changes to agents and/or API instrumentation. Using a drop rule is an easier way to accomplish the same goal. Here is an example NerdGraph call that drops two event types: Event1 and Event2. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM Event1, Event2\" description: \"Drops all data for Event1 and Event2.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Copy Drop events meeting certain criteria Let’s say you have a high volume custom event type that arrives from multiple sources. If you don't find all of that data important, you can use a drop rule. Here is an example of a drop rule that filters out events based on specific criteria. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM MyCustomEvent WHERE appName='LoadGeneratingApp' AND environment='development'\" description: \"Drops all data for MyCustomEvent that comes from the LoadGeneratingApp in the dev environment, because there is too much and we don’t look at it.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Copy Drop sensitive attributes while maintaining the rest of the data Let's say you noticed an event has attributes that contain Personally Identifiable Information (PII). You are working to update your services to stop sending the data, but until then, you need to cease storing further PII in New Relic. Although you could drop all of the data as it comes in the door with a DROP_DATA rule, the rest of the data still provides value. Therefore, you can register a drop rule to remove only the offending PII from your data: mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_ATTRIBUTES nrql: \"SELECT userEmail, userName FROM MyCustomEvent description: \"Removes the user name and email fields from MyCustomEvent\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Copy Verify your drop rule works After you create a drop rule, verify that it is working as expected. The rule should take effect quickly after a successful registration, so try running a TIMESERIES version of the query you registered to see that the data drops off. Drop rule type NRQL DROP_DATA Drop rule NRQL: SELECT * FROM MyEvent WHERE foo = bar Copy Validation NRQL: SELECT count(*) FROM MyEvent WHERE foo = bar TIMESERIES Copy This should drop to 0. To verify that it did not affect any thing else, invert the WHERE clause. DROP_ATTRIBUTES Drop rule NRQL: SELECT dropAttr1, dropAttr2 FROM MyEvent WHERE foo = bar Copy Validation NRQL: SELECT count(dropAttr1), count(dropAttr2) FROM MyEvent WHERE foo = bar TIMESERIES Copy Both lines should drop to 0. To verify that it did not affect events that contained these attributes and still should, invert the WHERE clause. View rules Here is an example NerdGraph call that returns the drop rules set on an account: { actor { account(id: YOUR_ACCOUNT_ID) { nrqlDropRules { list { rules { id nrql accountId action createdBy createdAt description } error { reason description } } } } } } Copy Delete drop rules Here is an example NerdGraph call deleting two specific drop rules: mutation { nrqlDropRulesDelete(accountId: YOUR_ACCOUNT_ID, ruleIds: [\"48\", \"98\"]) { successes { id nrql accountId action description } failures { error { reason description } submitted { ruleId accountId } } } } Copy Audit drop rule history To see who created and deleted drop rules, query your account audit logs. The list endpoint also includes the user ID of the person who created the rule. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Only new data will be dropped. Existing data cannot be edited or deleted. Learn more Recommendations for learning more: NerdGraph basics and terminology NRQL basics Browse the Explorers Hub for community discussions about NRQL drop rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 536.49774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Drop</em> <em>data</em> using <em>NerdGraph</em>",
        "sections": "<em>Drop</em> <em>data</em> using <em>NerdGraph</em>",
        "tags": "Telemetry <em>Data</em> Platform",
        "body": " instrumentation. Using a <em>drop</em> rule is an easier way to accomplish the same goal. Here is an example <em>NerdGraph</em> call that drops two event types: Event1 and Event2. mutation { nrql<em>Drop</em>RulesCreate(<em>account</em>Id: YOUR_<em>ACCOUNT</em>_ID, rules: [ { action: <em>DROP_DATA</em> nrql: &quot;SELECT * FROM Event1, Event2&quot; description: &quot;Drops all"
      },
      "id": "6043f34228ccbc36212c60bb"
    },
    {
      "sections": [
        "NerdGraph NRQL tutorial",
        "Basic NRQL queries with NerdGraph",
        "Create embeddable charts",
        "Suggested facets",
        "Rules governing suggested facets",
        "Example of returning suggested attributes"
      ],
      "title": "NerdGraph NRQL tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b56b0e93848c3830a3d0767278e844700c958531",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-nrql-tutorial/",
      "published_at": "2021-03-11T11:44:16Z",
      "updated_at": "2021-03-11T11:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic NerdGraph GraphiQL explorer to make New Relic Query Language (NRQL) queries. To learn how to construct these queries and see responses, go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. This document explains some of the available functions for NRQL queries. Basic NRQL queries with NerdGraph To make NRQL queries using NerdGraph: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Pass the NRQL query as a string argument to the NRQL object, and include the results field in your NerdGraph query. For example, to get a count of all transaction events in the last hour, use the following query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This NerdGraph query example returns the following results: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your transaction data. Use the NerdGraph GraphiQL explorer to experiment with queries. Create embeddable charts In addition to returning raw data, you can fetch embeddable chart links for the data to use in an application. For example, instead of a single count of transaction, you can create a chart that illustrates a timeseries of bucketed counts over time. Add TIMESERIES to your query with embeddedChartUrl: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) from Transaction TIMESERIES\") { embeddedChartUrl } } } } Copy This NerdGraph query example returns the URL for the chart in the following response: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \" embeddedChartUrl \": \"https://chart-embed.service.newrelic.com/charts/EMBEDDABLE-CHART-ID\" } } } } } Copy If you view the embedded chart URL using any standard HTTP client, it returns an image showing a visualization of the response to the query you submitted. These charts follow the same embedded chart rules as embedded charts that are created elsewhere. To change the style of the data visualization, pass a chartType argument to embeddedChartUrl. Suggested facets When using NerdGraph to explore your data, you can use the suggestedFacets field to return suggested attributes for use in faceted NRQL queries. Rules governing suggested facets Here are some of the rules that govern what attributes are suggested: Built-in suggestions. Each event type comes with its own set of recommended attributes. These are attributes chosen by New Relic for their importance and popularity. Usage-based suggestions. Some attribute suggestions are based on the queries that have been frequently used by your account. These suggestions can include custom attributes. Role restriction. Restricted users do not have access to account-related facet suggestions. To disable the use of account data for determining suggested queries, contact Support. Example of returning suggested attributes Here's an example of returning suggested attributes for faceting transaction counts. The response suggests the host attribute. Faceting by host can reveal that one host is servicing more requests than other hosts. { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) from Transaction TIMESERIES\") { suggestedFacets { attributes } } } } } Copy This NerdGraph query example returns a response similar to this: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \" suggestedFacets \": [ \"attributes\": [\"host\"] ] } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 523.52966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> NRQL tutorial",
        "sections": "Basic NRQL <em>queries</em> with <em>NerdGraph</em>",
        "tags": "<em>NerdGraph</em>",
        "body": " a count of all <em>transaction</em> events in the last hour, use the following <em>query</em>: { actor { <em>account</em>(id: YOUR_<em>ACCOUNT</em>_ID) { nrql(<em>query</em>: &quot;SELECT count(*) FROM <em>Transaction</em> SINCE 1 HOUR AGO&quot;) { results } } } } Copy This <em>NerdGraph</em> <em>query</em> example returns the following results: { &quot;<em>data</em>&quot;: { &quot;actor&quot;: { &quot;<em>account</em>"
      },
      "id": "6044058c196a67976b960f3d"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph",
        "Tip",
        "Use the NerdGraph GraphiQL explorer",
        "Requirements and endpoints",
        "NerdGraph tutorials and examples",
        "NerdGraph terminology",
        "Make queries with the explorer",
        "Query account a New Relic user can access",
        "Query user, account, and NRQL in one NerdGraph GraphiQL request"
      ],
      "title": "Introduction to New Relic NerdGraph",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-03-11T03:15:01Z",
      "updated_at": "2021-03-11T03:15:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is New Relic's GraphQL-format API. Our NerdGraph is an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. Tip To use NerdGraph and APIs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use the NerdGraph GraphiQL explorer We have a GraphiQL explorer that lets you explore our schema, find definitions, and form calls. To use the explorer: You'll need a New Relic user key. Go to api.newrelic.com/graphiql (if you have New Relic data in EU, use api.eu.newrelic.com/graphiql) Requirements and endpoints To use NerdGraph, you need a New Relic user key. NerdGraph endpoints: Main endpoint: https://api.newrelic.com/graphql EU endpoint: For accounts with data in EU data center, use https://api.eu.newrelic.com/graphql. To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy NerdGraph tutorials and examples You can use NerdGraph to: Functionality Tutorials Query all the entities associated with your account. See the entities tutorial. Query, create, and update workloads associated with your account. See the workloads tutorial. Create, manage, and add tags to entities. For more information and examples, see the tagging tutorial. Query distributed tracing data. See the trace data tutorial. Fetch data when building a New Relic One app. See New Relic One app data querying and mutations. Understand upstream and downstream relationships with your services. See the relationships tutorial. Configure your New Relic cloud integrations. See cloud integration examples. Query event data using NRQL. See the NRQL tutorial. Watch video tutorials about NerdGraph. Go to the New Relic University tutorial Intro to New Relic NerdGraph. Or, go to the full online course New Relic APIs. NerdGraph terminology The New Relic GraphQL server explicitly defines the graph structure of NerdGraph. The following keywords are common to all GraphQL servers. Use these keywords to help build and understand your own queries. In addition: To understand how NerdGraph provides unified access to all the things you monitor with New Relic, see NerdGraph entities. To understand schema definitions: From the NerdGraph GraphiQL explorer, select Docs. Term Definition Queries Queries are basic requests that are intended to only fetch data, without any additional actions. Queries in the NerdGraph GraphiQL explorer are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations Mutations are requests that are intended to have additional actions, such as creating data or updating data on a server. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Make queries with the explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. In GraphQL, you ask for specific information in the graph structure of New Relic's data. You can follow the nodes of the graph to query exactly the data that you want. New fields are added seamlessly, and old fields can be marked as deprecated, which removes them from documentation and allows an eventual, graceful shutdown of that field. Query account a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one NerdGraph GraphiQL request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 486.77405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>",
        "sections": "<em>Query</em> user, <em>account</em>, and NRQL in one <em>NerdGraph</em> <em>GraphiQL</em> request",
        "tags": "<em>NerdGraph</em>",
        "body": " that you want. { &quot;<em>data</em>&quot;: { &quot;actor&quot;: { &quot;<em>account</em>&quot;: { &quot;name&quot;: &quot;<em>Data</em> <em>Nerd</em>&quot; } } } } Copy <em>Query</em> user, <em>account</em>, and NRQL in one <em>NerdGraph</em> GraphiQL request The <em>graph</em> structure shows its capabilities when queries become more complex. For example, you can <em>query</em> for user information, <em>account</em> information, and make"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2021-03-12T01:46:23Z",
      "updated_at": "2021-03-05T01:46:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ✔ Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ✔ PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ✔ pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ✔ pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! ★ Starting as orchestrator... ✔ Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js import React from 'react'; import { TableChart, TextField, NerdGraphQuery, Spinner, Button, BlockText, } from 'nr1'; import { Map, CircleMarker, TileLayer } from 'react-leaflet'; const accountId = 0; // Replace with your account ID export default class PageViewApp extends React.Component { constructor(props) { super(props); this.state = { countryCode: null, }; } getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } } mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } LIMIT 1000 \") { results nrql } } } }`; return query; } render() { const { countryCode } = this.state; const defaultMapCenter = [10.5731, -7.5898]; return ( <div className=\"container\"> <div className=\"row\"> <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div> <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl > <TileLayer attribution='&copy OpenStreetMap contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); }} </NerdGraphQuery> </div> <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" /> </div> </div> ); } } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 473.39966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by region in a custom <em>app</em>",
        "sections": "<em>Query</em> your browser <em>data</em>",
        "info": "Build a New Relic <em>app</em> showing page view <em>data</em> on a world map.",
        "tags": "custom <em>app</em>",
        "body": "-webpackrc.js import React from &#x27;react&#x27;; import { TableChart, TextField, <em>NerdGraphQuery</em>, Spinner, Button, BlockText, } from &#x27;nr1&#x27;; import { Map, CircleMarker, TileLayer } from &#x27;react-leaflet&#x27;; const <em>account</em>Id = 0; &#x2F;&#x2F; Replace with your <em>account</em> ID export default class PageView<em>App</em> extends React.<em>Component</em>"
      },
      "id": "5efa993c196a67066b766469"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-03-11T00:18:44Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 803.2923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/",
      "sections": [
        "What's new in New Relic"
      ],
      "published_at": "2021-03-12T01:57:59Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-03-12T01:57:59Z",
      "type": "docs",
      "external_id": "49467ca3d09d7a4f1c1c69fd16be4e20050a7686",
      "popularity": 1,
      "body": "March 11 Nerdlog Weekly Roundup: Monitor 1,000 hosts at once with New Relic’s Explorer’s Navigator and Related Entities Get hundreds of entities in a compact, high-level view March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free March 9 Nerdlog weekly roundup: AIOps and Custom Data Visualizations Smarter incident intelligence with AIOps and custom data visualizations February 25 Nerdlog weekly roundup Everything you need to know about OpenTelemetry, Real User Monitoring, Data Dropping, Logs, and more February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog featured weekly releases Check out our new ServiceNow and Snowflake Integrations, and how to visualize k6 performance data in New Relic. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 447.29706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "body": " automatically deliver anomaly charts. October 14, 2020 <em>New</em> <em>Relic</em> <em>One</em> now has a <em>new</em> UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry <em>data</em>. October 13, 2020 Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em> Store and receive sensitive third-party secrets <em>data</em>. October"
      },
      "id": "60422917196a677e2fa83ddf"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.56042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights&#x27; 3-across limit Easier creation of dashboards with multiple pages (previously called <em>data</em> <em>apps</em> in Insights). Your Insights <em>data</em> <em>apps</em> are preserved as multi-page dashboards in <em>New</em> <em>Relic</em> <em>One</em>. Improved"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.42917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.1566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Why a <em>new</em> dashboards API?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and understandable description of the APIs&#x27; <em>data</em>. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the <em>new</em> <em>New</em> <em>Relic</em> <em>One</em> dashboards API. Find below some examples that illustrate how the old"
      },
      "id": "60441442e7b9d2020b5799b9"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-03-11T07:31:53Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.89096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>View</em> performance data by <em>region</em>",
        "body": " performance and historical performance. Contents <em>View</em> performance data by <em>region</em> Important Firewalls may have an impact on the geographical data collected about your end users. To <em>view</em> or sort the performance information by location: one.newrelic.com &gt; Browser &gt; (select an <em>app</em>) &gt; Geo: This <em>page</em>"
      },
      "id": "604429e7196a67193d960f75"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/p03-product-image/browser/products_browsers_features_browserloadtime_sept2020_thumb.png",
      "url": "https://newrelic.com/products/browser-monitoring/features",
      "sections": [
        "New Relic Browser features",
        "Full Support for Google’s Core Web Vitals",
        "User Centric Perceived Performance",
        "Single Page App Route Changes",
        "Session Traces",
        "Browser Traces",
        "Page Load Time - Segmentation Chart",
        "Page Load Time - Histogram and Percentiles",
        "Geographic Reporting",
        "Page-Level AJAX Calls",
        "Page View Throughput",
        "Connect Browser with Backend Performance",
        "JavaScript Error Summary",
        "Errors by Browser",
        "Percentage of Page Views with Errors",
        "Source Map Support",
        "Best-in-class Customer Experience Monitoring",
        "Browser Throughput",
        "Browser Load Time - Segmentation Chart",
        "Browser Version Chart",
        "Error Instance Details",
        "AJAX Dashboard",
        "Calls by Page View",
        "Request Status Codes",
        "Data Transfer Per Request",
        "Quickly View App Health",
        "Custom dashboards",
        "Integrate with your ticketing system",
        "Alerting",
        "Filterable Geography",
        "U.S. and EU Data Regions",
        "SOC2 Audited",
        "Secure Data Center",
        "Continuous Monitoring",
        "Secure by Default",
        "Compliance Friendly",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-03-12T01:54:26Z",
      "title": "New Relic Browser | New Relic",
      "updated_at": "2021-03-12T01:54:25Z",
      "type": "",
      "external_id": "b30121e0e2deb44e52a48d9a83ca4f854e2fb470",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Browser Overview Features Resources New Relic Browser features Sign up for free Page Load Performance JavaScript Errors Browser Performance AJAX Global Features Security Page Load Performance New Relic Browser is the world’s most deployed Real User Monitoring (RUM) solution because it’s easy to use, and instantly connects end-user experience with time spent in backend services. From easy-to-understand overviews to user-centric perceived performance metrics and events, Browser helps you benchmark and improve web performance and troubleshoot across your full stack. Full Support for Google’s Core Web Vitals By adding Cumulative Layout Shift, a score measuring the impact of sudden unexpected shifts in layout due to content dynamically resizing, we now offer full support for all three of Google’s Core Web Vitals for web health. Use NRQL to create dashboards for all three measurements, definitions below: Largest Contentful Paint (LCP) - measures loading performance First Input Delay (FID) - measures interactivity Cumulative Layout Shift (CLS) - measures visual stability User Centric Perceived Performance Web performance teams can use more modern metrics than just page load time to benchmark and improve end-user experience for their dynamic pages. Browser helps developers understand how code impacts customers, answering key questions on page performance. Monitor how long users wait for content to display (paint metrics), how long until users can interact with our page (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single Page App Route Changes View Single Page Application route change performance, regardless of what JavaScript framework you use. Powerful low-level instrumentation can even capture interactions beyond the route change that can be customized via API, allowing monitoring tailored to the architecture of your application, such as for custom frameworks. Session Traces Session Traces provide one of the most valuable assets an engineer requires - context. Beyond identifying long load times, and specific errors, Browser Session Traces provide the story that occurred both before and after an error or performance issue. Pivot from AJAX requests and JavaScript errors into a Session Trace and conversely pivot from a Session Trace out to a specific JavaScript error or Network error. Browser Traces Traces are snapshots of one user’s experience, surfaced as an outlier due to a longer than average load time. It provides details around when it took place, a segmented breakdown of where load time was spent, browser type, and the user’s geographic location. This report is excellent when dissecting areas of your application which are performing poorly for specific users. Page Load Time - Segmentation Chart Page load times capture metrics from the moment a user begins a transaction in the browser until the page completes loading. The reports show average page load time broken down into color-coded segments for: Request queuing, application code, network latency, DOM processing, and Page rendering. Page Load Time - Histogram and Percentiles Histograms and percentiles of browser page load times provide a holistic view of the speed of page loads, one that is not focused on averages alone. Histograms and percentiles surface every page load that occurred during a specified time window, providing the ability to drill into outliers that might have been overlooked otherwise. Geographic Reporting Understand how your end users’ experience with your site varies by geographical region. Identify if more CDN’s are required, or if high value customers in specific parts of the world are having a negative experience with your site’s performance. Page-Level AJAX Calls For a specific page, see all the AJAX calls being made as well as the response time, throughput (rpm), total number of calls, error status codes, and average data transfer made for each one. Page View Throughput Throughput is measured in requests per per minute. Throughput metrics help you understand which pages are being called most frequently. Connect Browser with Backend Performance From the Page views report, you can select single page URL and see all of the associated backend APM transactions (if you have the APM Agent installed in your application). Quickly view the total call time, average response time, and call count for any individual backend transaction. You can also dive deeper into a particular transaction and see diagnostics within our APM reports. JavaScript Errors The JavaScript error dashboards help you identify production JavaScript errors impacting your users' experiences and begin pinpointing how to resolve them. JavaScript Error Summary This summary view gives you a high level understanding of the types of JavaScript errors happening, the frequency at which they occur, and the percentage of users affected by the errors. Errors by Browser For each type of error, this chart shows you which browsers are being impacted by the error and the relative contribution it is making to your total error volume. Percentage of Page Views with Errors For each type of error, this chart shows you the percentage of page views affected by it. This allows you to quickly assess the reach and impact a particular error has on your end users. Source Map Support Troubleshoot minified production JavaScript code, with source map support giving you full visibility to where in your code the front-end error is. Intuitive drag-and-drop lets you locate issues in a click, while API integrations work seamlessly with your build pipeline. Best-in-class Customer Experience Monitoring Crash analysis in New Relic Mobile lets you analyze the most impactful crashes and fix them faster. Source map support in New Relic Browser gives you more actionable visibility into front-end JS errors by showing you exactly where in the original source the error occurred, even if your code is minified. Browser Performance New Relic's Browser dashboards provide information about your end users' experience based on browser type and version, so you can understand where to focus your time testing and optimizing for performance. Browser Throughput Provides a snapshot of the average number of pageviews received per minute broken down by browser type. Browser Load Time - Segmentation Chart For each type of browser, a segmented view of time spent on request queuing, application code, network latency, DOM processing, and Page rendering. Browser Version Chart Helps you understand which versions of each browser type your customers come from based on throughput. Error Instance Details Error Instance details grabs a snapshot of a single error and captures the stack trace details available from the browser, focusing on the actionable components, down to the line of code. These are metrics are combined with unique browser combinations down to the version level, and unique url. JavaScript diagnostics doesn't get more granular than this. AJAX If your applications use AJAX to update parts of a webpage after the initial page load, our AJAX dashboards will provide you with the level of visibility you need to understand how those requests are performing and ultimately affecting your users’ experience. AJAX Dashboard The main AJAX dashboard surfaces your site’s most resource intensive AJAX requests, filterable by time consumption, response time, throughput, callback time, and data transfer. From here you can drill into a particular call for detailed analysis. Calls by Page View Shows which page views are calling a particular server side controller, with page level detail around throughput, response time, total number of calls, and data transfer. Request Status Codes The status codes reporting indicates the return behavior from an AJAX call. A large number of non-200 status codes may indicate a problem with your AJAX endpoints. Data Transfer Per Request This shows data transfer which is requested and sent. Use this to look for correlations between high callback times and data transfer rates. Global Features The following features are used throughout New Relic’s product suite to help make our products easier to use and fit seamlessly into your existing workflows. Quickly View App Health New Relic uses color coded status indicators throughout to help you quickly spot performance issues. Custom dashboards Keep an eye on your most critical performance metrics quickly by adding them to a custom dashboard. Integrate with your ticketing system File tickets related to performance problems directly into your ticketing system. Learn which ticketing systems we support. Alerting Check out our new Alerts Features for Browser that report on JS error %, response time, throughput and much more! Filterable Geography Understand how your end users’ experience with your site varies by geographical region, down to the city level. Identify how a CDN or ASN/ Internet Service Provider is performing in different regions. Security New Relic is committed to helping customers make their applications fast and secure. We take protecting our customers' data seriously, here's an overview of how we do it. U.S. and EU Data Regions Our global data-hosting structure consists of two regions: European Union and United States. You can select your preferred data region during the account setup process, regardless of your physical location. (Note: We do not support migration or aggregation of data across regions.) SOC2 Audited New Relic has successfully completed a SOC 2 audit of processes and controls relevant to security and availability. This audit reviews our security process and controls and provides both ourselves, and more importantly our customers an independent, third-party assurance that we are taking the appropriate steps to protect our systems and our customer’s data. Secure Data Center The infrastructure that runs the New Relic service and stores our customer’s data resides in a Tier III, SSAE-16 certified data center. Customer data is backed up on a regular basis. Continuous Monitoring New Relic employs both internal and third-party services to perform continuous security scanning on both our network and applications to ensure that our applications and servers remain secure. Secure by Default We strongly believe in the concept of “secure by default”. Customers have to explicitly enable settings within New Relic to authorize the sending of sensitive data. We want to make sure that you are not accidentally exposing anything that you don’t want to. Compliance Friendly New Relic can be configured to operate securely in regulated environments such as PCI, HIPAA, or SOX. In addition we are Swiss and EU Privacy Shield certified. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.3055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Percentage of <em>Page</em> <em>Views</em> with Errors",
        "body": " (paint metrics), how long until users can interact with our <em>page</em> (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single <em>Page</em> <em>App</em> Route Changes <em>View</em> Single <em>Page</em> Application route change performance, regardless of what JavaScript"
      },
      "id": "5c66a952b5b9e17d23a27084"
    },
    {
      "sections": [
        "Amazon VPC monitoring integration",
        "Features",
        "Activate",
        "Configuration and polling",
        "Find and use data",
        "Metric data",
        "VPC NAT Gateway data",
        "Tip",
        "VPC VPN Tunnel",
        "Inventory data"
      ],
      "title": "Amazon VPC monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "AWS integrations list"
      ],
      "external_id": "8b5f98e1853d95d8f563d8910d02abac829976cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/aws-integrations-list/aws-vpc-monitoring-integration/",
      "published_at": "2021-03-11T10:48:09Z",
      "updated_at": "2021-03-11T10:48:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations include an integration for reporting your Amazon VPC data to New Relic. This document explains how to activate the integration and describes the data reported. Features The Amazon Virtual Private Cloud (VPC) is a virtual network that utilizes the scalable infrastructure of Amazon Web Services (AWS). With New Relic's VPC integration, you can gain visibility into configuration event changes that are overlaid across your Amazon services. The Amazon VPC integration generates a feed of configuration/inventory changes that occur in your VPC. VPC data is available in pre-built dashboards, and you can create custom queries and charts in New Relic One. You can also create alert conditions to notify you about changes in the VPC. Additionally, Enhanced Amazon VPC Flow Logs enables you to capture information about IP traffic to and from network interfaces in your VPC. Activate To enable this integration follow standard procedures to Connect AWS services to New Relic. Configuration and polling You can change the polling frequency and filter data using configuration options. Default polling information for the Amazon VPC integration: Default New Relic polling interval: 15 minutes Amazon CloudWatch data interval: 1 minute Find and use data To find your integration data, go to one.newrelic.com > Infrastructure > AWS and select one of the VPC integration links. You can query and explore your data using the PrivateNetworkSample event type, with provider values of: VpcNatGateway VpcVpnTunnel By default, collection of VpcNatGateway, VpcVpnTunnel, and VpcVpnConnection data is disabled. This is because if you have many NAT gateways or many VPNs (connections and tunnels), it might lead to an increase on your CloudWatch bill. For this reason, the integration provides configuration settings to set whether you want to fetch that data. For more on how to use your data, see Understand integration data. Metric data VPC NAT Gateway data This integration collects the following data from PrivateNetworkSample with a provider value of VpcNatGateway: Tip For full descriptions, see Amazon VPC NAT Gateway Metrics and Dimensions. Name Description activeConnectionCount The total number of concurrent active TCP connections through the NAT gateway. bytesInFromDestination The number of bytes received by the NAT gateway from the destination. bytesInFromSource The number of bytes received by the NAT gateway from clients in your VPC. bytesOutToDestination The number of bytes sent out through the NAT gateway to the destination. bytesOutToSource The number of bytes sent through the NAT gateway to the clients in your VPC. connectionAttemptCount The number of connection attempts made through the NAT gateway. connectionEstablishedCount The number of connections established through the NAT gateway. errorPortAllocation The number of times the NAT gateway could not allocate a source port. idleTimeoutCount The number of connections that transitioned from the active state to the idle state. An active connection transitions to idle if it was not closed gracefully and there was no activity for the last 350 seconds. packetsDropCount The number of packets dropped by the NAT gateway. packetsInFromDestination The number of packets received by the NAT gateway from the destination. packetsInFromSource The number of packets received by the NAT gateway from clients in your VPC. packetsOutToDestination The number of packets sent out through the NAT gateway to the destination. packetsOutToSource The number of packets sent through the NAT gateway to the clients in your VPC. VPC VPN Tunnel This integration collects the following data from PrivateNetworkSample with a provider value of VpcVpnTunnel: Tip For full descriptions, see Amazon VPC VPN Metrics and Dimensions. Name Description tunnelState The state of the tunnel. 0 indicates DOWN and 1 indicates UP. tunnelDataIn The bytes received through the VPN tunnel. Each metric data point represents the number of bytes received after the previous data point. Use the Sum statistic to show the total number of bytes received during the period. tunnelDataOut The bytes sent through the VPN tunnel. Each metric data point represents the number of bytes sent after the previous data point. Use the Sum statistic to show the total number of bytes sent during the period. Inventory data This integration reports the following VPC configuration options and metadata as inventory data. For more about inventory data, see Understand integration data. Tip Tags (indicated with an *) are only fetched when tags collection is on. Inventory category Data aws/vpc/network-interface awsRegion subnetId status sourceDestCheck requesterManaged requesterId privateIpAddress privateDnsName networkInterfaceId macAddress ipv6Addresses securityGroups description availabilityZone attachmentInstanceId attachmentDeleteOnTermination attachmentStatus attachmentInstanceOwnerId publicIp publicDnsName tags * aws/vpc/endpoint awsRegion creationTimestamp policyDocumentMd5 routeTableIds serviceName state vpcId vpcEndpointId aws/vpc/nat-gateway awsRegion natGatewayId createTime natGatewayAddresses state subnetId vpcId aws/vpc/peering-connection awsRegion vpcPeeringConnectionId accepterVpcInfo requesterVpcInfo tags * aws/vpc/vpn/connection awsRegion vpnId state type category customerGatewayConfiguration vpnGatewayId customerGatewayId staticRoutesOnly tags * aws/vpc/vpn/tunnel awsRegion acceptedRouteCount outsideIpAddress status statusChange statusMessage aws/vpc/internet-gateway region internetGatewayId attachments tags * aws/vpc/network-acl region networkAclId associations entries isDefault vpcId tags * aws/vpc/route-table region routeTableId associations propagatingVgws routes vpcId tags * aws/vpc/security-group region description groupName groupId ipPermissions ipPermissionsEgress ownerId vpcId tags * aws/vpc/subnet region availabilityZone cidrBlock defaultForAz mapPublicIpOnLaunch subnetId state vpcId tags * aws/vpc/vpc region cidrBlock dhcpOptionsId enableDnsHostname enableDnsSupport instanceTenancy isDefault state vpcId tags *",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.3327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " <em>region</em> routeTableId associations propagatingVgws routes vpcId tags * aws&#x2F;vpc&#x2F;security-group <em>region</em> description groupName groupId ipPermissions ipPermissionsEgress ownerId vpcId tags * aws&#x2F;vpc&#x2F;subnet <em>region</em> availabilityZone cidrBlock defaultForAz <em>map</em>PublicIpOnLaunch subnetId state vpcId tags * aws&#x2F;vpc&#x2F;vpc <em>region</em> cidrBlock dhcpOptionsId enableDnsHostname enableDnsSupport instanceTenancy isDefault state vpcId tags *"
      },
      "id": "60450763196a678c49960f68"
    },
    {
      "sections": [
        "Upload source maps via API",
        "Prepare for using the source map API",
        "What is the JavaScript URL?",
        "Is a release name and ID required?",
        "Are there limits to source map uploads?",
        "Push source maps to New Relic",
        "Use npm module via command line or client-side script",
        "Important",
        "npm command line: Publish",
        "npm command line: List published maps",
        "npm command line: Delete",
        "npm via Node.js script: Publish",
        "npm via Node.js script: List published maps",
        "npm via Node.js script: Delete",
        "Use API via curl",
        "curl: Upload maps",
        "curl: List existing maps",
        "curl: Delete map",
        "Troubleshoot source maps"
      ],
      "title": "Upload source maps via API",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "3c5a8467aa0c47e12cbe83080e701e3c7cee090c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/upload-source-maps-api/",
      "published_at": "2021-03-11T04:55:59Z",
      "updated_at": "2021-03-11T04:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring supports the uploading of source maps, which are used to un-minify error stack traces on the JS errors page. This document explains how to use the API to publish (upload) source maps to Browser. Prepare for using the source map API In order to upload source maps to Browser via the API, you'll need this information: A user API key (before November 20, 2020, the Admin API key was required; that will still work if already in place) The New Relic application ID for the deployed app The full JavaScript file URL Optionally, if the JavaScript URL doesn't automatically have release info appended to it, the release name and ID What is the JavaScript URL? Every time the agent captures an error in your code, it's associated with the URL of the JavaScript in which it occurred. This is the src attribute of the script tag in your HTML. This full JavaScript URL is required when sending source maps to Browser. You can find the URL for an error's JavaScript file in Browser, on the JS errors page. See Browser monitoring source maps for more on finding these errors in the UI. Is a release name and ID required? Many organizations include a version number or hash in the JavaScript URL. This is generally added to \"bust\" caches to ensure your users get the most recent version of your code. This type of URL might look something like: https://example.com/assets/application-59.min.js https://example.com/assets/bundle-d6d031.min.js https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js If your app's URLs automatically have the version info appended to it, the Browser agent has everything it needs in order to match errors with your code. You can move ahead to generating source maps. If this doesn't apply to you, and JS URLs do not have version info appended, you’ll have to assist the agent by specifying a release name and ID with the API. Are there limits to source map uploads? There is no limit to the overall number of source maps you can upload. However, the API is rate-limited: You can upload a maximum of 100 source maps per minute You can upload a maximum of 5,000 source maps per day Source map files can be a maximum of 50Mb in size. Push source maps to New Relic Now that you have one or more source maps, you are ready to publish it to Browser. You can use any of these methods to send source maps to Browser: Use the New Relic npm module with the API via the command line or via a client-side JavaScript build/deploy script like Gulp or Grunt. Use API curl commands. Use the Browser UI. Use npm module via command line or client-side script The easiest and recommended way to upload source maps to Browser is to use the our new @newrelic/publish-sourcemap npm module. It provides a command line tool and Javascript API to accomplish this task. More documentation is available in the npm repo. Here are some examples of using the npm module via the command line. Important The following examples are for US accounts. For EU accounts, the endpoint is https://sourcemaps.service.eu.newrelic.com. For more information, see Introduction to the EU region data center. npm command line: Publish Here's an example of uploading source maps using the npm module via the command line. Note that the source map can come from a local file or a remote URL. npm install -g @newrelic/publish-sourcemap publish-sourcemap PATH_TO_SOURCE_MAP_FILE (local or remote) PATH_TO_ORIGINAL_FILE --apiKey=YOUR_NEW_RELIC_USER_API_KEY --applicationId=YOUR_NEW_RELIC_APP_ID Copy npm command line: List published maps Here's an example of listing published source maps: list-sourcemaps --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_KEY Options: --applicationId Browser application id --apiKey New Relic user API key Copy npm command line: Delete Here's an example of deleting a source map: delete-sourcemap --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_API_KEY --sourcemapId=YOUR_SOURCE_MAP_ID Options: --applicationId Browser application id --apiKey New Relic user API key --sourcemapId Unique id generated for a source map Copy Here are some examples of using the npm module to publish from client-side JavaScript: npm via Node.js script: Publish Here's an example of publishing a source map via a Node.js script: var publishSourcemap = require(‘@newrelic/publish-sourcemap’).publishSourcemap publishSourcemap({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY' }, function (err) { console.log(err || 'Sourcemap upload done')}) Copy npm via Node.js script: List published maps Here's an example of listing all published source maps: var listSourcemaps = require(‘@newrelic/publish-sourcemap’).listSourcemaps listSourcemaps({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err, res) { console.log(err || res.body)}) Copy npm via Node.js script: Delete Here's an example of deleting a source map file via a Node.js script: var deleteSourcemap = require(‘@newrelic/publish-sourcemap’).deleteSourcemap deleteSourcemap({ sourcemapId: 'SOURCE_MAP_ID', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err) { console.log(err || 'Deleted source map')}) Copy When you're done, go to the JS errors page in Browser, select an error grouping, and see if your error stack traces have been un-minified. Use API via curl Below are some examples of using curl to publish, list, and delete source maps: curl: Upload maps An example of using API via curl to publish maps to Browser: curl -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ -F \"sourcemap=@SOURCE_MAP_PATH\" \\ -F \"javascriptUrl=JS_URL\" \\ -F \"releaseId=YOUR_RELEASE_ID\" \\ -F \"releaseName=YOUR_UI_PAGE\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps Copy curl: List existing maps Below is an example of how to get a list of source maps previously uploaded to New Relic via curl. New Relic returns the source map's unique SOURCEMAP_ID and its components: curl \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps Copy curl: Delete map To delete a source map: Use the GET endpoint to list existing source maps and locate the SOURCEMAP_ID. Run the following command via curl: curl -X DELETE \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps/SOURCEMAP_ID Copy When you're done, go to the JS errors page in Browser, select an error grouping, and see if your error stack traces have been un-minified. Troubleshoot source maps If you are having trouble generating source maps from your build system, or if your errors in Browser are remaining minified, see the source maps troubleshooting documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.82079,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upload source <em>maps</em> via API",
        "sections": "Upload source <em>maps</em> via API",
        "body": "&#x2F;publish-sourcemap’).deleteSourcemap deleteSourcemap({ sourcemapId: &#x27;SOURCE_<em>MAP</em>_ID&#x27;, applicationId: YOUR_NEW_RELIC_<em>APP</em>_ID, apiKey: &#x27;YOUR_NEW_RELIC_USER_API_KEY&#x27;, }, function (err) { console.log(err || &#x27;Deleted source <em>map</em>&#x27;)}) Copy When you&#x27;re done, go to the JS errors <em>page</em> in Browser, select an error"
      },
      "id": "6043fea6196a672dec960f78"
    },
    {
      "sections": [
        "Create custom events (Go)",
        "RecordCustomEvent parameters",
        "Example"
      ],
      "title": "Create custom events (Go)",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Instrumentation"
      ],
      "external_id": "51ae4a409139b08f5a2df59d9c379d425d21d97a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/features/create-custom-events-go/",
      "published_at": "2021-03-11T08:13:38Z",
      "updated_at": "2021-03-11T08:13:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Custom events are useful to explore data for a single event you are interested in, including data from external sources, at a particular moment in time. To track arbitrary event data for apps monitored by your New Relic Go agent, add RecordCustomEvent to the apps. You can then query and visualize the event data. RecordCustomEvent parameters To add RecordCustomEvent to your Go app, use this format: RecordCustomEvent(eventType string, params map[string]interface{}) Copy Parameter Description eventType string Required. The name of the event type to record. Must consist of alphanumeric characters, underscores _, or colons :. Must contain no more than 255 bytes. Must follow New Relic Insights data requirements for names, limits, and restricted characters. params map number, string, or boolean Required. Specify key/value pairs of attributes to annotate the event. Each value in the params map must be a number, string, or boolean. Keys must be less than 255 bytes. The params map must not contain more than 64 attributes. Example Here is an example of a custom event for a Go app: func customEvent(w http.ResponseWriter, r *http.Request) { io.WriteString(w, \"recording a custom event\") app.RecordCustomEvent(\"my_event_type\", map[string]interface{}{ \"myString\": \"hello\", \"myFloat\": 0.603, \"myInt\": 123, \"myBool\": true, }) } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.56963,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>custom</em> events (Go)",
        "sections": "Create <em>custom</em> events (Go)",
        "body": " the event data. Record<em>Custom</em>Event parameters To add Record<em>Custom</em>Event to your Go <em>app</em>, use this format: Record<em>Custom</em>Event(eventType string, params <em>map</em>[string]interface{}) Copy Parameter Description eventType string Required. The name of the event type to record. Must consist of alphanumeric characters"
      },
      "id": "6043d7e028ccbcd7dc2c60d3"
    }
  ],
  "/components/charts": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation | New Relic Documentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-03-08T15:36:49Z",
      "updated_at": "2021-03-02T20:41:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.19852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Build a custom visualization for dashboards",
        "Before you begin",
        "Create a new visualization",
        "Render the visualization in local development",
        "Important",
        "Advanced nerdpack configuration",
        "Deploy and use your visualization",
        "Summary"
      ],
      "title": "Build a custom visualization for dashboards",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "5e17f1f0db2020342ced37e95dbcb94489b5ca73",
      "image": "https://developer.newrelic.com/static/cf9bafc3fc03f7562e4f969cafcd7659/30c01/visualization-apps-navigation.png",
      "url": "https://developer.newrelic.com/build-apps/build-visualization/",
      "published_at": "2021-03-12T01:47:31Z",
      "updated_at": "2021-02-27T01:48:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create custom data views",
      "body": "Building your own visualizations for New Relic dashboards enables you and your organization to query data from any source and display it on your dashboard. In this guide, you'll learn how to use the CLI to generate a visualization file structure, run it locally where you can quickly test and iterate, and then deploy it for use in a dashboard. Before you begin To get started, make sure you have a New Relic account. To complete this guide, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. Create a new visualization In this first set of steps you will use the CLI to quickly generate the boilerplate for a new visualization. Step 1 of 3 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 3 Start with a new Nerdpack. If you just installed the New Relic One CLI, then you have a new Nerdpack project directory (called something like my-awesome-nerdpack). If you need to create one, run nr1 create and select the nerdpack option. bash Copy $ nr1 create --type nerdpack --name my-awesome-nerdpack Step 3 of 3 Navigate to the root of your Nerdpack project and run the nr1 create command, selecting the visualization option. bash Copy $ cd my-awesome-nerdpack $ nr1 create --type visualization --name my-awesome-visualization As a result, you have a new visualization directory matching the name you gave your visualization. It is located in the visualizations directory in the root of your Nerdpack project. The files created provide an example visualization – a radar chart populated by a basic NRQL query. The nr1.json file provides metadata. The configuration key in this metadata defines the prop-input fields to be shown in the UI. These are the fields users will fill in to create an instance of the visualization. Supported input types are: boolean string number json nrql: a single NRQL query string. namespace: a group of input fields to be displayed together under a shared heading in the prop-editing UI. collection: a repeatable group of input fields to be displayed together under a shared heading in the prop-editing UI. The nrqlQueries entry is an example of a collection type. The index.js file is where you define the React component that receives the props and renders the visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. If your visualization queries data over a time range and you want it to utilize the platform time range setting, you will need to utilize the timeRange value from PlatformStateContext. The timeRange can be passed directly to the NrqlQuery component. Setting the NrqlQuery component's pollInterval prop to NrqlQuery.AUTO_POLL_INTERVAL automatically handles calculating an appriate data polling interval. <PlatformStateContext.Consumer> {({timeRange}) => ( <NrqlQuery timeRange={timeRange} pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} > ... Copy Render the visualization in local development Now run the generated visualization locally, and view it in Custom Visualizations. There you can quickly test changes to your code. Step 1 of 7 Start the local Node server for your Nerdpack. bash Copy $ nr1 nerdpack:serve Important To see changes to the nr1.json file take effect, restart the local Node server. Changes to the definition of the configuration field will not show up in the prop configuration side bar of the Custom Visualizations UI until you stop the local Node server and start it back up. Step 2 of 7 In a browser, open https://one.newrelic.com/?nerdpacks=local. This url is also shown in the terminal when the Node server starts. The nerdpacks=local query string will direct the UI to load your new visualization artifact from the local Node server. Advanced nerdpack configuration See the advanced nerdpack configuration section for detailed information about how your local Node server is proxied to the browser and how you can override webpack configuration if needed. Step 3 of 7 Open the Apps page, and navigate to Custom Visualizations, which you will find favorited by default. Step 4 of 7 In the Custom Visualizations listing, find and click on the tile for your visualization. If the tile is not showing up or it is not indicating that it is running locally, restart the Node server and refresh the browser. When you select your locally running visualization, the visualization hosted by your local Node server is rendered with prop-configuration inputs. Here you can take advantage of the features outlined in the following steps. Step 5 of 7 You can set prop values and see the visualization update automatically. The prop inputs are listed as defined in the prop definitions located in the nr1.json file in the visualization folder (for example ./visualizations/my-awesome-visualization/nr1.json). Fill in values for the props and see the visualization update automatically. As you change props in the sidebar, a render cycle of your visualization's React component is triggered. Step 6 of 7 Modify the visualization's Javascript code and see the result automatically update in the UI. For example, you can change the value for fillOpacity on the Radar component in index.js. Upon save, you will see the page automatically update. fillOpacity={1.0} visualizations/your-visualization/index.js Copy Step 7 of 7 To add more props, you must update the configuration field in the nr1.json file for your visualization and restart the local Node server. The props you define in the configuration field allow New Relic One to cleanly display a prop-editing UI for users interacting with your visualization. See above for more information about the configuration field. Deploy and use your visualization When your visualization is ready to be added to a dashboard, just follow these steps. Step 1 of 2 Open and follow the guide to publish and deploy the Nerdpack to New Relic One and subscribe accounts to it. Step 2 of 2 Then you can add your visualization to a dashboard. Summary Congratulations on completing the steps in this example! You've learned how to: Create a visualization and run it locally Quickly test and iterate on visualization code changes in Custom Visualizations Deploy a visualization Add a custom visualization to a dashboard",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.1096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Advanced <em>nerdpack</em> configuration",
        "tags": "<em>nr1</em> <em>cli</em>",
        "body": " in the <em>CLI</em> quick start. Create a new visualization In this first set of steps you will use the <em>CLI</em> to quickly generate the boilerplate for a new visualization. Step <em>1</em> of 3 Ensure you&#x27;re working with the latest version of the New Relic One <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 3 Start with a new <em>Nerdpack</em>"
      },
      "id": "6039a4dbe7b9d262492a07c4"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.17335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-03-12T01:48:26Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.9024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One <em>CLI</em> common commands",
        "sections": "<em>nr1</em> help",
        "info": "An overview of common commands you can use with the New Relic One <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or catalog). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-03-12T01:48:26Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.9024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " building guides and the New Relic One <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── <em>nr1</em>.json"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Build a custom visualization for dashboards",
        "Before you begin",
        "Create a new visualization",
        "Render the visualization in local development",
        "Important",
        "Advanced nerdpack configuration",
        "Deploy and use your visualization",
        "Summary"
      ],
      "title": "Build a custom visualization for dashboards",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "5e17f1f0db2020342ced37e95dbcb94489b5ca73",
      "image": "https://developer.newrelic.com/static/cf9bafc3fc03f7562e4f969cafcd7659/30c01/visualization-apps-navigation.png",
      "url": "https://developer.newrelic.com/build-apps/build-visualization/",
      "published_at": "2021-03-12T01:47:31Z",
      "updated_at": "2021-02-27T01:48:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Create custom data views",
      "body": "Building your own visualizations for New Relic dashboards enables you and your organization to query data from any source and display it on your dashboard. In this guide, you'll learn how to use the CLI to generate a visualization file structure, run it locally where you can quickly test and iterate, and then deploy it for use in a dashboard. Before you begin To get started, make sure you have a New Relic account. To complete this guide, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. Create a new visualization In this first set of steps you will use the CLI to quickly generate the boilerplate for a new visualization. Step 1 of 3 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 3 Start with a new Nerdpack. If you just installed the New Relic One CLI, then you have a new Nerdpack project directory (called something like my-awesome-nerdpack). If you need to create one, run nr1 create and select the nerdpack option. bash Copy $ nr1 create --type nerdpack --name my-awesome-nerdpack Step 3 of 3 Navigate to the root of your Nerdpack project and run the nr1 create command, selecting the visualization option. bash Copy $ cd my-awesome-nerdpack $ nr1 create --type visualization --name my-awesome-visualization As a result, you have a new visualization directory matching the name you gave your visualization. It is located in the visualizations directory in the root of your Nerdpack project. The files created provide an example visualization – a radar chart populated by a basic NRQL query. The nr1.json file provides metadata. The configuration key in this metadata defines the prop-input fields to be shown in the UI. These are the fields users will fill in to create an instance of the visualization. Supported input types are: boolean string number json nrql: a single NRQL query string. namespace: a group of input fields to be displayed together under a shared heading in the prop-editing UI. collection: a repeatable group of input fields to be displayed together under a shared heading in the prop-editing UI. The nrqlQueries entry is an example of a collection type. The index.js file is where you define the React component that receives the props and renders the visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. If your visualization queries data over a time range and you want it to utilize the platform time range setting, you will need to utilize the timeRange value from PlatformStateContext. The timeRange can be passed directly to the NrqlQuery component. Setting the NrqlQuery component's pollInterval prop to NrqlQuery.AUTO_POLL_INTERVAL automatically handles calculating an appriate data polling interval. <PlatformStateContext.Consumer> {({timeRange}) => ( <NrqlQuery timeRange={timeRange} pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} > ... Copy Render the visualization in local development Now run the generated visualization locally, and view it in Custom Visualizations. There you can quickly test changes to your code. Step 1 of 7 Start the local Node server for your Nerdpack. bash Copy $ nr1 nerdpack:serve Important To see changes to the nr1.json file take effect, restart the local Node server. Changes to the definition of the configuration field will not show up in the prop configuration side bar of the Custom Visualizations UI until you stop the local Node server and start it back up. Step 2 of 7 In a browser, open https://one.newrelic.com/?nerdpacks=local. This url is also shown in the terminal when the Node server starts. The nerdpacks=local query string will direct the UI to load your new visualization artifact from the local Node server. Advanced nerdpack configuration See the advanced nerdpack configuration section for detailed information about how your local Node server is proxied to the browser and how you can override webpack configuration if needed. Step 3 of 7 Open the Apps page, and navigate to Custom Visualizations, which you will find favorited by default. Step 4 of 7 In the Custom Visualizations listing, find and click on the tile for your visualization. If the tile is not showing up or it is not indicating that it is running locally, restart the Node server and refresh the browser. When you select your locally running visualization, the visualization hosted by your local Node server is rendered with prop-configuration inputs. Here you can take advantage of the features outlined in the following steps. Step 5 of 7 You can set prop values and see the visualization update automatically. The prop inputs are listed as defined in the prop definitions located in the nr1.json file in the visualization folder (for example ./visualizations/my-awesome-visualization/nr1.json). Fill in values for the props and see the visualization update automatically. As you change props in the sidebar, a render cycle of your visualization's React component is triggered. Step 6 of 7 Modify the visualization's Javascript code and see the result automatically update in the UI. For example, you can change the value for fillOpacity on the Radar component in index.js. Upon save, you will see the page automatically update. fillOpacity={1.0} visualizations/your-visualization/index.js Copy Step 7 of 7 To add more props, you must update the configuration field in the nr1.json file for your visualization and restart the local Node server. The props you define in the configuration field allow New Relic One to cleanly display a prop-editing UI for users interacting with your visualization. See above for more information about the configuration field. Deploy and use your visualization When your visualization is ready to be added to a dashboard, just follow these steps. Step 1 of 2 Open and follow the guide to publish and deploy the Nerdpack to New Relic One and subscribe accounts to it. Step 2 of 2 Then you can add your visualization to a dashboard. Summary Congratulations on completing the steps in this example! You've learned how to: Create a visualization and run it locally Quickly test and iterate on visualization code changes in Custom Visualizations Deploy a visualization Add a custom visualization to a dashboard",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 622.9911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Advanced <em>nerdpack</em> configuration",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " in the <em>CLI</em> quick start. Create a new visualization In this first set of steps you will use the <em>CLI</em> to quickly generate the boilerplate for a new visualization. Step <em>1</em> of 3 Ensure you&#x27;re working with the latest version of the New Relic <em>One</em> <em>CLI</em>: bash Copy $ <em>nr1</em> update Step 2 of 3 Start with a new <em>Nerdpack</em>"
      },
      "id": "6039a4dbe7b9d262492a07c4"
    },
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you’re looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 μs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is “loading” its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 475.69406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "In your application, you can display data in charts, like those used elsewhere in New Relic&#x27;s user interface. The New Relic <em>One</em> SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply"
      },
      "id": "5fdab9f1e7b9d2e1e8df9221"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation | New Relic Documentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-03-08T15:36:49Z",
      "updated_at": "2021-03-02T20:41:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.45685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic <em>applications</em>. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-03-12T01:49:20Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.1466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-03-12T01:48:26Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.8404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or <em>catalog</em>). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.87677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards <em>API</em> migration: from Insights <em>API</em> to Nerdgraph",
        "sections": "Why a <em>new</em> dashboards <em>API</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and understandable description of the APIs&#x27; data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights <em>API</em> to the <em>new</em> <em>New</em> <em>Relic</em> <em>One</em> dashboards <em>API</em>. Find below some examples that illustrate how the old"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Improved features in New Relic One",
        "Try out New Relic One",
        "Recommendations",
        "Learn more"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-03-11T03:15:51Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries and charts. Now we have New Relic One, which has its own query builder experience. New Relic One offers an improved charts and dashboards experience compared to Insights. This transition guide can help you understand: What are some of the new and improved New Relic One chart/dashboard features Why it's easy to switch to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Improved features in New Relic One New Relic One is an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more. one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. After using your dashboards in New Relic One, your dashboards will still be in Insights. Features include: Better querying and charting experiences, including a \"basic\" query mode that doesn't require knowledge of NRQL Better display options that are easier to understand, especially with dense, line-heavy charts and a better TV mode More charts or widgets across dashboards (up to 12 now, instead of Insights' 3-across limit Easier creation of dashboards with multiple pages (previously called data apps in Insights). Your Insights data apps are preserved as multi-page dashboards in New Relic One. Improved experience for querying metric data, both the Metric data type and metric timeslice data Easy customization for your visualizations Try out New Relic One It's easy to try out and switch to New Relic One. We recommend reading the recommendations before you do. Then, to view your Insights dashboards in New Relic One, go to an Insights dashboard and click Try new dashboards. Recommendations The transition from Insights to New Relic One was designed to be easy and seamless, but we have one recommendation: Important If your team starts to edit or create dashboards in New Relic One, don't go back to Insights to edit those dashboards. If you create some types of dashboards in New Relic One, their improved features may lose functionality when edited in Insights. These include: Dashboards created using the Insights metric explorer. When edited in New Relic One, that data is converted to another format, which means it cannot then be edited in Insights. Dashboards with 3+ widgets across. Insights has a 3-widgets-across limit. If you build a New Relic One dashboard with more than 3 widgets across, editing that dashboard in Insights will break its layout in New Relic One. New customization features result in incompatibilities between New Relic One and Insights charts. Also: Dashboards with multiple pages are no longer called Data apps. When you create a New Relic One dashboard that has multiple pages and go back to Insights, it will be located in the Data apps section. Some admin-related UI pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page API keys UI page Formatter UI page To find these pages: go to insights.newrelic.com > Manage data Learn more For a more detailed look of New Relic One dashboard features, see this Explorers Hub post. To learn about other New Relic One features, see Introduction to New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.87677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " pages are not present. The following Manage data UI pages will remain in Insights for now: Summary UI page Add data UI page Embeddables UI page Lookup tables UI page <em>API</em> keys UI page Formatter UI page To find these pages: go to insights.newrelic.com &gt; Manage data Learn more For a more detailed look of <em>New</em> <em>Relic</em> <em>One</em> dashboard features, see this Explorers Hub post. To learn about other <em>New</em> <em>Relic</em> <em>One</em> features, see Introduction to <em>New</em> <em>Relic</em> <em>One</em>."
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "AWS CloudFormation integration",
        "Features",
        "Requirements",
        "Install the CloudFormation integration",
        "Register the resource provider",
        "Register using the CloudFormation API",
        "Register using the CloudFormation CLI",
        "Configure the resource provider",
        "Example configuration",
        "JSON example configuration",
        "YAML example configuration",
        "Provision the Resource in a CloudFormation Stack",
        "What's next?"
      ],
      "title": "AWS CloudFormation integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "AWS integrations list"
      ],
      "external_id": "94c3cebdaeaa394fb5369b657c844e9c764a42cc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/aws-integrations-list/aws-cloudformation-integration/",
      "published_at": "2021-03-11T10:43:07Z",
      "updated_at": "2021-03-11T10:43:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic’s AWS CloudFormation integration allows you to add alert conditions to new or existing CloudFormation stacks using the New Relic alerts resource provider. This document explains how to activate and use this integration. Features AWS CloudFormation is an Amazon Web Services (AWS) service that allows you to use programming languages or a simple text file to model and provision, in an automated and secure manner, all the resources needed for your applications across all regions and accounts. It allows you to simply create and duplicate a collection of AWS resources, known as a stack. Whenever a stack is generated, AWS CloudFormation provisions the resources that are specified in your template. Using the CloudFormation integration for New Relic, you can add alert conditions to your CloudFormation template using our custom resource provider, giving you the ability to monitor your infrastructure and applications with New Relic Alerts. Requirements To use the Amazon CloudFormation integration, ensure your system meets these requirements: AWS Command Line Interface (AWS CLI) installed. New Relic REST API key. Optional: CloudFormation CLI installed. Install the CloudFormation integration To install the CloudFormation integration: Navigate to the New Relic CloudFormation Partner Integration GitHub repository. From the repository page, clone or download the repository. Register the resource provider To use private resource providers you must first register them with CloudFormation, in the accounts and regions in which you want to use them. Once you're registered a resource provider, it will appear in the CloudFormation registry for that account and region, and you can use it in your stack templates. You can register the resource provider using one of the following methods: Register using the CloudFormation API To register the resource provider using the CloudFormation API: In your terminal or command-line interface, run the RegisterType action to validate, package, and upload the resource provider to the CloudFormation Registry: aws cloudformation register-type --type-name NewRelic::Alerts::NrqlAlert --schema-handler-package s3://nr-cloudformation-downloads/newrelic-alerts-nrqlalert.zip --type RESOURCE Copy Note: If you are updating a previously registered resource, you can use the returned registration token to track the progress of the registration request using the DescribeTypeRegistration action in the CloudFormation API. Token example: Registration in progress with token: <3c27b9e6-dca4-4892-ba4e-3c0example> Copy Register using the CloudFormation CLI To register the resource provider using the CloudFormation Command Line Interface (CLI): Refer to the AWS CloudFormation Github README for instructions on downloading and installing the CloudFormation CLI. Once you have installed the CloudFormation CLI, run the following command to validate, package, and upload the resource provider to the CloudFormation Registry: cfn submit -v --region <region> Copy Note: If you are updating a previously registered resource, you can use the returned registration token to track the progress of the registration request using the DescribeTypeRegistration action in the CloudFormation API. Token example: Validating your resource specification... Packaging Java project Creating managed upload infrastructure stack Managed upload infrastructure stack already exists. Attempting to update Managed upload infrastructure stack is up to date Registration in progress with token: <3c27b9e6-dca4-4892-ba4e-3c0example> Copy Configure the resource provider Once you have registered the resource, add the NewRelic::Alerts::NrqlAlert resource to the JSON or YAML file for your CloudFormation stack, using the following properties to configure the alert condition. For an example configuration, see the Lambda CloudFormation resource examples. Properties Description Type ApiKey The New Relic REST API key. Required. string PolicyId The unique ID for the alert policy's account ID associated with the condition; for example, 1234567890. Required. integer Condition Name The name of the alerting condition. string RunbookUrl Link to runbook for resolving this error. string Enabled The status of your alert condition. true if the alert is active. Default: false boolean ExpectedGroups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. integer IgnoreOverlap If disabled, New Relic looks for a convergence of groups. If the condition is looking for 2 or more groups, and the returned values cannot be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. boolean ValueFunction This is the value function used from the plugin metric, and be one of the following strings: min max average sample_size total percent For more information on ValueFunction, see Alerts conditions API glossary: value_function. string Terms An array of key/value pairs that may include the following: Duration Operator Priority Threshold TimeFunction For detailed field definitions, see Alerts conditions API glossary: terms. array Nrql The NRQL query being monitored by Alerts, must include both of the following: Query (Required) SinceValue (Required) For detailed field definitions, see Alerts conditions API glossary: nrql. Required. string Example configuration Lambda CloudFormation resource examples: JSON example configuration { \"AWSTemplateFormatVersion\": \"2010-09-09\", \"Resources\": { \"LambdaNodeAlert\": { \"Type\": \"NewRelic::Alerts::NrqlAlert\", \"Properties\": { \"ApiKey\": \"YOUR_API_KEY\", \"PolicyId\": YOUR_POLICY_ID, \"NrqlCondition\": { \"Name\": \"Alert Condition NAme\", \"RunbookUrl\": \"http://example.com/runbook.html\", \"Enabled\": false, \"ExpectedGroups\": 1, \"IgnoreOverlap\": true, \"Terms\": [ { \"Duration\": 1, \"Operator\": \"equal\", \"Priority\": \"critical\", \"Threshold\": 1.0, \"TimeFunction\": \"all\" } ], \"Nrql\": { \"Query\": \"SELECT count(*) FROM AwsLambdaInvocationError FACET provider.functionName\", \"SinceValue\": 1 } } } } } Copy YAML example configuration AWSTemplateFormatVersion: 2010-09-09 Resources: # Here's our custom resource type, which creates an alert in New Relic that triggers when the function is invoked LambdaNodeAlert: Type: NewRelic::Alerts::NrqlAlert Properties: #TODO: Your values here ApiKey: YOUR_API_KEY PolicyId: YOUR_POLICY_ID NrqlCondition: Name: Alert Condition Test RunbookUrl: http://example.com/runbook Enabled: true ExpectedGroups: 1 IgnoreOverlap: true Terms: - Duration: 1 Operator: \"equal\" Priority: \"critical\" Threshold: 1.0 TimeFunction: \"all\" Nrql: Query: \"SELECT count(*) FROM AwsLambdaInvocationError FACET provider.functionName\" SinceValue: 1 Copy Provision the Resource in a CloudFormation Stack To use the resource provider to provision your stack and create an alert condition: Once you have added the resource provider to your CloudFormation template, run the following command in your terminal or command-line interface to provision the resource and create your CloudFormation stack: aws cloudformation create-stack --region us-west-2 \\ --template-body \"file://stack.yaml\" \\ --stack-name NewRelicAlert Copy To view your alert, go to alerts.newrelic.com, select Alert policies > (selected policy) > Alert conditions. What's next? To learn more about using alerts: Check out the New Relic University tutorial Intro to alert policies. Or, go directly to the full online course New Relic alerting. Read Alerts best practices. Learn about the New Relic Alerts API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 248.58133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Register using the CloudFormation <em>API</em>",
        "body": " infrastructure and applications with <em>New</em> <em>Relic</em> Alerts. Requirements To use the Amazon CloudFormation integration, ensure your system meets these requirements: AWS Command Line Interface (AWS <em>CLI</em>) installed. <em>New</em> <em>Relic</em> REST <em>API</em> <em>key</em>. Optional: CloudFormation <em>CLI</em> installed. Install the CloudFormation"
      },
      "id": "60440e2164441f1746378efc"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/56ee242dc2dcb0098eb8ae67d5d14807/c1b63/Operational_workload.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-03-12T01:53:52Z",
      "updated_at": "2021-03-10T01:47:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, from frontend to backend services, across your entire stack. Workloads help you understand complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and back-end APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, from front-end to back-end services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the back-end APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Apps > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role that has that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 239.893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", and resolve those issues quickly. Tip To use workloads with Alerts and Applied Intelligence, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free <em>account</em> in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-03-09T03:53:01Z",
      "updated_at": "2021-03-09T03:53:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.8551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that <em>key</em> performance indicator. The chart titles link to <em>New</em> <em>Relic</em> <em>One</em> when there’s an associated entity in your <em>account</em>. Note that correlations currently do"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ]
}