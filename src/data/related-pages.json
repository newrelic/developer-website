{
  "/automate-workflows/get-started-terraform": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2q925u10aatdd/promo-image.1602169257.png",
      "url": "https://learn.newrelic.com/effective-alerting-with-new-relic",
      "sections": [
        "In this engaging FREE 2 hour session we move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you. With scenario based labs you’ll create specific policies and conditions for typical use cases across the full stack, use ",
        "About this workshop"
      ],
      "published_at": "2020-11-23T01:37:52Z",
      "title": "Effective Alerting with New Relic",
      "updated_at": "2020-11-20T01:38:46Z",
      "type": "",
      "external_id": "d88dcb753499fcfdcc9677a0c48a6a6866a7c111",
      "popularity": 1,
      "body": "Sign In Effective Alerting with New Relic In this engaging FREE 2 hour session we move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you. With scenario based labs you’ll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop More live training sessions coming soon. Want to know more about alerting? In this highly practical and engaging 2 hour session we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs you’ll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  You'll get to work with Applied Intelligence alerting and learn how to make use of Proactive Detection and Incident Intelligence to reduce alert noise, correlate incidents to understand the root cause more quickly, and resolve and fix incidents faster.  The format of this session will include best practices, challenge based labs, discussions and collaborative activities resulting in takeaways you can immediately apply to your accounts or organization's requirements. As these sessions are interactive and highly practical, the number of attendees is limited, Register Now to hold your spot! Agenda Topic and Labs  Alerts Concepts and Workflow Effective Alerting strategies  Establishing Baselines, SLO’s and Thresholds Use Cases and labs:  Alerting on SLAs and back end services Alerting on new applications or variable performance -Dynamic Baseline Alerting Alerting on Infrastructure conditions and Integration Providers Outlier detection and other NRQL Alerting use cases:  Multiple issues (static),  Synthetic performance (dynamic),  Outlier behavior (Outlier) Notifying the right team: Channels and Webhooks Lab: Webhook Challenge Alerts and Dashboarding Lab: Charting alerts Muting Alerts with Muting Rules Applied Intelligence  Proactive Detection Notifications and Analyzing Anomalies  Lab: Configure Anomaly notification channel Incident Intelligence Building Decisions Configuring Sources, Destinations and Pathways About this workshop More live training sessions coming soon. Want to know more about alerting? In this highly practical and engaging 2 hour session we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs you’ll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  You'll get to work with Applied Intelligence alerting and learn how to make use of Proactive Detection and Incident Intelligence to reduce alert noise, correlate incidents to understand the root cause more quickly, and resolve and fix incidents faster.  The format of this session will include best practices, challenge based labs, discussions and collaborative activities resulting in takeaways you can immediately apply to your accounts or organization's requirements. As these sessions are interactive and highly practical, the number of attendees is limited, Register Now to hold your spot! Agenda Topic and Labs  Alerts Concepts and Workflow Effective Alerting strategies  Establishing Baselines, SLO’s and Thresholds Use Cases and labs:  Alerting on SLAs and back end services Alerting on new applications or variable performance -Dynamic Baseline Alerting Alerting on Infrastructure conditions and Integration Providers Outlier detection and other NRQL Alerting use cases:  Multiple issues (static),  Synthetic performance (dynamic),  Outlier behavior (Outlier) Notifying the right team: Channels and Webhooks Lab: Webhook Challenge Alerts and Dashboarding Lab: Charting alerts Muting Alerts with Muting Rules Applied Intelligence  Proactive Detection Notifications and Analyzing Anomalies  Lab: Configure Anomaly notification channel Incident Intelligence Building Decisions Configuring Sources, Destinations and Pathways © 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.96589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Effective <em>Alerting</em> with New Relic",
        "sections": "In this engaging FREE 2 hour session we move beyond basic <em>alerts</em> to implementing an effective <em>alerting</em> strategy, and create <em>alerts</em> which surface issues that are important to you. With scenario based labs you’ll create specific policies and conditions for typical use cases across the full stack, use ",
        "body": " behavior (Outlier) Notifying the right team: Channels and Webhooks Lab: Webhook Challenge <em>Alerts</em> and Dashboarding Lab: Charting <em>alerts</em> Muting <em>Alerts</em> with Muting Rules Applied Intelligence  Proactive Detection Notifications and Analyzing Anomalies  Lab: Configure Anomaly <em>notification</em> <em>channel</em> Incident Intelligence Building Decisions Configuring Sources, Destinations and Pathways © 2020 powered by"
      },
      "id": "5f7f37f564441f79493f15a1"
    },
    {
      "nodeid": 40926,
      "sections": [
        "Recent Announcements",
        "Issue summary and analysis in Applied Intelligence"
      ],
      "title": "Issue summary and analysis in Applied Intelligence",
      "type": "docs",
      "external_id": "6a03b1c31cb3c9c6f3a9951eb330f64aa85b8898",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/whats_up_ai_summary.png",
      "url": "https://docs.newrelic.com/whats-new/issue-summary-analysis-applied-intelligence",
      "published_at": "2020-11-22T01:10:30Z",
      "updated_at": "2020-10-14T11:08:34Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "When trying to find the root cause of an issue, access to contextual information is crucial. Knowing that, we’ve made it easier to find relevant issue information and analysis. The issue summary provides bottom-line insights to get you information faster. Depending on the issue, it can contain up to four sections: Analysis summary: Surfaces related components and SRE golden signals (for example, error rate, throughput, saturation, and latency) Suggested responder: Suggests the most relevant responders who can help to resolve the issue Impacted entities: Shows a summary of any entities we monitor with one-click access to anomaly analysis if you’ve configured Proactive Detection Labels sets: Shows incidents from third-party sources (for example, PagerDuty, AWS CloudWatch, etc.) With these updates to the issue summary and analysis, more information is always a click away.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.518745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to four sections: Analysis summary: Surfaces related components and SRE <em>golden</em> <em>signals</em> (for example, error rate, throughput, saturation, and latency) Suggested responder: Suggests the most relevant responders who can help to resolve the issue Impacted entities: Shows a summary of any entities we"
      },
      "id": "5f86dc32196a67fd7cbd5388"
    },
    {
      "nodeid": 37421,
      "sections": [
        "Applied intelligence",
        "Proactive detection",
        "Incident intelligence",
        "Incident workflows",
        "Proactive Detection with Applied Intelligence",
        "Why it matters",
        "How it works",
        "Requirements",
        "Set up Proactive Detection",
        "Mute notifications (Slack only)",
        "Use Proactive Detection Slack messages",
        "View Anomaly overview UI",
        "Use anomaly events with NRDB",
        "Send Proactive Detection events to Incident Intelligence",
        "Webhook payload and examples",
        "Data limits",
        "For more help"
      ],
      "title": "Proactive Detection with Applied Intelligence",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "Applied intelligence",
      "external_id": "c4b5a2b1288ec80d3f45508b73d0ed3f595af064",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/proactive-detection-applied-intelligence",
      "published_at": "2020-11-21T20:03:47Z",
      "updated_at": "2020-11-07T19:35:49Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / Applied intelligence / Proactive detection",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how Proactive Detection notifies you of unusual app behavior. Get notified in Slack or set up a custom webhook.",
      "body": "With Applied Intelligence's Proactive Detection, you can be notified of unusual app behavior and access an automatic analysis of this unusual behavior. You can have notifications for anomalies delivered in Slack, or you can set up a webhook to deliver messages when you need them. These events are automatically available in NRDB for dashboarding, alerting, and integration with Incident Intelligence. Why it matters With Proactive Detection, Applied Intelligence delivers insights about anomalies in your production system, along with an automatic analysis of the anomaly. When an anomaly is detected, you can view it in an overview of anomalies, or we'll send notifications directly to your Slack channel or a webhook. How it works Proactive Detection uses the following methods to detect anomalies in your app data: Proactive Detection monitors metric data reported by an APM agent, building a model of your typical application dynamics, and focuses on key golden signals: throughput, response time, and errors. If one of these golden signals shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates models based on new data. Receiving notifications: We send notifications when we detect anomalous changes in throughput, error rate, or response time. The notifications are sent to selected Slack channels, or sent via webhook. When the anomaly goes back to normal, a recovery message is sent. If you don't want to receive notifications, you can choose to just save the events to NRDB. Anomaly analysis: For each anomaly, we provide a link in Slack to an analyze anomaly page. This page generates automatic insights into the anomaly. The page is also available from the anomaly overview page, which lists all recent anomalies. This page uses your existing APM and Proactive Detection data to provide explanations as to the cause of the anomaly. Activity stream: Inside the activity stream on the New Relic One homepage and the APM Summary page you will see relevant anomalies for applications that you've configured with Proactive Detection. Clicking on any of the anomaly events in the activity stream will bring up the analysis page for that anomaly. Applications will not always generate anomalies, so it can be normal to not receive any detections. Requirements To use Proactive Detection, ensure you have: An APM agent installed on applications to monitor To receive notifications in Slackthe Applied Intelligence Slack application installed into your Slack workspace by an IT administrator. For more details, see Data limits. Set up Proactive Detection You can configure this feature in the Proactive Detection UI: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection to go to Configuration. Click Add a configuration. Input the following information into the form: Choose a name for your configuration that helps you easily identify it from others in your account. Select an account. Select up to 1,000 applications. Note that certain applications with low throughput might not be good candidates for Proactive Detection, as they can be more sensitive to smaller amounts of data fluctuation. Select the golden signals you would like to monitor for anomalies. Set up for Slack To use Proactive Detection with Slack: Select Slack. Choose which Slack channel receives notifications. You can select any existing public or private channel. This prompts the workflow to add the Applied Intelligence Slack application to your selected channel. To create a new channel, do that directly in Slack first. If you experience an error when assigning Slack channels, make sure that the New Relic AI Slack application has been added to your Slack workspace. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up for webhooks To use Proactive Detection with webhooks: Select Webhook. Input the following information into the form: Provide the webhook URL. Provide optional custom headers. Choose to edit the custom payload, or enable using the default payload. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up without notifications To use Proactive Detection when you don't need to receive notifications: Select No notifications. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Mute notifications (Slack only) In Slack, detections coming from specific applications can be muted temporarily or permanently. The entire channel can also be muted temporarily. This is useful in the case of an incident or when the channel should otherwise not be interrupted. To mute in Slack, select Mute this app’s warnings or Mute all warnings, then select the duration. We will resume sending notifications for any detections once the muting duration has completed. Muting an application permanently removes it from the configuration. To add it back in, go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection, and select the configuration to edit. Muting Proactive Detection notifications does not affect alerts. Use Proactive Detection Slack messages Each anomaly message has several key pieces of information you can use to learn more about and start troubleshooting the potential issue: The application name and a link to more information about it in New Relic One. The metric experiencing an anomaly and a link to its details in New Relic One. A graph of the metric over time to provide a visual understanding of the anomaly’s behavior and degree. An Analyze button that navigates to an analysis page in Applied Intelligence that identifies key attributes that are unique to the anomaly, anomalies found upstream or downstream, and any other relevant signals. Once an anomaly has returned to normal, we send a recovery notification with the option to provide feedback. Your feedback provides our development team with input to help us improve detection quality. In the case of feedback provided on throughput anomalies, an evaluation is run each hour based on feedback to fit a more suitable model. If we helped you, you can select Yes or No. View Anomaly overview UI In addition to notifications for anomalies that give you information via Slack or webhook, Proactive Detection also includes a UI view with more information about the anomalies in your environment. This provides a list of all the recent anomalies from every configuration in the selected account. You can also select each anomaly to view a detailed analysis. Use anomaly events with NRDB Once you configure Proactive Detection, anomaly events will be sent to New Relic’s database (NRDB). You can query NRDB for Proactive Detection anomaly events and use them in conjunction with other Applied Intelligence tools. Query for Proactive Detection events from NRDB You can use NRQL to query NRDB for any Proactive Detection events recorded over the previous 7 days: FROM ProactiveDetection SELECT * Attribute Description anomaly.deliveredAt Number The time at which the anomaly event was initially recorded, in epoch milliseconds. Example: 1584366819000 anomaly.description String A brief description of the anomaly event. Example: Non-web throughput has returned to normal anomaly.endedAt String The time at which the anomalous period ended, in epoch milliseconds. Example: 1584366819000 anomaly.startedAt Number The time at which the anomalous period began, in epoch milliseconds. Example: 1584366819000 anomaly.type The type of data that was analyzed, including error_rate, response_time.web, response_time.non_web, throughput.web, or throughput.non_web. anomaly.status The state of the anomaly as the NRDB event is inserted, including open or close. anomaly.uuid A unique identifier for the NRDB anomaly event. Example: 4ee3b908-d323-4677-94c8-339762c931bc anomaly.id ID of the anomaly associated with the event. Example: 56341b5608bf68e1 entity.accountId Number The ID of the account for the entity. entity.domain Enum The domain for the entity. Example: APM entity.domainId String The id used to uniquely identify the entity within the domain. entity.guid String The guid used to uniquely identify the entity across all products. entity.name String The name of the entity. Example: Laura's coffee service Send Proactive Detection events to Incident Intelligence You can send Proactive Detection events to Incident Intelligence to be processed and correlated with other activity in your system: Create an alert condition for your NRQL query that pulls proactive detection events from NRDB. Configure a new incident intelligence source for your condition. (Optional) Create Decision logic to correlate future anomalies with related events. Webhook payload and examples Proactive Detection sends the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Proactive Detection, use these examples of the webhook body format and JSON schema. Attribute Description category Enum The category of data that was analyzed. Categories include web throughput, non-web throughput, web transactions, non-web transactions, and error class. data List The time series data leading up to the detection. data[].timestamp Number The timestamp of the data point in epoch milliseconds. Example: 1584366819000 data[].unit String The unit describing the value of the data point. Data units include count, milliseconds, and error_rate. data[].value Number The value of the data point. Example: 1.52 detectionType Enum The type of data that was analyzed. Types include latency, throughput, and error_rate. entity Object The entity that reported the unusual data. entity.accountId Number The ID for the entity's account. entity.domain Enum The domain for the entity. Example: APM entity.domainId String The id used to uniquely identify the entity within the domain. entity.guid String The guid used to uniquely identify the entity across all products. entity.name String The name of the entity. Example: Laura’s coffee service entity.link String A link to view the entity. Example: https://rpm.newrelic.com/accounts/YOUR_ACCOUNT_ID/applications/987654321” severity Enum A description of how unusual of a change occurred, including NORMAL, WARNING, or CRITICAL. version String Version used to describe the data being provided. Example: v1 JSON schema example Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). Template: { \"version\": \"{{version}}\", \"entity\": { \"type\": \"{{entity.type}}\", \"name\": \"{{entity.name}}\", \"link\": \"{{entity.link}}\", \"entityGuid\": \"{{entity.entityGuid}}\", \"domainId\": \"{{entity.domainId}}\", \"domain\": \"{{entity.domain}}\", \"accountId\": {{entity.accountId}} }, \"detectionType\": \"{{detectionType}}\", \"category\": \"{{category}}\", \"data\": [{{#each data}} { \"value\": {{value}}, \"unit\": \"{{unit}}\", \"timestamp\": {{timestamp}} } {{#unless @last}},{{/unless}} {{/each}}] } Sample payload: { \"version\": \"v1\", \"entity\": { \"type\": \"APPLICATION\", \"name\": \"My Application\", \"link\": \"https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/123\", \"entityGuid\": \"foo\", \"domainId\": \"123\", \"domain\": \"APM\", \"accountId\": YOUR_ACCOUNT_ID }, \"detectionType\": \"metric\", \"category\": \"web throughput\", \"severity\": \"CRITICAL\", \"data\": [ { \"value\": 100, \"unit\": \"count\", \"timestamp\": 1584047560917 } , { \"value\": 99, \"unit\": \"count\", \"timestamp\": 1584047620917 } , { \"value\": 0, \"unit\": \"count\", \"timestamp\": 1584047680917 } ] } Data limits In addition to requirements, data limits include: APM app transactions per month: up to 100 million included free Monitored APM applications: limited to 1,000 per configuration Slack configurations: limited to 200 per account Webhook configurations: limited to 200 per account Configurations without notifications: limited to 200 per account For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.839355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Mute <em>notifications</em> (Slack only)",
        "info": "Read about how Proactive Detection <em>notifies</em> you of unusual app behavior. Get <em>notified</em> in Slack or set up a custom webhook.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "body": " a model of your typical application dynamics, and focuses on key <em>golden</em> <em>signals</em>: throughput, response time, and errors. If one of these <em>golden</em> <em>signals</em> shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates",
        "breadcrumb": "Contents &#x2F; <em>Alerts</em> and Applied Intelligence &#x2F; Applied intelligence &#x2F; Proactive detection"
      },
      "id": "5f344fad196a6775d3fbd704"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.29745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": "Automate workflows When building today&#x27;s complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including <em>Terraform</em>, AWS"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "nodeid": 40951,
      "sections": [
        "Recent Announcements",
        "New Relic One now has a new UI for OpenTelemetry"
      ],
      "title": "New Relic One now has a new UI for OpenTelemetry",
      "type": "docs",
      "external_id": "50b2de1ac4518571388a57bbe1824f477b7faf8d",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/whats_up_opentelemetry.png",
      "url": "https://docs.newrelic.com/whats-new/new-relic-one-now-has-new-ui-opentelemetry",
      "published_at": "2020-11-21T20:55:39Z",
      "updated_at": "2020-10-14T11:09:53Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "New Relic One now has a UI dedicated to providing full APM functionality for your OpenTelemetry data. With this curated experience, you can find the root cause of incidents quickly, and optimize the performance of your applications and services. Send your OpenTelemetry data to New Relic using one of the OpenTelemetry exporters and quickly discover and analyze your data using one of these key pages: Entity Explorer: The entity explorer gives you a unified view of every entity so you can see everything you monitor in one place and quickly zoom into what you care about most. Summary page: The summary page provides an overview of “golden signals” for a service or application, such as response time, throughput, and error rate. Transactions page: Use the APM transactions page to identify transactions that might be causing the problem. Distributed Tracing: With distributed tracing, you can get an end-to-end view of a single request across your services and quickly identify slow and error traces. Externals: The external services page captures calls to out-of-process services such as web services, resources in the cloud, and other network entities. Databases: The databases page shows an application’s database and cache data with charts to view throughput, response time and operations. Metric explorer: Use the metrics explorer to view your metrics and facet by various dimensions and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.094185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": The summary page provides an overview of “<em>golden</em> <em>signals</em>” for a service or application, such as response time, throughput, and error rate. Transactions page: Use the APM transactions page to identify transactions that might be causing the problem. Distributed Tracing: With distributed tracing, you can get"
      },
      "id": "5f86dc8128ccbc36e51e676b"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " <em>Relic</em> One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.493286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly <em>tag</em> resources Add <em>tags</em> to apps for easy filtering 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up <em>New</em> <em>Relic</em> using"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Important",
        "Bonus step: Create a deployment marker",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:33:56Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: bash Copy $ sudo snap install newrelic-cli macOS With Homebrew installed, run: bash Copy $ brew install newrelic-cli Windows With Scoop installed, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.2462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "&#x27;, }, ]; Copy Step 6 of 10 Add a simple <em>tag</em> to your application Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using entity <em>tags</em> delete). Let&#x27;s suppose that you"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 38406,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Configure",
        "Metric format",
        "Metric types",
        "Add tags (attributes)",
        "Create alerts",
        "Find and use data",
        "Check the source code",
        "For more help"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "5d94989a9004778a43aba9fc5187b7904affc412",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/statsd-nrql-alert-condition-example-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2",
      "published_at": "2020-11-23T01:52:34Z",
      "updated_at": "2020-11-19T01:43:42Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Here are explanations of these fields: Field name Description <metric name> string Required. Name of the metric. <value> string Required. The metric type: c = counter g = gauge ms = timer @<sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. #<tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.00865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tags</em> (attributes)",
        "body": "-format data into <em>New</em> <em>Relic</em>. You can also add any arbitrary <em>tags</em> (key-value pairs) to your data. Once your metrics are in <em>New</em> <em>Relic</em>, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs"
      },
      "id": "5ece854928ccbc9dbdc13573"
    },
    {
      "category_2": "Label examples",
      "nodeid": 8916,
      "sections": [
        "Synthetics REST API",
        "Monitor examples",
        "Label examples",
        "Secure credentials examples",
        "Use Synthetics label APIs",
        "Requirements",
        "API examples",
        "For more help"
      ],
      "title": "Use Synthetics label APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Synthetics REST API",
      "external_id": "bbd777a90bfc7c2af48dfa8ff28aca91b4d7cb71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis",
      "published_at": "2020-11-22T00:06:23Z",
      "updated_at": "2020-11-22T00:06:23Z",
      "breadcrumb": "Contents / APIs / Synthetics REST API / Label examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Deprecated: Using the New Relic REST API to manage synthetic monitor labels. ",
      "body": "DEPRECATED On July 20, 2020, the New Relic One tagging functionality replaces synthetic labels and the ability to organize Synthetics and APM tags into groups. For more information, including how to migrate your existing tags through the UI or NerdGraph tagging API, see New Relic's Explorers Hub post. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls from the command line. You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'X-Api-Key:Admin_User_Key' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.18556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Deprecated: Using the <em>New</em> <em>Relic</em> REST API to manage synthetic monitor labels. ",
        "body": "DEPRECATED On July 20, 2020, the <em>New</em> <em>Relic</em> One tagging functionality replaces synthetic labels and the ability to organize Synthetics and APM <em>tags</em> into groups. For more information, including how to migrate your existing <em>tags</em> through the UI or NerdGraph tagging API, see <em>New</em> <em>Relic</em>&#x27;s Explorers Hub"
      },
      "id": "57036374e621f41ff8000162"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.22006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " <em>Relic</em> One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.10757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " the Kubernetes operator Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 30 min Getting started with <em>New</em> <em>Relic</em> and Terraform Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: bash Copy $ sudo snap install newrelic-cli macOS With Homebrew installed, run: bash Copy $ brew install newrelic-cli Windows With Scoop installed, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.96243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple <em>tags</em> to one of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal <em>API</em> <em>Key</em>: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "category_2": "Label examples",
      "nodeid": 8916,
      "sections": [
        "Synthetics REST API",
        "Monitor examples",
        "Label examples",
        "Secure credentials examples",
        "Use Synthetics label APIs",
        "Requirements",
        "API examples",
        "For more help"
      ],
      "title": "Use Synthetics label APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Synthetics REST API",
      "external_id": "bbd777a90bfc7c2af48dfa8ff28aca91b4d7cb71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis",
      "published_at": "2020-11-22T00:06:23Z",
      "updated_at": "2020-11-22T00:06:23Z",
      "breadcrumb": "Contents / APIs / Synthetics REST API / Label examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Deprecated: Using the New Relic REST API to manage synthetic monitor labels. ",
      "body": "DEPRECATED On July 20, 2020, the New Relic One tagging functionality replaces synthetic labels and the ability to organize Synthetics and APM tags into groups. For more information, including how to migrate your existing tags through the UI or NerdGraph tagging API, see New Relic's Explorers Hub post. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls from the command line. You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'X-Api-Key:Admin_User_Key' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.58469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Synthetics label <em>APIs</em>",
        "sections": "Synthetics REST <em>API</em>",
        "info": "Deprecated: Using the <em>New</em> <em>Relic</em> REST <em>API</em> to manage synthetic monitor labels. ",
        "category_0": "<em>APIs</em>",
        "category_1": "Synthetics REST <em>API</em>",
        "body": "DEPRECATED On July 20, 2020, the <em>New</em> <em>Relic</em> One tagging functionality replaces synthetic labels and the ability to organize Synthetics and APM <em>tags</em> into groups. For more information, including how to migrate your existing <em>tags</em> through the UI or NerdGraph tagging <em>API</em>, see <em>New</em> <em>Relic</em>&#x27;s Explorers Hub",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; Synthetics REST <em>API</em> &#x2F; Label examples"
      },
      "id": "57036374e621f41ff8000162"
    },
    {
      "category_2": "Maintenance",
      "nodeid": 3131,
      "sections": [
        "New Relic APM",
        "Getting started",
        "Guides",
        "Apdex",
        "Maintenance",
        "Troubleshooting",
        "Record and monitor deployments",
        "Options for tracking deployments",
        "Using a Personal API key with the REST API",
        "Record deployments with the REST API",
        "Record deployments using the New Relic agent",
        "Notify your team of deployments",
        "End of life notification: Hipchat, Campfire",
        "For more help"
      ],
      "title": "Record and monitor deployments",
      "category_0": "APM",
      "type": "docs",
      "category_1": "New Relic APM",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/apm/new-relic-apm/maintenance/record-monitor-deployments",
      "external_id": "c0440fa0da1980f7e22f7fdb5cb2f0e4bd721fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments",
      "published_at": "2020-11-21T23:46:56Z",
      "updated_at": "2020-11-15T09:46:29Z",
      "breadcrumb": "Contents / APM / New Relic APM / Maintenance",
      "document_type": "page",
      "popularity": 1,
      "info": "To set up deployment notifications for apps monitored by New Relic APM, use webhooks, APM agent-specific options, or New Relic's REST API.",
      "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app's performance. Tracking deployments creates deployment markers that appear in APM charts. Options for tracking deployments You can use the New Relic REST API v2 to record new deployments, retrieve a list of past deployments, and delete past deployments on your APM application. In addition, some APM agents have agent-specific methods to record deployments automatically. You can use your Slack integration with New Relic, or a simple webhook, to notify your team in real time of deployments for applications monitored by APM. Slack provides a webhook URL that allows you to post generic JSON that will appear formatted in a chosen Slack channel. There are a few places where you can view deployments in the New Relic UI after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, New Relic One Service summary, and entity summary pages. On APM performance charts as a chart marker. On the Deployments page for summary performance. Deployment markers are not available for Browser applications, but see Browser releases for a way to tag errors with release versions. Using a Personal API key with the REST API To use a Personal API key in any of the examples below, replace 'X-Api-Key','YOUR_API_KEY' with 'Api-Key','YOUR_PERSONAL_API_KEY'. Record deployments with the REST API You can use the New Relic REST API v2 to record deployments, get a list of past deployments, and delete deployments. The examples in this document use curl as a command line tool. However, you can use any method to make your REST requests. You can also create, view, and delete deployments with the API Explorer. JSON uses double quotes \" for element names and content. Using single quotes ' will cause errors. Record a deployment with POST To record a new deployment, send a POST request that includes your REST API key or Personal API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. For example: curl -X POST \"https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json\" \\ -H \"X-Api-Key:YOUR_API_KEY\" \\ -i \\ -H \"Content-Type: application/json\" \\ -d \\ '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Record a deployment with PowerShell To record a deployment with PowerShell, send a POST request that includes your REST API key or Personal API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. This example uses PowerShell version 3 or higher: Invoke-WebRequest -Uri https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json -Method POST -Headers @{'X-Api-Key'='YOUR_API_KEY'} -ContentType 'application/json' -Body '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' This example uses PowerShell version 2 (requires .NET framework 3.5 or higher): $encoding = [System.Text.Encoding]::GetEncoding(\"ASCII\") $data ='{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' $postData = $encoding.GetBytes($data) $request = [System.Net.WebRequest]::Create('https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json') $request.Method = 'POST' $request.Headers.add('X-Api-Key','YOUR_API_KEY') $request.ContentType='application/json' $stream = $request.GetRequestStream() $stream.Write($postData,0,$postData.Length) $request.GetResponse() View a list of deployments with GET To retrieve a list of all past deployments for your app, send a GET request that includes your REST API key or Personal API key to the deployments endpoint. GET requests do not use a JSON payload. For example: curl -X GET \"https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json\" \\ -H \"X-Api-Key:YOUR_API_KEY\" \\ -i Sample output from GET This example requests a list of deployments for app ID 9999999: curl -X GET \"https://api.newrelic.com/v2/applications/9999999/deployments.json\" \\ -H \"X-Api-Key:ABCDEFGHIJKLMNOPQRSTUVWXabcdefghijklmnopqrstuvwx\" \\ -i The API returns this list of deployments: HTTP/1.1 200 OK ETag: \"ABCDEFGHIJKabcdefghijk0123456789\" Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json { \"deployments\": [ { \"id\": 1234567, \"revision\": \"1234123412341234123412341234123412341234\", \"changelog\": \"Fixed the bugs for real this time\", \"description\": \"Example description two\", \"user\": \"Data Nerd\", \"timestamp\": \"2016-02-24T10:09:27-08:00\", \"links\": { \"application\": 9999999 } }, { \"id\": 2345678, \"revision\": \"7890789078907890789078907890789078907890\", \"changelog\": \"Think I fixed all the bugs\", \"description\": null, \"user\": \"Dren Atad\", \"timestamp\": \"2014-10-22T12:23:47-07:00\", \"links\": { \"application\": 9999999 } } ], \"links\": { \"deployment.agent\": \"/v2/applications/{application_id}\" } } Delete a deployment with DELETE To delete a deployment, send a DELETE request that includes your Admin User's API key to the deployments endpoint. DELETE requests do not use a JSON payload, but you must specify the ID for the deployment you want to delete. To retrieve the ID for a deployment, use the GET request. For example: curl -X DELETE \"https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments/DEPLOYMENT_ID.json\" \\ -H \"X-Api-Key:ADMIN_USERS_KEY\" \\ -i Character limits and JSON parameters The JSON payload can include the following parameters. UTF-8 4 byte characters, such as Emojis and some non-Latin language glyphs, cannot be used in the deployment text. Parameter Data type Description revision String, 127 character maximum Required. A unique ID for this deployment, visible in the Summary page and on the Deployments page. Can be any string, but is usually a version number or a Git checksum. changelog String, 65535 character maximum Optional. A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) > Change log. description String, 65535 character maximum Optional. A high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment. user String, 31 character maximum Optional. A username to associate with the deployment, visible in the Summary page and on the Deployments page. timestamp ISO 8601 Optional. When the deployment occurred, down to the second. If not specified, the deployment will be recorded at the time when the API call was received. Timestamp requirements: Must be in UTC time. Must be after the most recent deployment timestamp. Cannot be in the future. Must be in ISO8601 format; for example, \"2019-10-08T00:15:36Z\". Record deployments using the New Relic agent Some agents have additional methods to record deployments: All agents: Use the New Relic REST API v2. C: No SDK-specific methods. Use the REST API. Go: No agent-specific methods. Use the REST API. Java: Call the Java agent jar. .NET: Use PowerShell and the REST API. Node.js: No agent-specific methods. Use the REST API. PHP: Use a PHP script. Python: Use the record-deploy subcommand of the newrelic-admin script. Ruby: Use a Capistrano recipe. Notify your team of deployments Owners and Admins After a deployment is recorded using the REST API, you can optionally notify a webhook endpoint of the deployment. The destination of the webhook can be your Slack instance. To use webhooks to set up a deployment notification for a Slack channel: Log in to your Slack account as an admin, then go to App directory > Manage > Apps. Search for your New Relic app, then select Add configuration. From Post to channel, select an existing Slack channel or add a new channel, then Add configuration. From the list of options, copy the webhook URL. Go to one.newrelic.com > (account dropdown) > Account settings > Integrations > Deploy notifications > Webhook. Paste the Slack webhook URL, then save. Optional: Send a test message. You can also use webhooks, Slack channels, and other options for alert notifications with New Relic Alerts. End of life notification: Hipchat, Campfire As of September 9, 2019, integrations with Hipchat and Campfire for APM deployment notifications will no longer be available. Recommendation: If you are still using Hipchat or Campfire, use webhooks with Slack channels instead. For more information, see the New Relic Explorers Hub post. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.82242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Record and monitor <em>deployments</em>",
        "sections": "Record <em>deployments</em> using the <em>New</em> <em>Relic</em> agent",
        "info": "To set up <em>deployment</em> notifications for apps monitored by <em>New</em> <em>Relic</em> APM, use webhooks, APM agent-specific options, or <em>New</em> <em>Relic&#x27;s</em> REST <em>API</em>.",
        "category_1": "<em>New</em> <em>Relic</em> APM",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;apm&#x2F;<em>new</em>-<em>relic</em>-apm&#x2F;maintenance&#x2F;record-monitor-<em>deployments</em>",
        "body": " after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, <em>New</em> <em>Relic</em> One Service summary, and <em>entity</em> summary pages. On APM performance charts as a chart <em>marker</em>. On the Deployments page for summary performance. <em>Deployment</em> <em>markers</em> are not available",
        "breadcrumb": "Contents &#x2F; APM &#x2F; <em>New</em> <em>Relic</em> APM &#x2F; Maintenance"
      },
      "id": "5d88eb2f28ccbcc2249cb197"
    }
  ],
  "/terms": [
    {
      "category_2": "FAQ",
      "nodeid": 39516,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing plan: Frequently asked questions",
        "Frequently asked questions",
        "For more help"
      ],
      "title": "New Relic One pricing plan: Frequently asked questions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "6dedf2639c075dbb140ce0cbf69bef8ad15b16a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/faq/new-relic-one-pricing-plan-frequently-asked-questions",
      "published_at": "2020-11-21T17:24:43Z",
      "updated_at": "2020-11-21T17:24:43Z",
      "breadcrumb": "Contents / Licenses / License information / FAQ",
      "document_type": "page",
      "popularity": 1,
      "body": "These are frequently asked questions about the New Relic One pricing plan. Frequently asked questions Q: Where can I find more information about New Relic One and related Products? A: For a high level description of user entitlements for Telemetry Data Platform, Full Stack Observability (Standard, Pro, and Enterprise; also referred to as full users), and AI, please visit our pricing page. Q: Is there a limit on the number of concurrent sessions or IP addresses that may be used with a user account? A: Yes. The current limits are described in Manage users. Q: What terms govern my use of the Products? A: If a Customer has paid New Relic during a rolling 12-month period, then Customer’s usage of the Products is covered by the Paid Terms of Service. If a Customer has not paid New Relic during a 12-month period, then Customer’s usage of the Products is covered by the Unpaid Terms of Service. Q: How are the number of Monthly Provisioned Users (full users) calculated for each month? A: Please see Calculation details. Q: Can I mix and match New Relic One Standard, Pro, and Enterprise users in a billing account? A: No. You can only select one type of New Relic One User per billing account ID. Q: If I am an existing customer under the product-based pricing plan, I purchased extended retention, and I move to New Relic One-based pricing, will I lose my extended retention benefits? A: Unless otherwise stated in an Order, Customers that previously purchased extended retention for their products under the product-based pricing plan (i.e., New Relic Insights Pro and/or New Relic Logs) have access to that same level of extended retention under New Relic One-based pricing for its initial New Relic One term at no additional cost. Customers that did not previously purchase extended retention for their products under the original, product-based pricing plan have the default retention per the Documentation and may purchase extended retention. Q: Can Event extended retention, additional Synthetics Checks, or additional New Relic Edge data be added to my account? A: For additional retention for Events or Logs beyond the Standard Data Retention, contact your New Relic Account Executive. Note: Minimum requirement for Extended Retention is that the Customer must have a Annual Pool of Funds subscription which includes all of the following: Telemetry Data Platform, Full Stack Observability Pro or above. Telemetry Data Platform Pricing is affected. Q: What is included in New Relic's Free Tier of Products? A: Please see this page for a description of what's included. Customer’s use of the Free Tier shall be governed by the terms and conditions described in the Unpaid Terms of Service. If Customer’s usage exceeds the Free Tier, Customer is fully responsible for fees incurred in excess of the Free Tier as described in the “Pay As You Go” program and as described in the Paid Terms of Service. Q: How does the ‘Free Tier’ impact my PAYG or Annual Pool of Funds subscription? A: The Free Tier usage will be deducted automatically from the Monthly Product Usage for Pay As You Go or Annual Pool of Funds subscriptions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 467.5255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Observability Pro or above. Telemetry Data Platform Pricing is affected. Q: What is included in New Relic&#x27;s Free Tier of Products? A: Please see this page for a description of what&#x27;s included. Customer’s use of the Free Tier shall be governed by the <em>terms</em> and <em>conditions</em> described in the Unpaid <em>Terms</em>"
      },
      "id": "5f33be9b196a67b12dfbd71d"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions."
      ],
      "published_at": "2020-11-23T01:54:13Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2020-10-31T02:00:32Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (“New Relic”). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 370.55118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "category_2": "Developer Edition",
      "nodeid": 39641,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Developer Program Resources",
        "For more help"
      ],
      "title": "Developer Program Resources",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "98308cfffa652e4c25967e1be5b848b9c28ca410",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources",
      "published_at": "2020-11-22T00:35:45Z",
      "updated_at": "2020-08-08T19:17:02Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / Developer Edition",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic Developer edition policy",
      "body": "As a customer, you are eligible to participate in New Relic’s Developer Program. Additional information and resources are available at New Relic’s Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 308.5496,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your"
      },
      "id": "5f338507e7b9d2f670c9de83"
    },
    {
      "category_2": "New Relic One",
      "nodeid": 39366,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Preview access for New Relic One",
        "For more help"
      ],
      "title": "Preview access for New Relic One",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "eae3865081d3bd8ad2dd8b6eaf0fe0147355360c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one",
      "published_at": "2020-11-21T17:33:45Z",
      "updated_at": "2020-07-31T04:41:27Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / New Relic One",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 305.90884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "5f23a0f7e7b9d29da9c82305"
    },
    {
      "category_2": "Product definitions",
      "nodeid": 39646,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing: Definitions",
        "For more help"
      ],
      "title": "New Relic One pricing: Definitions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "097fc095ef18942f3af1845237742340e36416b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions",
      "published_at": "2020-11-21T15:20:50Z",
      "updated_at": "2020-09-10T14:58:10Z",
      "breadcrumb": "Contents / Licenses / License information / Product definitions",
      "document_type": "page",
      "popularity": 1,
      "info": "This document provides definitions of terminology you may see in New Relic contracts.",
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer’s websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‘Documentation’ page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer’s Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic’s customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 275.9635,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "This document provides definitions of <em>terminology</em> you may see in New Relic contracts.",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "5f23b039196a67030b94f5c4"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.18481,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " solutions in our Developer Toolkit. Guides to <em>automate</em> workflows 5 min Quickly <em>tag</em> resources Add tags to apps for easy filtering 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> See how easy it is to leverage automation in <em>your</em> DevOps environment! 20 min Set up New Relic using"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Label examples",
      "nodeid": 8916,
      "sections": [
        "Synthetics REST API",
        "Monitor examples",
        "Label examples",
        "Secure credentials examples",
        "Use Synthetics label APIs",
        "Requirements",
        "API examples",
        "For more help"
      ],
      "title": "Use Synthetics label APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Synthetics REST API",
      "external_id": "bbd777a90bfc7c2af48dfa8ff28aca91b4d7cb71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis",
      "published_at": "2020-11-22T00:06:23Z",
      "updated_at": "2020-11-22T00:06:23Z",
      "breadcrumb": "Contents / APIs / Synthetics REST API / Label examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Deprecated: Using the New Relic REST API to manage synthetic monitor labels. ",
      "body": "DEPRECATED On July 20, 2020, the New Relic One tagging functionality replaces synthetic labels and the ability to organize Synthetics and APM tags into groups. For more information, including how to migrate your existing tags through the UI or NerdGraph tagging API, see New Relic's Explorers Hub post. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls from the command line. You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'X-Api-Key:Admin_User_Key' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.33041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "DEPRECATED On July 20, 2020, the New Relic One <em>tagging</em> functionality replaces synthetic labels and the ability to organize Synthetics and APM tags into groups. For more information, including how to migrate <em>your</em> existing tags through the UI or NerdGraph <em>tagging</em> API, see New Relic&#x27;s Explorers Hub"
      },
      "id": "57036374e621f41ff8000162"
    },
    {
      "category_2": "Full-stack observability",
      "nodeid": 14056,
      "sections": [
        "Best practices guides",
        "Telemetry data platform",
        "Full-stack observability",
        "Alerts and Applied Intelligence",
        "APM best practices guide",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "For more help"
      ],
      "title": "APM best practices guide",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "Best practices guides",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide",
      "external_id": "7c83791f0021bce381d9095b37b90259b9115c32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide",
      "published_at": "2020-11-21T17:20:49Z",
      "updated_at": "2020-11-11T22:53:30Z",
      "breadcrumb": "Contents / Solutions and best practices / Best practices guides / Full-stack observability",
      "document_type": "page",
      "popularity": 1,
      "info": "Here are some best practices designed to help you become a New Relic APM master and a key asset to your team.",
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master—and a key asset to your team! To get a high-level overview of all your applications and services, use the entity explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name tag) and \"test\" (environment tag). In the APM agent configuration settings files, use the labels field to add tags to your data. For example, see this description of the Python labels setting. APM is designed so that apps can roll up into an unlimited number of meaningful tag categories. How to do it Read the overview: Use tags to organize and group what you monitor. Follow these instructions for creating tags: NerdGraph tagging API tutorial. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application’s historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, apps monitored by New Relic APM or New Relic Browser, hosts monitored by New Relic Infrastructure, and so on) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends—all great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic’s SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization’s SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.85911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "2. Add <em>tags</em> to <em>your</em> applications",
        "info": "Here are some best practices designed to help you become a New Relic APM master and a key asset to <em>your</em> team.",
        "category_2": "Full-<em>stack</em> observability",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;new-relic-solutions&#x2F;best-practices-guides&#x2F;full-<em>stack</em>-observability&#x2F;apm-best-practices-guide",
        "body": " systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to <em>automate</em> <em>your</em> <em>entire</em> deployment and management process. How to do it Regularly review which version of the agent you&#x27;re using so that you know when an update",
        "breadcrumb": "Contents &#x2F; Solutions and best practices &#x2F; Best practices guides &#x2F; Full-<em>stack</em> observability"
      },
      "id": "5f91fa75e7b9d20b7d3c9f80"
    },
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.07502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Automate</em> common tasks",
        "body": " Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min <em>Automate</em> common tasks Use the New Relic CLI to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to <em>your</em> app Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Workloads",
      "nodeid": 39081,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Use workloads",
        "Create a workload",
        "Use the API",
        "For more help"
      ],
      "title": "Use workloads",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "ceb8cc0a7f379f735e0a0fee73f4456837868f91",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-one-workloads-numbered_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads",
      "published_at": "2020-11-21T19:12:01Z",
      "updated_at": "2020-11-18T15:53:29Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Workloads",
      "document_type": "page",
      "popularity": 1,
      "info": "In New Relic, use workloads to group together entities that make up a specific business service, making it easier to isolate and troubleshoot issues.",
      "body": "To view workloads, go to one.newrelic.com and click on Apps on the left corner. In Apps, select the Workloads launcher, and then choose a specific workload. A Workload looks like this: Important components in the New Relic One workload UI. The screenshot numbers are important parts of the workload UI we'd like to describe to you: The Overview tab shows the most relevant entity performance and alert data that you need to operate the workload. View of workload components. This is useful for understanding the workload’s architecture, especially if the workload’s entities change over time because they are dynamically defined. Important charts. These are charts with key metrics for each entity type, such as number of requests, response time and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). Workload status. You can configure the status to inform about how your workload is performing, based on the individual alerting status of the entities in your workload. Open violations. You can filter the workload to only the alerting entities to make it easier to troubleshoot the most important issues. Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. The Entities tab shows the entities that make up the workload. If you’ve used queries to dynamically select entities, the entity list will change over time. Edit workload. Edit the workload to define the entities that are part of the workload and to link dashboards to the workload. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's guid, account ID, and App ID. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Apps > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click the Workloads launcher, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like app name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.051285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize <em>your</em> use of workloads, it helps to have a good entity-<em>tagging</em> strategy. We recommend reading the <em>tagging</em> documentation. How the dynamic query logic"
      },
      "id": "5f246157196a67553f94f5cd"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 303.22937,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " to <em>query</em> <em>data</em> from your account and <em>add</em> it to a dropdown menu in an application 45 min <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min <em>Add</em> a time"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorage</em>",
        "sections": "Intro to <em>NerdStorage</em>",
        "info": "Intro to <em>NerdStorage</em> on New Relic One",
        "tags": "<em>nerdstorage</em>",
        "body": " document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of <em>data</em> associated with it. <em>Data</em> associated with a document: <em>NerdStorage</em> accepts any sort of <em>data</em> associated to a documentId. <em>Query</em> and mutation components that are provided work by serializing"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.45355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding New Relic into your CI&#x2F;CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery",
        "This site uses cookies 🍪"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:44:09Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.019516,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> and store <em>data</em>",
        "sections": "<em>Query</em> and store <em>data</em>",
        "info": "Reference guide for SDK <em>query</em> components using NerdGraph",
        "tags": "nerdgraph <em>query</em> components",
        "body": ", EntityByGuid<em>Query</em>, EntityByName<em>Query</em>. Storage queries: New Relic One provides a simple storage mechanism that we call <em>NerdStorage</em>. This can be used by Nerdpack creators to store application configuration setting <em>data</em>, user-specific <em>data</em>, and other small pieces of <em>data</em>. Components in this category"
      },
      "id": "5efa989e28ccbc2f15307deb"
    },
    {
      "image": "https://opensource.newrelic.com/static/New_Relic_One_Catalog_Project-044e387f68b03896ff65f46edcffb1f3.png",
      "url": "https://opensource.newrelic.com/oss-category/",
      "sections": [
        "Categories",
        "Community Project",
        "Requirements",
        "Community Plus",
        "New Relic One Catalog",
        "Example Code",
        "New Relic Experimental",
        "Archived"
      ],
      "published_at": "2020-11-23T01:54:13Z",
      "title": "New Relic Open Source Categories",
      "updated_at": "2020-10-31T02:02:17Z",
      "type": "opensource",
      "external_id": "87c1876d27bdde7fb6636382fb5e659ae47c496a",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards Categories Community Project Community Plus New Relic One Catalog Example Code New Relic Experimental Archived For the code snippets that appear in the project's README file, see this documentation. Community Project This code is developed in the open with input from the community through issues and PRs. There is an active maintainer team within New Relic, troubleshooting support in the New Relic Explorers Hub, and the documentation is available in the project repository. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Has active maintainer / maintainers, including at least one Relic Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline Community Plus This code is developed in the open with input from the community through issues and PRs. A New Relic engineering team serves as the maintainer. Troubleshooting support is available in the New Relic Explorers Hub, and documentation is available in the project repository and docs.newrelic.com. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Is maintained by a New Relic engineering team Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub For additional details on support options, see the Open Source Support Policy Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline New Relic One Catalog This code is a part of the New Relic One Catalog. It meets the criteria for a Community Project; but it also contains UI workflows for configuration. Most Catalog projects seek to maintain a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration data that is stored in NerdStorage Architectural review (including UX) by New Relic (Optional) maintains a public roadmap (recommended via a GitHub project in the repo) Example Code This code demonstrates an aspect of building on the New Relic One platform. Find the complete description of its usage and other relevant docs in the README. There is no long-term maintainer for this code nor is support provided, but the author(s) may address future updates / needs as platform features change. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file (optional) Issues are available at the project author's discretion Documentation reviewed by the New Relic documentation team Linted code New Relic Experimental This code solves an interesting problem but does not yet have an active maintainer(s). The project is being developed in the open for the purpose of feedback on a new feature or function. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Typically hosted in the New Relic Experimental GitHub org (Optional) Issues at the project owner's discertion Archived This code is read-only. There is neither a maintainer team nor support. Requirements Complies with New Relic's legal requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Previous references to Support should be modified or removed from the README Project is read-only and available for cloning only",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.687355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration <em>data</em> that is stored in <em>NerdStorage</em> Architectural review (including"
      },
      "id": "5f31822228ccbc916988dff8"
    }
  ],
  "/build-apps/add-time-picker-guide": [
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.2518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " Relic One <em>app</em> 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 20 min Add a <em>time</em> <em>picker</em> to your <em>app</em> Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.639114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " <em>picker</em> to your <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to New Relic One 30 min Add a table to your <em>app</em> Add a table to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.27063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": " be divided into these categories: <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "category_2": "New Relic for iOS release notes",
      "nodeid": 8411,
      "sections": [
        "Mobile apps release notes",
        "New Relic for Android release notes",
        "Insights for tvOS release notes",
        "New Relic for iOS release notes",
        "Insights for Android release notes",
        "Insights for iOS release notes",
        "New Relic for iOS 3.20.3",
        "New Relic for iOS 3.55.0",
        "Improvements",
        "Bug fixes",
        "New Relic for iOS 3.54.0",
        "New features",
        "New Relic for iOS 3.53.1",
        "Notes",
        "New Relic for iOS 3.53.0",
        "New Relic for iOS 3.52.1",
        "New Relic for iOS 3.51.1",
        "New Relic for iOS 3.50.0",
        "New Relic for iOS 3.49.0",
        "New Relic for iOS 3.48.0",
        "Pages"
      ],
      "title": "New Relic for iOS 3.20.3",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Mobile apps release notes",
      "external_id": "a266a331e9c78e3af9160c97be2d58be684a96cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-apps-release-notes/new-relic-ios-3203?page=0%2C1",
      "published_at": "2020-11-23T00:40:19Z",
      "updated_at": "2020-11-23T00:40:18Z",
      "breadcrumb": "Contents / Release notes / Mobile apps release notes / New Relic for iOS release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Items per page 5 10 New Relic for iOS 3.55.0 Thursday, April 23, 2020 - 06:00 Download Improvements Improved time picker with custom start and end time selection Added time picker to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards Fixed a crash that sometimes occurred on the iPad Fixed a crash that occurred sometimes on error charts with no data New Relic for iOS 3.54.0 Thursday, April 9, 2020 - 09:00 Download New features View New Relic dashboards Added detailed pages that include new chart tooltip and legend behavior Landscape support for widgets New Relic for iOS 3.53.1 Friday, February 21, 2020 - 08:49 Download Notes 3.53.1 is a hot fix for 3.53.0 which has an improved Mobile APM Http Errors view, to allow you to facet & filter down to the errors you care about. Bug fixes Fixes crash that sometimes occurred when viewing line charts with multiple elements. New Relic for iOS 3.53.0 Wednesday, November 20, 2019 - 15:30 Download Notes We now have an improved Mobile APM Http Errors view, to allow you to facet & filter down to the errors you care about. New features New Mobile APM HTTP Errors view Improvements Added support for Radar in context 'event' anomalies Bug fixes Fixed a crash that sometimes occurred when viewing charts Fixed a crash that sometimes appeared when trying to login Fixed a crash that occurred rarely in the monitors page New Relic for iOS 3.52.1 Tuesday, November 12, 2019 - 09:00 Download Notes Support for iOS 13 dark mode!!! New features Dark mode support for iOS 13 New crashes tab in Mobile APM, with improved grouping, searching and filtering Added in Synthetics monitors to the iPad Improvements Fix for showing a retry login popup when we shouldn't be Enable auto resizing of the y axis in charts, to scale to the visible time window Update APM app error rate to reflect the web New Relic for iOS 3.51.1 Friday, September 13, 2019 - 14:30 Download Notes The New Relic app is even better with an improved home screen, displaying all your favorite services, hosts, mobile and browser apps, key transactions, and more. This enhanced landing page also allows you to search across services, apps and hosts! New features Added new home screen with favorite APM, Mobile, and Browser apps, Infrastructure hosts, key transactions, and plugin instances. Added search to the home screen, to quickly search across APM, Mobile, Browser apps, hosts and key transactions. Improvements Updated Infrastructure, when viewing a filter set, to show all hosts in the charts (up to 20) by default. New Relic for iOS 3.50.0 Wednesday, July 31, 2019 - 12:00 Download Notes Improved and redesigned Browser product within the app! New features New Browser single page app (SPA) overview charts Added support to display in progress Browser violations and recent events Added support to display Browser page views Added support to display Browser JS errors Improvements Improved real agents call in APM Added link in app to license documentation New Relic for iOS 3.49.0 Wednesday, May 15, 2019 - 10:00 Download Notes Synchronizes app favorites with New Relic One for a consistent way to get access to those APM apps, Browser apps, Mobile apps, and Synthetics monitors wherever you might be. Improvements Uses the same data source for favorites as New Relic One Merges any iPhone / iPad specific favorites into your New Relic One favorites Updates Apdex charts to zoom in on the y axis to better show smaller variations Update Transaction trace bar to closer match the web in some edge cases Bug fixes Fixed an issue where searching in the APM Error attributes or stack traces would result in strange behavior Fixes an issue in the host / instance popup where the web response time was off by an order of magnitude New Relic for iOS 3.48.0 Thursday, April 11, 2019 - 09:00 Download New features Additional information for Java instances and Elixir hosts in the APM application detail section. New host / instance drop down for APM applications showing summary information, and allowing you to filter the APM page to a specific host or instance. Improvements Update to the Mobile APM summary page to allow the view to load for more customers New Relic for iOS 3.48.0 Thursday, April 11, 2019 - 09:00 Download Notes Our new APM memory / threads section now works with Java & Elixir agents! Improvements Additional information for Java instances and Elixir hosts in the APM application detail section. New host / instance drop down for APM applications showing summary information, and allowing you to filter the APM page to a specific host or instance. Update to the Mobile APM summary page, so that some edge cases will now load. Pages « first ‹ previous 1 2 3 4 5 6 7 8 9 next › last »",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.628586,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Mobile <em>apps</em> release notes",
        "category_1": "Mobile <em>apps</em> release notes",
        "body": "[RSS] Items per page 5 10 New Relic for iOS 3.55.0 Thursday, April 23, 2020 - 06:00 Download Improvements Improved <em>time</em> <em>picker</em> with custom start and end <em>time</em> selection Added <em>time</em> <em>picker</em> to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards Fixed a crash that sometimes"
      },
      "id": "5b6b67d5827a6614c852ffd6"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-30T01:48:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.42412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your New Relic One <em>application</em>",
        "sections": "Add tables to your New Relic One <em>application</em>",
        "info": "Add a table to your New Relic One <em>app</em>.",
        "tags": "table in <em>app</em>",
        "body": " ID as shown in the example. export default class Nr1HowtoAdd<em>TimePicker</em> extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to&#x2F;create-a-table. Before you can load the demo"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.15067,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " picker to your <em>app</em> <em>Add</em> a time picker to a sample application 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and <em>publish</em> it to New Relic One 30 min <em>Add</em> a table to your <em>app</em> <em>Add</em> a table to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing",
        "This site uses cookies 🍪"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-11-23T01:45:56Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they’ve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren’t an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.592567,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "Permissions for managing applications When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13151,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Extend your instrumentation",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "92a838b215a23bd47fcc8b45abdf347c56f720db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment",
      "published_at": "2020-11-21T21:51:04Z",
      "updated_at": "2020-08-18T06:29:37Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your APM's Node.js app in the Google App Engine (GAE) flexible environment. ",
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 27.22541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "info": "How to install your APM&#x27;s Node.js <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "5972fea707552313d3f9ba8d"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13866,
      "sections": [
        "Python agent",
        "Getting started",
        "Installation",
        "Configuration",
        "Supported features",
        "Back-end services",
        "Custom instrumentation",
        "API guides",
        "Python agent API",
        "Web frameworks and servers",
        "Async instrumentation",
        "Hosting services",
        "Attributes",
        "Troubleshooting",
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Python agent",
      "external_id": "c1ce9a74f2eccba9cf0cd509a6f15f2d02fabb16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment",
      "published_at": "2020-11-21T15:35:19Z",
      "updated_at": "2020-08-30T17:24:26Z",
      "breadcrumb": "Contents / APM agents / Python agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your Python app in the Google App Engine (GAE) flexible environment. ",
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.683088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "info": "How to install your Python <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "5f3fb624196a672fda1cd4a3"
    },
    {
      "category_2": "Installation",
      "nodeid": 13121,
      "sections": [
        "Go agent",
        "Get started",
        "Installation",
        "Configuration",
        "Instrumentation",
        "API guides",
        "Features",
        "Troubleshooting",
        "Install the Go agent in GAE flexible environment",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Go agent",
      "external_id": "d6409627d1a1d951d544a84613ad1709456f4560",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment",
      "published_at": "2020-11-21T17:45:17Z",
      "updated_at": "2020-08-15T09:48:00Z",
      "breadcrumb": "Contents / APM agents / Go agent / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your New Relic's Go app in the Google App Engine (GAE) flexible environment. ",
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.304096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to install your New Relic&#x27;s Go <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker"
      },
      "id": "5f37af50196a67d8f955e63e"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 756.1467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " <em>Relic</em> One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 634.9177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " CloudFormation, and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: bash Copy $ sudo snap install newrelic-cli macOS With Homebrew installed, run: bash Copy $ brew install newrelic-cli Windows With Scoop installed, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 570.17554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 419.9206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> One app",
        "body": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference To build a <em>New</em> <em>Relic</em> One app, you must install the <em>New</em> <em>Relic</em> One <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> One <em>CLI</em> (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/resources/webinars/Build-nerdlet-New-Relic-One-programmability-EMEA-200520?video=past-webinar",
      "sections": [
        "During the webinar you will learn:",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-22T10:00:03Z",
      "title": "Build a Nerdlet with New Relic One Programmability",
      "updated_at": "2020-10-09T21:04:21Z",
      "type": "storefront",
      "external_id": "8e6acf295e0921c9d6ddbb015cf6a7ab1829c8cf",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Build a nerdlet with New Relic One programmability Webinar Build a nerdlet with New Relic One programmability   Learn how to build an application using data available in New Relic. Watch this exclusive 60 minute session to get an introduction to the fundamentals of New Relic One programmability and walk through the key concepts of developing New Relic applications. Training is delivered by a New Relic facilitator, who will guide you through the creation of an app from scratch.   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Executing New Relic CLI commands Making GraphQL and web service requests. During the webinar you will learn: Installation of New Relic CLI and environment setup Familiarisation with New Relic One application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment. Request a demo COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 416.2187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a Nerdlet with <em>New</em> <em>Relic</em> One Programmability",
        "body": " the <em>New</em> <em>Relic</em> command-line interface (<em>CLI</em>) on local workstation Setting <em>New</em> <em>Relic</em> API developer access credentials Executing <em>New</em> <em>Relic</em> <em>CLI</em> commands Making GraphQL and web service requests. During the webinar you will learn: Installation of <em>New</em> <em>Relic</em> <em>CLI</em> and environment setup Familiarisation"
      },
      "id": "5ed2fe08e7b9d263f7c70718"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies 🍪"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:44:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Diagnose error alerts in Telco Lite 20 min Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.6145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion",
        "This site uses cookies 🍪"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:44:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Practice diagnosing common issues using New Relic 75 min Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker Cloning the demo-deployer Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the deployer's repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Since Telco Lite contains several services, the deployment can take over half an hour. When it finishes, you should see some output stating that the deployment was successful: bash [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.6145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ", and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/c33-pillar-details/New-Relic-TechDemo-ImprovePerformance-C33.png",
      "url": "https://newrelic.com/resources/webinars/live-demo-improve-performance-reliability-and-scale",
      "sections": [
        "Improve Performance, Reliability and Scale with New Relic One",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-21T15:20:40Z",
      "title": "Weekly Live Demo: Improve Performance, Reliability and Scale with New Relic One",
      "updated_at": "2020-11-21T15:20:40Z",
      "type": "storefront",
      "external_id": "da322a2e0413a8a540347ec1539dc77ec5d5d9cd",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WEEKLY LIVE DEMO Improve Performance, Reliability and Scale with New Relic One Every Wednesday at 11 a.m. PT / 2 p.m. ET Format: One hour (5-minute overview, 45 minutes demo, 10 minutes Q&A) Interested in learning more about New Relic One before you decide to sign up? Attend this weekly demo of New Relic One led by a member of our Solutions Engineering team to get a detailed tour of the observability platform. Learn why over 16,000 customers use New Relic One to: Collect metrics, events, logs, and traces across your entire software environment - Eliminate data silos and cut through complexity by bringing all of your telemetry data onto one platform. Find and fix issues faster - Draw meaningful connections within a complex sea of data by automatically highlighting dependencies, so you can respond to incidents faster and with better context. Run more efficiently and reliably - Get a comprehensive view of your server and host health, as well as the applications and services they depend on. Register for this demo December 2, 2020 @ 11:00 PST December 9, 2020 @ 11:00 PST December 16, 2020 @ 11:00 PST COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.661884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly Live <em>Demo</em>: Improve Performance, Reliability and Scale with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "5ed26da4196a6761a165884b"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-23T01:40:22Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2020-11-21T01:39:10Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.589485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/contact-sales",
      "sections": [
        "Contact a sales rep.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-22T01:48:32Z",
      "title": "Contact Sales",
      "updated_at": "2020-11-21T14:25:35Z",
      "type": "",
      "external_id": "4483f09a82f519cca9556f9a1c8308968d3dd688",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Contact a sales rep. Our technical sales team can help you understand how our products may fit in your unique software environment, get customized pricing, answer technical questions or setup a demo. Want answers right now? Give us a call: (888) 643-8776. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 38.711636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "57883e6b0cc37f1f1165996e"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies 🍪"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:47:24Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Diagnose high response times in Telco Lite 15 min Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.50253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " the offending row (called a span), and then select <em>Explore</em> this transaction: Step 3 of 6 You&#x27;re now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion",
        "This site uses cookies 🍪"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:44:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Practice diagnosing common issues using New Relic 75 min Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker Cloning the demo-deployer Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the deployer's repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Since Telco Lite contains several services, the deployment can take over half an hour. When it finishes, you should see some output stating that the deployment was successful: bash [INFO] Executing Deployment [✔] Parsing and validating Deployment configuration success [✔] Provisioner success [✔] Installing On-Host instrumentation success [✔] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.6145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ", and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/c33-pillar-details/New-Relic-TechDemo-ImprovePerformance-C33.png",
      "url": "https://newrelic.com/resources/webinars/live-demo-improve-performance-reliability-and-scale",
      "sections": [
        "Improve Performance, Reliability and Scale with New Relic One",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-21T15:20:40Z",
      "title": "Weekly Live Demo: Improve Performance, Reliability and Scale with New Relic One",
      "updated_at": "2020-11-21T15:20:40Z",
      "type": "storefront",
      "external_id": "da322a2e0413a8a540347ec1539dc77ec5d5d9cd",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WEEKLY LIVE DEMO Improve Performance, Reliability and Scale with New Relic One Every Wednesday at 11 a.m. PT / 2 p.m. ET Format: One hour (5-minute overview, 45 minutes demo, 10 minutes Q&A) Interested in learning more about New Relic One before you decide to sign up? Attend this weekly demo of New Relic One led by a member of our Solutions Engineering team to get a detailed tour of the observability platform. Learn why over 16,000 customers use New Relic One to: Collect metrics, events, logs, and traces across your entire software environment - Eliminate data silos and cut through complexity by bringing all of your telemetry data onto one platform. Find and fix issues faster - Draw meaningful connections within a complex sea of data by automatically highlighting dependencies, so you can respond to incidents faster and with better context. Run more efficiently and reliably - Get a comprehensive view of your server and host health, as well as the applications and services they depend on. Register for this demo December 2, 2020 @ 11:00 PST December 9, 2020 @ 11:00 PST December 16, 2020 @ 11:00 PST COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.661884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly Live <em>Demo</em>: Improve Performance, Reliability and Scale with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "5ed26da4196a6761a165884b"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-23T01:40:22Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2020-11-21T01:39:10Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.589485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/contact-sales",
      "sections": [
        "Contact a sales rep.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-22T01:48:32Z",
      "title": "Contact Sales",
      "updated_at": "2020-11-21T14:25:35Z",
      "type": "",
      "external_id": "4483f09a82f519cca9556f9a1c8308968d3dd688",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Contact a sales rep. Our technical sales team can help you understand how our products may fit in your unique software environment, get customized pricing, answer technical questions or setup a demo. Want answers right now? Give us a call: (888) 643-8776. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 38.711636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "57883e6b0cc37f1f1165996e"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.89896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " to query <em>data</em> from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate <em>data</em> using <em>NerdStorage</em> <em>NerdStorage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. 20 min Add a time"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2020-11-23T01:52:51Z",
      "updated_at": "2020-10-27T02:33:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.4883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document <em>database</em> <em>accessible</em> within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " will return the URL to view your running application on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>"
      },
      "id": "5efa98d4e7b9d26d6b7bab74"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.10982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": ", or user-specific <em>data</em>. For more on this, see <em>NerdStorage</em>. Platform APIs The Platform API <em>components</em> of the SDK enable your application to interact with different parts of the <em>New</em> <em>Relic</em> <em>One</em> platform, by reading and writing state from and to the URL, setting the configuration, etc. They can"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.27951,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> CLI Reference",
        "sections": "<em>New</em> <em>Relic</em> CLI Reference",
        "info": "The command line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> cli",
        "body": "<em>New</em> <em>Relic</em> CLI Reference The <em>New</em> <em>Relic</em> CLI enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> CLI commands Find details for the <em>New</em> <em>Relic</em> CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.71497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorageVault</em>",
        "sections": "Using <em>NerdStorageVault</em> in your <em>apps</em>",
        "info": "Intro to <em>NerdStorageVault</em> on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorageVault 15 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorageVault to store <em>data</em> in an encrypted storage solution. Using NerdStorageVault in your <em>apps</em> NerdStorageVault is used to store"
      },
      "id": "5f865b55196a675792bd5340"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.02657,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:build",
        "Builds a Nerdpack",
        "Usage",
        "Options",
        "nr1 nerdpack:clone",
        "Clone an existing Nerdpack",
        "nr1 nerdpack:serve",
        "Serve your Nerdpack locally",
        "nr1 nerdpack:uuid",
        "Get your Nerdpack's UUID",
        "nr1 nerdpack:publish",
        "Publish your Nerdpack",
        "nr1 nerdpack:deploy",
        "Deploy your Nerdpack to a channel",
        "nr1 nerdpack:undeploy",
        "Undeploy your Nerdpack",
        "nr1 nerdpack:clean",
        "Removes all built artifacts",
        "nr1 nerdpack:validate",
        "Validates artifacts inside your Nerdpack",
        "nr1 nerdpack:Info",
        "Shows the state of your Nerdpack in the New Relic's registry",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:50:29Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2020-10-14T01:58:45Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "New Relic One CLI Nerdpack commands To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from a git repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your development folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Command details nr1 nerdpack:build Builds a Nerdpack Runs a webpack process to assemble your Nerdpack into javascript and CSS bundles. As many other CLI commands, it should be run at the package.json level of your Nerdpack. Usage $ nr1 nerdpack:build OPTION Options --extra-metadata-path=extra-metadata-path Specify a json file path with extra metadata. [default: extra-metadata.json] --prerelease=prerelease If specififed, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile The authencation profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clone Clone an existing Nerdpack Duplicates an existing Nerdpack onto your local computer. You can clone an open source Nerdpack from our Open Source GitHub repositories. After choosing a git repository, this command performs the following actions so that you can start using the Nerdpack: Clones the repository. Sets the repository as remote upstream. Installs all of its dependencies (using npm). Generates a new UUID using your profile, and commits it. Usage $ nr1 nerdpack:clone OPTION Options -r, --repo=REPO Repository location (either an HTTPS or SSH path). (Required) -p, --path=PATH Determines the directory to clone to (defaults to the repository name). -f, --force Replaces destination folder if it exists. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:serve Serve your Nerdpack locally Launches a server with your Nerdpack locally on the New Relic One platform, where it can be tested live. To learn more about working with apps locally, see our guide on how to serve, publish, and deploy documentation. Usage $ nr1 nerdpack:serve Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:uuid Get your Nerdpack's UUID Prints the UUID (Universal Unique ID) of your Nerdpack, by default. The UUID determines what data the Nerdpack can access and who can subscribe to the Nerdpack. To deploy a Nerdpack you didn't make, you'll have to assign it a new UUID by using the -g or --generate option. For more details, see our GitHub workshop on GitHub. Usage $ nr1 nerdpack:uuid Options --profile=PROFILE The authentication profile you want to use. -f, --force If present, it will override the existing UUID without asking. -g, --generate Generates a new UUID if not available. --verbose Adds extra information to the output. nr1 nerdpack:publish Publish your Nerdpack Publishes your Nerdpack to New Relic. Please note: If no additional parameters are passed in, this command will automatically deploy the Nerdpack onto the DEV channel. If you want to specify your own list of deploy channels, add the --channel option. For example, $ nr1 nerdpack:publish --channel BETA --channel STABLE. If you want to disable this behavior, add -D or --skip-deploy to the command. Then, you can use nr1 nerdpack:deploy to perform a deploy manually. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:publish Options -B, --skip-build Skips the previous build process. -D, --skip-deploy Skips the following deploy process. -c, --channel=DEV/BETA/STABLE Specifies the channel to deploys to. [default: STABLE] -f, --force Forces the publish, overriding any existing version in the registry. --dry-run Undergoes publishing process without actually publishing anything. --extra-metadata-path=extra-metadata-path Specifies a json file .path with extra metadata. [default: extra-metadata.json] --prerelease=STRING The value you enter will be appended to the current version of generated files. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:deploy Deploy your Nerdpack to a channel Deploys a Nerdpack version to a specific channel (DEV, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:deploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to deploy to. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --from-version=VERSION Specifies which version to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:undeploy Undeploy your Nerdpack Undeploys a Nerdpack version from a specific channel (for example, DEV, BETA, or STABLE). Usage $ nr1 nerdpack:undeploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to undeploy from. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to undeploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clean Removes all built artifacts Cleans and removes the content and the developtment folders (dist/, tmp/). Usage $ nr1 nerdpack:clean OPTION Options --profile=profile The authentication profile you want to use --verbose Adds extra information to the output. nr1 nerdpack:validate Validates artifacts inside your Nerdpack Validates artifacts inside your Nerdpack. Usage $ nr1 nerdpack:validate OPTION Options -l, --force-local The authentication profile you want to use. -r, --force-remote Force download of new schema files. --profile=profile The authentication profile you want to uset. --verbose Adds extra information to the output. nr1 nerdpack:Info Shows the state of your Nerdpack in the New Relic's registry Shows the state of your Nerdpack in the New Relic's registry. The default amount of versions shown is 10 but all versions can be shown if the --all (or -a) flag is used Usage $ nr1 nerdpack:info OPTION Options -a, --all Show all versions. -i, --nerdpack-id=nerdpack-id Get info from the specified Nerdpack instead of local one. --profile=profile The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.37646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "info": "An overview of the CLI <em>commands</em> you can use to set up your <em>New</em> <em>Relic</em> <em>One</em> <em>Nerdpacks</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em> To set up your Nerdpacks, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 <em>nerdpack</em>:build Assembles your <em>Nerdpack</em> into bundles nr1 <em>nerdpack</em>:clone Clones a <em>Nerdpack</em> from"
      },
      "id": "5f28bd6a64441f9817b11a38"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.42257,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using NerdStorageVault in your <em>apps</em>",
        "info": "Intro to NerdStorageVault on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorageVault 15 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.67828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em>"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.08251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom <em>app</em> or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your <em>app</em>"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies 🍪"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:47:24Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Diagnose high response times in Telco Lite 15 min Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds—or 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time—less than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.50253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " the offending row (called a span), and then select <em>Explore</em> this transaction: Step 3 of 6 You&#x27;re now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies 🍪"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:44:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Diagnose error alerts in Telco Lite 20 min Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.6145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/c33-pillar-details/New-Relic-TechDemo-ImprovePerformance-C33.png",
      "url": "https://newrelic.com/resources/webinars/live-demo-improve-performance-reliability-and-scale",
      "sections": [
        "Improve Performance, Reliability and Scale with New Relic One",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-21T15:20:40Z",
      "title": "Weekly Live Demo: Improve Performance, Reliability and Scale with New Relic One",
      "updated_at": "2020-11-21T15:20:40Z",
      "type": "storefront",
      "external_id": "da322a2e0413a8a540347ec1539dc77ec5d5d9cd",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WEEKLY LIVE DEMO Improve Performance, Reliability and Scale with New Relic One Every Wednesday at 11 a.m. PT / 2 p.m. ET Format: One hour (5-minute overview, 45 minutes demo, 10 minutes Q&A) Interested in learning more about New Relic One before you decide to sign up? Attend this weekly demo of New Relic One led by a member of our Solutions Engineering team to get a detailed tour of the observability platform. Learn why over 16,000 customers use New Relic One to: Collect metrics, events, logs, and traces across your entire software environment - Eliminate data silos and cut through complexity by bringing all of your telemetry data onto one platform. Find and fix issues faster - Draw meaningful connections within a complex sea of data by automatically highlighting dependencies, so you can respond to incidents faster and with better context. Run more efficiently and reliably - Get a comprehensive view of your server and host health, as well as the applications and services they depend on. Register for this demo December 2, 2020 @ 11:00 PST December 9, 2020 @ 11:00 PST December 16, 2020 @ 11:00 PST COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.661884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly Live <em>Demo</em>: Improve Performance, Reliability and Scale with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "5ed26da4196a6761a165884b"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-23T01:40:22Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2020-11-21T01:39:10Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.589485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/contact-sales",
      "sections": [
        "Contact a sales rep.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-22T01:48:32Z",
      "title": "Contact Sales",
      "updated_at": "2020-11-21T14:25:35Z",
      "type": "",
      "external_id": "4483f09a82f519cca9556f9a1c8308968d3dd688",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Contact a sales rep. Our technical sales team can help you understand how our products may fit in your unique software environment, get customized pricing, answer technical questions or setup a demo. Want answers right now? Give us a call: (888) 643-8776. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 38.711636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects Training Get help"
      },
      "id": "57883e6b0cc37f1f1165996e"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.43375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " <em>CLI</em> <em>commands</em> to: Generate Nerdpack&#x2F;Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the <em>catalog</em> Installing the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> In <em>New</em> <em>Relic</em>, click Apps and then in the <em>New</em> <em>Relic</em> <em>One</em> <em>catalog</em> area, click the Build"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.61856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em> Start the guide Get inspired 30 min Add a table to your app Add a table to your <em>New</em>"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Summary",
        "Related information",
        "This site uses cookies 🍪"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2020-11-23T01:51:55Z",
      "updated_at": "2020-10-30T01:47:24Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Create a \"Hello, World!\" application 15 min Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it. Related information Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can see it directly on their homepage.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.54941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "NR <em>One</em> <em>Catalog</em>",
        "body": ", you can publish it to <em>New</em> <em>Relic</em> <em>One</em>. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and <em>New</em> <em>Relic</em>. To develop projects, you need the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). If you haven&#x27;t already"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.34998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.01381,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.54475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.8548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.31012,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies 🍪"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.64675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: bash Copy $ sudo snap install newrelic-cli macOS With Homebrew installed, run: bash Copy $ brew install newrelic-cli Windows With Scoop installed, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.23995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-subscription/",
      "sections": [
        "New Relic One CLI subscription commands",
        "Command details",
        "nr1 subscription:set",
        "Subscribe to a Nerdpack",
        "Usage",
        "Options",
        "Aliases",
        "nr1 subscription:list",
        "See your subscription",
        "nr1 subscription:unset",
        "Unsubscribe from a Nerdpack",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:45:56Z",
      "title": "New Relic One CLI subscription commands",
      "updated_at": "2020-08-06T01:44:54Z",
      "type": "developer",
      "external_id": "12d2e1b06dede5b1272527f95a14518010aecc58",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to manage your Nerdpack subscriptions.",
      "body": "New Relic One CLI subscription commands To manage your Nerdpack subscriptions, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Command details nr1 subscription:set Subscribe to a Nerdpack Subscribes your account to a specific Nerdpack and channel. This command can be run with a Nerdpack UUID or within a specific Nerdpack folder. By default, the command uses the Nerdpack ID in package.json and subscribes to the STABLE channel. An account can only be subscribed to one Nerdpack and channel at a time. Usage $ nr1 subscription:set Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. -c, --channel=DEV/BETA/STABLE Specifies the channel to subscribe to. [default: STABLE] --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:subscribe nr1 subscription:list See your subscription Lists all the Nerdpacks your account is subscribed to. Your account is linked to your API key. Usage $ nr1 subscription:list Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 subscription:unset Unsubscribe from a Nerdpack Unsubscribes your account from a specific Nerdpack. When this command is executed within a Nerdpack folder, the Nerdpack ID from package.json is used by default. Usage $ nr1 subscription:unset Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:unsubscribe $ nr1 subscription:delete $ nr1 subscription:remove $ nr1 subscription:rm",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 704.4128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to manage your <em>Nerdpack</em> subscriptions.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em> To manage your <em>Nerdpack</em> subscriptions, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 subscription:set Subscribes your account to a <em>Nerdpack</em> and channel. nr1"
      },
      "id": "5f2b6096e7b9d225ebc9de6f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 489.57782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " (<em>New</em> <em>Relic</em> query language). See our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.57208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": ". For more on how to serve and publish your application, see our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, Nerdlet"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies 🍪"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.0718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate <em>Nerdpack</em> components There are two ways to generate a <em>Nerdpack</em> template: Generate a <em>Nerdpack</em>: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select <em>Nerdpack</em> to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.05823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.13615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.68143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.1655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " <em>Relic</em> <em>One</em> app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate <em>common</em> tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.66544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.8719,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " CloudFormation, and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.04416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.34998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: bash Copy $ sudo snap install newrelic-cli macOS With Homebrew installed, run: bash Copy $ brew install newrelic-cli Windows With Scoop installed, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.48496,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.04454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies 🍪"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.66483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.71616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em> 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "https://developer.newrelic.com/static/AaronSoto-d72d9bb5f5e6165751e67367612525f4.jpg",
      "url": "https://developer.newrelic.com/nerd-days/",
      "sections": [
        "Nerd Days is a free 1-day event focused on building more perfect software",
        "Register for Nerd Days 1.0",
        "What’s is Nerd Days exactly…",
        "Save the date & join us online",
        "Upcoming Nerd Days",
        "Speaker line up",
        "Aaron Soto",
        "Caitlin Halla",
        "David Shanker",
        "Jeremy Cooper",
        "Joel Worrall",
        "John Vajda",
        "Jon Thurman",
        "Justin Eveland",
        "Leon Chapman",
        "Lindsy Farina",
        "Talia Nassi",
        "Thomas Martin",
        "Alec Swanson",
        "Brian Thomason",
        "Chris Trombley",
        "Sander Blue",
        "Gabe O'Brien",
        "Liam Hurrell",
        "Michael Caron",
        "Phil Weber",
        "Sebastian Remirez",
        "Jewels Nocera",
        "Nica Fee",
        "Stijn Polfliet",
        "Brad Schmitt",
        "Eric Mittelhammer",
        "Colin MacNaughton",
        "Tracks",
        "Observability",
        "Cloud migration",
        "Open source",
        "Devops journey",
        "Fundamentals",
        "Nerd Days AMER Agenda",
        "DevOps journey",
        "Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements",
        "Instrumenting your service using agents",
        "New Relic CLI Wizardry",
        "5 Steps to Kubernetes Observability",
        "Delivering SRE as a Service",
        "Building applications on New Relic One",
        "Exploring your data using NRQL",
        "New Relic AI",
        "Going Serverless: Chipping at the monolith",
        "Logging for Modern Organizations",
        "Power up your Prometheus metrics with the Telemetry Data Platform",
        "Lunch with Lew",
        "Custom Instrumentation",
        "Exploring Data with NerdGraph",
        "Consolidating Your Data with New Relic’s Telemetry Data Platform",
        "Testing in Production",
        "How Open Source powers the New Relic One Catalog",
        "Alerts Best Practices",
        "The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data",
        "Monitoring your Cloud Usage and Spend",
        "Scaling the Developer Toolkit Team: Writing Code that Writes Code",
        "Reducing toil with Terraform",
        "True availability using Synthetics",
        "How Observability-Driven Development accelerates DevOps transformations",
        "AWS Modernization",
        "Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks'",
        "NerdStorageVault: ThirdParty Secrets",
        "Closing + Swag",
        "Engage with the developer community",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:57:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-04T01:52:48Z",
      "type": "developer",
      "external_id": "0b8374051901a77e242ce296c00eeb3c760439d1",
      "document_type": "page",
      "popularity": 1,
      "body": "Nerd Days is a free 1-day event focused on building more perfect software Register for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region) What’s is Nerd Days exactly… A FREE developer focused live digital conference covering a broad range of topics at varying levels for all skill sets. Including: Live workshops Live coding and demos Customer examples Panel / Q&A sessions Presented by Relics, partners, Developer Champions, and customers Save the date & join us online Whether you’re new or a data nerd, there’s an interactive session for you. Choose the sessions you're interested in and add Nerd Days to your calendar. Date: October 13, 2020 Time: 9AM PST - 3PM PST We look forward to building with you during Nerd Days! If you have any questions about Nerd Days please emails deco@newrelic.com. Upcoming Nerd Days EMEA RegistrationNov 10, 2020 Speaker line up Get hands on with sessions presented by the following Relics, partners, Developer Champions, and customers. Aaron Soto Sr. Partner Solutions Architect AWS Caitlin Halla Software Engineer New Relic David Shanker Director, Platform Engineering Kinect Consulting Jeremy Cooper Sr. TechOps Strategy Consultant New Relic Joel Worrall Director, Open Source and Developer Advocacy New Relic John Vajda Senior Product Manager New Relic Jon Thurman Senior Solutions Consultant New Relic Justin Eveland Software Engineer New Relic Leon Chapman Senior TechOps Strategy Consultant New Relic Lindsy Farina Senior Product Manager New Relic Talia Nassi Developer Advocate Split Software Thomas Martin Director, Site Reliability 27 Global Alec Swanson Software Engineer New Relic Brian Thomason Senior Partner Solutions Consultant New Relic Chris Trombley Senior Software Engineer New Relic Sander Blue Senior Software Engineer New Relic Gabe O'Brien Senior Software Engineer New Relic Liam Hurrell Senior Technical Training Specialist New Relic Michael Caron Senior Technical Training Specialist New Relic Phil Weber Senior Technical Training Specialist New Relic Sebastian Remirez Lead Software Engineer New Relic Jewels Nocera Senior Software Engineer New Relic Nica Fee Developer Advocate New Relic Stijn Polfliet Principal TechOps Strategy Consultant New Relic Brad Schmitt Senior TechOps Strategy Consultant New Relic Eric Mittelhammer Senior TechOps Strategy Consultant New Relic Colin MacNaughton Lead Software Engineer New Relic Tracks Tracks will vary by region. All sessions will be recorded and distributed after the event. Observability Cloud migration Open source Devops journey Fundamentals Nerd Days AMER Agenda We’ve got a packed schedule with thought-leaders of their respective industries Fundamentals Observability Cloud migration DevOps journey Open source 9:00AM PST Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements Lew Cirne 10:00AM PST Instrumenting your service using agents Michael Caron New Relic CLI Wizardry Jon Thurman 5 Steps to Kubernetes Observability Stijn Polfliet & Brad Schmitt Delivering SRE as a Service Thomas Martin Building applications on New Relic One Joel Worrall 11:00AM PST Exploring your data using NRQL Phil Weber New Relic AI Sebastian Ramirez Going Serverless: Chipping at the monolith Nica Fee Logging for Modern Organizations Jeremy Cooper & Leon Chapman Power up your Prometheus metrics with the Telemetry Data Platform Liam Hurrell & Colin MacNaughton 12:00PM PST Lunch with Lew Lew Cirne & Jemiah Sius 1:00PM PST Custom Instrumentation Michael Caron Exploring Data with NerdGraph Caitlin Halla Consolidating Your Data with New Relic’s Telemetry Data Platform Eric Mittelhammer Testing in Production Talia Nassi How Open Source powers the New Relic One Catalog Justin Eveland 2:00PM PST Alerts Best Practices Phil Weber The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data Lindsy Farina Monitoring your Cloud Usage and Spend Jewels Nocera Scaling the Developer Toolkit Team: Writing Code that Writes Code Sander Blue Reducing toil with Terraform Jon Thurman 3:00PM PST True availability using Synthetics Michael Caron How Observability-Driven Development accelerates DevOps transformations Dave Shanker AWS Modernization Aaron Soto & Brian Thomason Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks' Gabe O’Brien & Alec Swanson NerdStorageVault: ThirdParty Secrets John Vajda 4:00PM PST Closing + Swag Jemiah Sius Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.125725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Building <em>applications</em> on <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " Observability Stijn Polfliet &amp; Brad Schmitt Delivering SRE as a Service Thomas Martin Building applications on <em>New</em> <em>Relic</em> <em>One</em> Joel Worrall 11:00AM PST Exploring your <em>data</em> using NRQL Phil Weber <em>New</em> <em>Relic</em> AI Sebastian Ramirez Going Serverless: Chipping at the monolith Nica Fee Logging for Modern Organizations"
      },
      "id": "5f3dd5bf28ccbc2349f56e4e"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.61306,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom <em>app</em> or modify <em>one</em> of our open source <em>apps</em>, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your <em>app</em>"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies 🍪"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.06848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Generate Nerdpack <em>components</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " <em>components</em>, see our <em>app</em> building guides and the <em>New</em> <em>Relic</em> <em>One</em> CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.61302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "info": "An overview of the CLI to help you build, deploy, and manage <em>New</em> <em>Relic</em> <em>apps</em>.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference To build a <em>New</em> <em>Relic</em> <em>One</em> <em>app</em>, you must install the <em>New</em> <em>Relic</em> <em>One</em> CLI. The CLI helps you build, publish, and manage your <em>New</em> <em>Relic</em> <em>app</em>. We provide a variety of tools for building <em>apps</em>, including the <em>New</em> <em>Relic</em> <em>One</em> CLI (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.18106,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.13615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: bash Copy $ sudo snap install newrelic-cli macOS With Homebrew installed, run: bash Copy $ brew install newrelic-cli Windows With Scoop installed, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.23995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.629715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies 🍪"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.26178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.302124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " the <em>Kubernetes</em> <em>operator</em> Learn how to provision New Relic resources using the <em>Kubernetes</em> <em>operator</em> 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Evaluation offset",
        "Fill data gaps",
        "How to edit data gap values:",
        "Gap filling options:",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/signal-loss-ui.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-11-22T03:42:46Z",
      "updated_at": "2020-11-08T04:47:48Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Read on to learn more about how to do this. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Create a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. The default streaming aggregation window duration is 1 minute. The minimum aggregation window is 30 seconds. The maximum is 15 minutes. Baseline thresholds don't support configurable aggregation window durations. They use the 1 minute default. You can adjust the evaluation offset to coordinate the streaming algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. If your data is sporadic or has aggregation windows that may not have data, you can fill those gaps with a custom value or the last known value. The default value is None. To learn more about gap filling and how to request access to it, see this announcement Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Create a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a poliocy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Evaluation offset For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. Aggregation window and Offset evaluation toggles The total supported latency is the multiple of the aggregation window duration times the evaluation offset. In the screenshot example, the latency is 15 minutes (a 5 minute aggregation window X 3 windows). If the event type data comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. How to edit data gap values: In the NRQL conditions UI under Condition settings > Advanced signal settings > fill data gaps with, and then choose None, Last known value, or Custom static value. In the Nerdgraph API (preferred), you'll find this node located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue In the REST API Explorer, you'll see this under the \"signal\" section of the Alert NRQL conditions API. Gap filling options: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.18696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "info": "How to define thresholds that trigger <em>alert</em> notifications based on your <em>NRQL</em> queries.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-<em>nrql</em>-<em>alert</em>-<em>conditions</em>",
        "body": "You can use <em>NRQL</em> queries to create <em>alert</em> <em>conditions</em>. Read on to learn more about how to do this. For more information on key concepts relating to <em>NRQL</em> <em>alert</em> <em>conditions</em> and streaming alerts, see Streaming alerts: key terms and concepts. Create a <em>NRQL</em> <em>alert</em> condition To create a <em>NRQL</em> <em>alert</em> condition",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Get started",
      "nodeid": 40836,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Streaming alerts: key terms and concepts",
        "Why it matters",
        "Streaming alerts tools",
        "Loss of signal detection",
        "Gap filling",
        "Aggregation window",
        "Offset evaluation",
        "For more help"
      ],
      "title": "Streaming alerts: key terms and concepts",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "01517529fcf70c4c598d2f06638e3afea8ab4837",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/streaming_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts",
      "published_at": "2020-11-21T19:21:14Z",
      "updated_at": "2020-10-26T21:39:40Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Get started",
      "document_type": "page",
      "popularity": 1,
      "body": "The streaming alerts platform checks for violations based on data that’s present or missing in the stream of data coming into New Relic. The stream of data that comes into New Relic is called a signal. You can control what part of the signal is alerted on through NRQL conditions. These NRQL condition alerts are processed by the streaming algorithm. The NRQL query provides the signal filter for all of your incoming data. You can read more about the streaming alerts platform in this Explorers Hub post. Why it matters Alerts violations are easy when they're caused by a specific event happening, but trickier when looking for events not happening. Only data that matches the conditions of the NRQL WHERE clause is alerted on. As data streams into New Relic, it's filtered by the NRQL condition. Before data is evaluated, it must meet the criteria defined by the NRQL query's WHERE clause. Instead of evaluating that data immediately for violations, the NRQL alert conditions collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it's processed. Once the aggregation window plus the offset time have elapsed, New Relic groups the aggregated data into a single data point. Alerts then evaluates the data point using the NRQL condition in order to determine whether it meets the violation threshold criteria. Even if a data point meets the criteria for a violation, a violation isn't triggered. A violation is only triggered when data points consistently meet the threshold criteria over a period of time. This is the threshold duration. If the data points are in violation for an entire threshold duration, we'll send you a notification based on your policy settings. All of these configurable delays give you more control over how you're alerted on sporadic and missing data. Streaming alerts tools Streaming alerts provide a set of tools you can use to more effectively alert on your streaming data, giving you greater control and reducing the number of false alerts notifications. They are: Loss of signal detection Gap filling Aggregation window duration customization Offset evaluation This article covers these tools at a conceptual level. You'll find direct instructions on how to use these tools in Create NRQL alert conditions. Loss of signal detection Loss of signal occurs when no data matches the NRQL condition over a specific period of time. A loss of signal is caused by different things. The WHERE clause in your NRQL query can filter out data before it's evaluated for violations. It could also mean a service or entity is offline or a periodic job has failed to run and no data is being sent to New Relic. In order to avoid unnecessary notifications, you can choose how long to wait before you're notified by a loss of signal violation. You can use loss of signal detection to open violations and be notified when a signal is lost. Alternately, you can use a loss of signal to close violations for ephemeral services or sporadic data, such as error counts. Gap filling Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. The default is None. Gaps in streaming data can be caused by network or host issues, a signal may be sparse, or some signals, such as error counts, may only have data when something is wrong. By filling the gaps with known values, the alert evaluation process can process those gaps and determine how they should affect the loss of signal evaluation. Aggregation window In order to make loss of signal detection more effective and to reduce unnecessary notifications, you can customize aggregation windows to the duration that you need. An aggregation window is a specific block of time. Alerts gathers data points together in an aggregation window, before using the aggregation function to evaluate the data. A longer aggregation window gives straggling data points more time to arrive before evaluating that data. When a data point arrives, its timestamp is used to put it in the proper aggregation window. You can set your aggregation window to anything between 1 second and 15 minutes. The default is 1 minute. Offset evaluation For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. The offset time value is the number of aggregation windows you want to use. The duration for each window is set in the Aggregation window field. For example, if your aggregation window is 1 minute and your Offset evaluation is 3, then a straggling data point will have about 3 minutes to arrive before it might be dropped. In other words, streaming alerts will always keep 3 aggregation windows in the queue, waiting 1 minute before evaluating each window and adding a new one. The current default is 3. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.74235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Streaming <em>alerts</em>: key terms and concepts",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "body": " of evaluating that data immediately for violations, the <em>NRQL</em> <em>alert</em> <em>conditions</em> collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it&#x27;s processed. Once the aggregation window plus the offset time have"
      },
      "id": "5f7f39fc28ccbc39853cd100"
    },
    {
      "category_2": "Ingest APIs",
      "nodeid": 35466,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Access and requirements",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting",
        "For more help"
      ],
      "title": "Introduction to the Metric API",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "3b86084718aca9ca624010e4078e5e9f54d3fcaa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data/apis/introduction-metric-api",
      "published_at": "2020-11-21T21:43:20Z",
      "updated_at": "2020-10-30T04:24:42Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to report metrics to New Relic from any source with the Metric API.",
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Access and requirements You'll need a New Relic Insert API key. For information on limits and restricted attributes, see Metric API requirements and limits. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Entity explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting If you receive an NrIntegrationError, see Troubleshoot a NrIntegrationError event. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.977005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em> on metric data",
        "body": " Metric query examples. For information on querying in general, see Query data. <em>Alert</em> on metric data To <em>alert</em> on metrics created with the Metric API, use <em>NRQL</em> <em>alert</em> <em>conditions</em>: Select the <em>NRQL</em> category when defining your condition, then use the FROM Metric ... <em>NRQL</em> query syntax to express it. When"
      },
      "id": "5f24d5a7e7b9d251d8c82340"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 38406,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Configure",
        "Metric format",
        "Metric types",
        "Add tags (attributes)",
        "Create alerts",
        "Find and use data",
        "Check the source code",
        "For more help"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "5d94989a9004778a43aba9fc5187b7904affc412",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/statsd-nrql-alert-condition-example-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2",
      "published_at": "2020-11-23T01:52:34Z",
      "updated_at": "2020-11-19T01:43:42Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Here are explanations of these fields: Field name Description <metric name> string Required. Name of the metric. <value> string Required. The metric type: c = counter g = gauge ms = timer @<sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. #<tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.838394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install for <em>Kubernetes</em>",
        "body": ". Here&#x27;s an example <em>NRQL</em> query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = &#x27;production&#x27; Create alerts You can <em>alert</em> on StatsD data using <em>NRQL</em> <em>alert</em> <em>conditions</em>. <em>Alert</em> example This procedure walks you through sending some sample data and then creating an <em>alert</em> condition"
      },
      "id": "5ece854928ccbc9dbdc13573"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "Automate workflows",
      "updated_at": "2020-11-19T01:49:32Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 75 min Use New Relic to diagnose problems Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 4907.482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " 20 min <em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> 75 min <em>Use</em> <em>New</em> <em>Relic</em> to diagnose problems Learn to diagnose problems <em>using</em> <em>New</em> <em>Relic</em>."
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Get started",
      "nodeid": 38331,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Kubernetes integration: compatibility and requirements",
        "Compatibility",
        "Requirements",
        "Install using Helm",
        "For more help"
      ],
      "title": "Kubernetes integration: compatibility and requirements",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "dd40c3bef40e68d873d909dbff75708e20a1141e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements",
      "published_at": "2020-11-22T00:54:21Z",
      "updated_at": "2020-11-18T21:10:25Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "Compatibility and requirements of the New Relic Kubernetes integration.",
      "body": "New Relic's Kubernetes integration can be installed directly on a server or VM, or through several cloud platforms, such as GKE, EKS, AKS, or OpenShift. Each has a different compatibility with our integration. Compatibility Our Kubernetes integration is compatible with the following versions, depending on the installation mode: Install mode or feature Kubernetes versions Kubernetes cluster Currently tested with versions 1.10 to 1.19 Kubernetes cluster GKE Currently tested with versions 1.10 and 1.17 Kubernetes cluster EKS Compatible with version 1.11 or higher Kubernetes cluster AKS Compatible with version 1.11 or higher Kubernetes cluster OpenShift Currently tested with versions 3.7, 3.9, 4.2, 4.3, 4.4, 4.5 and 4.6 Control plane monitoring Compatible with version 1.11 or higher Service monitoring Compatible with version 1.13 or higher Requirements The New Relic Kubernetes integration has the following requirements: Linux distribution compatible with New Relic infrastructure agent. kube-state-metrics version 1.9.5 running on the cluster. When using CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level. Install using Helm For compatibility and requirements when installing the Kubernetes integration using Helm, see Alternative install using Helm. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.55093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>using</em> <em>Helm</em>",
        "info": "Compatibility and requirements of the <em>New</em> <em>Relic</em> Kubernetes integration.",
        "body": " has the following requirements: Linux distribution compatible with <em>New</em> <em>Relic</em> infrastructure agent. kube-state-metrics version 1.9.5 running on the cluster. When <em>using</em> CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level"
      },
      "id": "5ea87c3be7b9d2c533748090"
    },
    {
      "category_2": "Private locations",
      "nodeid": 23826,
      "sections": [
        "Synthetic monitoring",
        "Getting started",
        "Guides",
        "Using monitors",
        "Monitor scripting",
        "Administration",
        "Private locations",
        "UI pages",
        "Synthetics API",
        "Troubleshooting",
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Change package.json for custom modules",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "For more help"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "category_0": "Synthetic monitoring",
      "type": "docs",
      "category_1": "Synthetic monitoring",
      "external_id": "69673df39f26ded4722eabf57c47ff1b84a365ae",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration",
      "published_at": "2020-11-21T19:40:05Z",
      "updated_at": "2020-11-21T19:40:05Z",
      "breadcrumb": "Contents / Synthetic monitoring / Synthetic monitoring / Private locations",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your New Relic containerized private minion (CPM).",
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file The package.json defines dependencies as both a local module (i.e. counter) and an npm hosted modules (i.e. async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/ Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED. UUID of the Private Location, as found on the Private Location Web page. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionLogLevel When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user defined key value pairs. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers. Where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionVsePassphrase If set, enables verified script execution and uses this value as a passphrase. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379 For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.45271,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Using</em> monitors",
        "info": "Customize your <em>New</em> <em>Relic</em> containerized private minion (CPM).",
        "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: <em>Set</em> <em>up</em> custom modules for scripted browsers in <em>New</em> <em>Relic</em>. Preserve launch data with permanent data storage. <em>Use</em> environment variables in your configuration. You may not modify"
      },
      "id": "5f31d9b5196a6790dafbd6e7"
    },
    {
      "category_2": "Installation",
      "nodeid": 36841,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Configure control plane monitoring",
        "Features",
        "Compatibility and requirements",
        "Discovery of master nodes and control plane components",
        "Configuration",
        "ETCD",
        "API server",
        "OpenShift configuration",
        "Set up mTLS from the ETCD client CA",
        "Set up mTLS for ETCD in OpenShift",
        "See your data",
        "For more help"
      ],
      "title": "Configure control plane monitoring",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "6bfd11636535081afb3ef8058362d6bd3296e3ce",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/new-relic-one-k8s-cluster-explorer-control-plane-parameters.png?itok=cLymrxv6",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring",
      "published_at": "2020-11-21T20:01:23Z",
      "updated_at": "2020-11-18T21:15:35Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to configure control plane monitoring for your Kubernetes integration with New Relic.",
      "body": "New Relic provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster's Control Plane components. That data can then be found in New Relic and used to create queries and charts. Control plane monitoring requires Kubernetes integration version 1.11.0 or higher. Features We monitor and collect metrics from the following control plane components: ETCD: leader information, resident memory size, number of OS threads, consensus proposals data, etc. For a list of supported metrics, see ETCD data. API server: rate of apiserver requests, breakdown of apiserver requests by HTTP method and response code, etc. For the complete list of supported metrics, see API server data. Scheduler: requested CPU/memory vs available on the node, tolerations to taints, any set affinity or anti-affinity, etc. For the complete list of supported metrics, see Scheduler data. Controller manager: resident memory size, number of OS threads created, goroutines currently existing, etc. For the complete list of supported metrics, see Controller manager data. Compatibility and requirements Control plane monitoring requires Kubernetes integration version 1.11.0 or higher. Control plane monitoring support is not enabled for managed clusters. This is because providers (EKS, GKE, AKS, etc.) abstract away the concept of master nodes and control plane components, so that access to them is limited or non-existent. The unprivileged version of the Kubernetes integration does not support control plane monitoring. OpenShift 4.x uses control plane component metric endpoints that are different than the default. Discovery of master nodes and control plane components The Kubernetes integration relies on the kubeadm labeling conventions to discover the master nodes and the control plane components. This means that master nodes should be labeled with node-role.kubernetes.io/master=\"\" or kubernetes.io/role=\"master\". The control plane components should have either the k8s-app or the tier and component labels. Refer to the following table for accepted label combinations and values: Component Label Endpoint API server Kubeadm / Kops / ClusterAPI k8s-app=kube-apiserver tier=control-plane component=kube-apiserver OpenShift app=openshift-kube-apiserver apiserver=true localhost:443/metrics by default (can be configured) if the request fails falls back to localhost:8080/metrics ETCD Kubeadm / Kops / ClusterAPI k8s-app=etcd-manager-main tier=control-plane component=etcd OpenShift k8s-app=etcd localhost:4001/metrics Scheduler Kubeadm / Kops / ClusterAPI k8s-app=kube-scheduler tier=control-plane component=kube-scheduler OpenShift app=openshift-kube-scheduler scheduler=true localhost:10251/metrics Controller manager Kubeadm / Kops / ClusterAPI k8s-app=kube-controller-manager tier=control-plane component=kube-controller-manager​ OpenShift app=kube-controller-manager kube-controller-manager=true localhost:10252/metrics When the integration detects that it is running inside a master node, it tries to find which components are running on the node by looking for pods that match the labels listed in the table above. For every running component, the integration makes a request to its metrics endpoint. Configuration Control plane monitoring is automatic for agents running inside master nodes. The only component that requires an extra step to run is ETCD, because it uses mutual TLS authentication (mTLS) for client requests. The API Server can also be configured to be queried using the Secure Port. Control plane monitoring for OpenShift 4.x requires additional configuration. For more information, see the OpenShift 4.x Configuration section. ETCD In order to set mTLS for querying ETCD, there are two configuration options that need to be set: Option Value ETCD_TLS_SECRET_NAME Name of a Kubernetes secret that contains the mTLS configuration. The secret should contain the following keys: cert: the certificate that identifies the client making the request. It should be signed by an ETCD trusted CA. key: the private key used to generate the client certificate. cacert: the root CA used to identify the ETCD server certificate. If the ETCD_TLS_SECRET_NAME option is not set, ETCD metrics won't be fetched. For step by step instructions on how to create a certificate and sign it with the ETCD client CA, see Set up mTLS from the ETCD client CA. ETCD_TLS_SECRET_NAMESPACE The namespace where the secret specified in the ETCD_TLS_SECRET_NAME was created. If not set, the default namespace is used. API server By default, the API server metrics are queried using the localhost:8080 unsecured endpoint. If this port is disabled, you can also query these metrics over the secure port. To enable this, set the following configuration option in the Kubernetes integration manifest file: Option Value API_SERVER_ENDPOINT_URL The (secure) URL to query the metrics. The API server uses localhost:443 by default Ensure that the ClusterRole has been updated to the newest version found in the manifest Added in version 1.15.0 Note that the port can be different according to the secure port used by the API server. For example, in Minikube the API server secure port is 8443 and therefore API_SERVER_ENDPOINT_URL should be set to https://localhost:8443 OpenShift configuration Control plane components on OpenShift 4.x use endpoint URLs that require SSL and service account based authentication. Therefore, the default endpoint URLs can not be used. To configure control plane monitoring on OpenShift, uncomment the following environment variables in the customized manifest. URL values are pre-configured to the default base URLs for the control plane monitoring metrics endpoints in OpenShift 4.x. - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259 - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" Even though the custom ETCD_ENDPOINT_URL is defined, ETCD requires HTTPS and mTLS authentication to be configured. For more on configuring mTLS for ETCD in OpenShift, see Set up mTLS for ETCD in OpenShift. When installing through Helm openshift, specify the config to automatically include these endpoints. Setting openshift.enabled=true and openshift.version=\"4.x\" will include the secure endpoints and enable the /var/run/crio.sock runtime. Set up mTLS from the ETCD client CA The instructions below are based on the Kubernetes documentation. For more information, see Managing TLS certificates in a cluster. For OpenShift, see Set up mTLS for ETCD in OpenShift. To set up mTLS from the ETCD client CA: Download and install the tool cfssl, selecting the correct binaries for your OS from the list. Once installed, execute the following command: cat <<EOF | cfssl genkey - | cfssljson -bare server { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF This command generates two files; server.csr containing the PEM encoded pkcs#10 certification request and server-key.pem containing the PEM encoded key to the certificate to be created. Use the generated certificate authority (CA) of ETCD to sign your CSR. Depending on your cluster configuration, you may already have this information. For default install configuration, download the CA certificate and the private key directly from ETCD with the following commands: kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system This requires that the etcd-manager-main pod has the label k8s-app=etcd-manager-main, which is a requirement for control plane monitoring . If your etc-manager-main pod is located in a different namespace, change the -n kube-system flags accordingly. With those files downloaded, use the following command to sign your CSRF: cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert Create the secret that is used to retrieve the TLS config for making requests to ETC. We recommend renaming the certificate and the private key: cp cert.pem cert && cp server-key.pem key kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert To ease future installations Use the following commands to simultaneously create the CSR, retrieve the CA, generate the certificate by signing the CSR, and create the secret with all the required fields: cat <<EOF | cfssl genkey - | cfssljson -bare server && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system && \\ cp server-key.pem key && \\ cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert && \\ cp cert.pem cert && \\ kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF The last step is to update the configuration in the manifest and apply it. In the configuration section, there are two options related to ETCD mTLS: ETCD_TLS_SECRET_NAME with the name of the secret that we just created. ETCD_TLS_SECRET_NAMESPACE with the namespace that we used to create the secret. To complete the installation, add these variables to the container spec of the integration DaemonSet and apply the changes: - name: \"ETCD_TLS_SECRET_NAME” value: \"newrelic-infra-etcd-tls-secret\" - name: \"ETCD_TLS_SECRET_NAMESPACE\" value: \"default\" Set up mTLS for ETCD in OpenShift Follow these instructions to set up mutual TLS authentication for ETCD in OpenShift 4.x: Export the ETCD client certificates from the cluster to an opaque secret. In a default managed OpenShift cluster, the secret is named kube-etcd-client-certs and it is stored in the openshift-monitoring namespace. kubectl get secret/kube-etcd-client-certs -n openshift-monitoring -o yaml > etcd-secret.yaml Open the secret file and change the keys: Rename the certificate authority to cacert. Rename the client certificate to cert. Rename the client key to key. Optional: change the secret name and namespace to something meaningful. Remove these unnecessary keys in the metadata section: creationTimestamp resourceVersion selfLink uid Install the manifest with its new name and namespace: kubectl apply -f etcd-secret.yaml Go to Update manifest configuration (the last step under Set up MTL from ETCD client) to configure the required environment variables. See your data If the integration has been been set up correctly, the Kubernetes cluster explorer contains all the Control Plane components and their status in a dedicated section, as shown below. one.newrelic.com > Kubernetes Cluster Explorer: Use the Kubernetes cluster explorer to monitor and collect metrics from your cluster's Control Plane components You can also check for Control Plane data with this NRQL query: SELECT latest(timestamp) FROM K8sApiServerSample, K8sEtcdSample, K8sSchedulerSample, K8sControllerManagerSample FACET entityName where clusterName = 'MY_CLUSTER_NAME' If you still can't see Control Plane data, try the solution described in Kubernetes integration troubleshooting: Not seeing data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.83212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> mTLS from the ETCD client CA",
        "info": "How to configure control plane monitoring for your Kubernetes integration with <em>New</em> <em>Relic</em>.",
        "body": "<em>New</em> <em>Relic</em> provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster&#x27;s Control Plane components. That data can then be found in <em>New</em> <em>Relic</em> and used to create queries and <em>charts</em>. Control plane monitoring requires Kubernetes"
      },
      "id": "5df47acc64441f8fea39263b"
    },
    {
      "image": "https://developer.newrelic.com/static/kubecon-europe-2020-b989ec0e7b4ed71a89666c35fe934433.jpg",
      "url": "https://developer.newrelic.com/kubecon-europe-2020/",
      "sections": [
        "KubeCon and CloudNativeCon Europe 2020",
        "New Relic welcomes you at Virtual Kubecon and CloudNativeCon Europe 2020!",
        "Attend one of our lightning talks",
        "Important",
        "We handle Prometheus, you keep Grafana",
        "How to use and customize Helm charts",
        "Kubernetes observability with context",
        "What is OpenTelemetry and how to get started?",
        "OpenTelemetry Architecture",
        "Kubernetes in the wild: best practices",
        "Want some action now? Check out the following videos!",
        "How to use the Kubernetes cluster explorer",
        "What is OpenTelemetry?",
        "Connecting Prometheus and Grafana to New Relic",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:43:46Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:51:45Z",
      "type": "developer",
      "external_id": "53cb6afa4f4062ba359559e9fb3bb2406ece2ad4",
      "document_type": "page",
      "popularity": 1,
      "body": "KubeCon and CloudNativeCon Europe 2020 New Relic welcomes you at Virtual Kubecon and CloudNativeCon Europe 2020! Learn more about the New Relic One platform, the only observability platform that provides open, connected and programmable observability for cloud-native environments. Join us to dive into the New Relic One platform and our Kubernetes cluster explorer. Register here Attend one of our lightning talks Important Go to the virtual expo tab, and find New Relic in Silver Hall B to attend a lightning talk. We handle Prometheus, you keep Grafana Mon Aug 17 @ 14:35 CEST Samuel Vandamme How to use and customize Helm charts Mon Aug 17 @ 16:25 CEST Douglas Camata Kubernetes observability with context Tue Aug 18 @ 15:05 CEST Stijn Polfliet What is OpenTelemetry and how to get started? Tue Aug 18 @ 17:15 CEST Lavanya Chockaligam How to use and customize Helm charts Wed Aug 19 @ 15:05 CEST Douglas Camata OpenTelemetry Architecture Wed Aug 19 @ 16:25 CEST John Watson Kubernetes in the wild: best practices Thu Aug 20 @ 15:05 CEST Martin Fuentes Kubernetes observability with context Thu Aug 20 @ 16:50 CEST Stijn Polfliet Want some action now? Check out the following videos! How to use the Kubernetes cluster explorer What is OpenTelemetry? Connecting Prometheus and Grafana to New Relic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.45083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "How to <em>use</em> and customize <em>Helm</em> <em>charts</em>",
        "body": " to <em>use</em> and customize <em>Helm</em> <em>charts</em> Mon Aug 17 @ 16:25 CEST Douglas Camata Kubernetes observability with context Tue Aug 18 @ 15:05 CEST Stijn Polfliet What is OpenTelemetry and how to get started? Tue Aug 18 @ 17:15 CEST Lavanya Chockaligam How to <em>use</em> and customize <em>Helm</em> <em>charts</em> Wed Aug 19 @ 15:05 CEST"
      },
      "id": "5f373dcae7b9d20949909274"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.64351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": " and UserStorage<em>Mutation</em> Account access: AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em>"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 11976,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 3.36.0",
        "Improvements",
        "Fixes"
      ],
      "title": "Java Agent 3.36.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "f94f5c53e522a9835ea42514e90d9a39e81fd050",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360",
      "published_at": "2020-11-21T20:29:40Z",
      "updated_at": "2018-04-14T23:39:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:  Wednesday, February 15, 2017 - 09:55 Download Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.767097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug"
      },
      "id": "58a53cf38e9c0f755a81db4e"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Implement distributed tracing",
        "Implement cross application tracing",
        "Obtain references to New Relic entities",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2020-11-21T18:27:02Z",
      "updated_at": "2020-09-03T11:06:02Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Implement distributed tracing These APIs require distributed tracing to be enabled. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other entities, see Obtain references. Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other entities, see Obtain references. Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Implement cross application tracing To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic entities. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic entities. Obtain references to New Relic entities Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic entities. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.889679,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "PHP agent API",
      "nodeid": 11821,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "newrelic_add_custom_tracer",
        "Requirements",
        "Description",
        "Parameters",
        "Return value(s)",
        "Example(s)",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "external_id": "12242c1e6fe8cb70e2d42ff670cad04c01e9317e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer",
      "published_at": "2020-11-21T18:54:09Z",
      "updated_at": "2019-09-30T22:55:59Z",
      "breadcrumb": "Contents » APM agents / PHP agent / PHP agent API",
      "document_type": "api_doc",
      "popularity": 1,
      "info": "New Relic PHP agent API call to add custom instrumentation to particular methods in your app code. ",
      "body": "newrelic_add_custom_tracer(string $function_name) Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } }",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 25.679956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "info": "New Relic PHP agent API call to add custom instrumentation to particular <em>methods</em> in your app code. ",
        "body": " <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument"
      },
      "id": "58ca4191e621f45edd466e7a"
    },
    {
      "nodeid": 9691,
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Contents",
        "Monitor mobile app performance",
        "Install and configure",
        "Use Unity SDK API",
        "Send custom events and attributes to Insights",
        "Track custom network requests",
        "Uninstall plugin",
        "Unity release notes",
        "For more help"
      ],
      "title": "Introduction to New Relic Mobile (Unity)",
      "type": "docs",
      "external_id": "9e03a54ec6df360532302d4dfe7484070f8ba80c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity",
      "published_at": "2020-11-21T16:20:05Z",
      "updated_at": "2020-07-25T00:44:01Z",
      "breadcrumb": "Contents",
      "document_type": "page",
      "popularity": 1,
      "body": "Legacy feature This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) NewRelicAgent.SetAttribute (string name, double value) Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); public static boolean incrementAttribute(String name, double value) If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); removeAllAttributes NewRelicAgent.removeAllAttributes() Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 16.097826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em> that return boolean results return"
      },
      "id": "5c52cbec8e9c0f0b286080ec"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "category_2": "Examples",
      "nodeid": 41326,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Configure Infinite Tracing with GraphQL",
        "Update the random sampler on a trace observer",
        "Update the name on a trace observer",
        "For more help"
      ],
      "title": "Configure Infinite Tracing with GraphQL",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "cb63484d75aa6e99eadf1de0bfef1563d98e1962",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/configure-infinite-tracing-graphql",
      "published_at": "2020-11-21T17:54:32Z",
      "updated_at": "2020-11-18T16:21:27Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic NerdGraph to configure some of the settings for Infinite Tracing trace observers.",
      "body": "You can configure many of the settings for Infinite Tracing with the New Relic Edge app. You can also perform a variety of these configuration tasks using GraphQL. With our NerdGraph GraphiQL explorer you can execute and see the results of queries and mutations for Infinite Tracing configuration. This document explains some of the options that are available. If you need help getting started with GraphQL, check out Introduction to New Relic NerdGraph. Update the random sampler on a trace observer As described in our docs on the tail-based sampling algorithms there are several ways Infinite Tracing chooses to sample a trace. The random sampler is configurable, allowing you to control the percent of traces kept. If you need help about when it's appropriate to change the random filter, see Infinite Tracing: Random trace filter. The following example shows you how to update the value from the default of 1%: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Execute the following query to find the trace observer that contains the random sampler to modify: { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { id name providerRegion status traceFilters { randomTraceFilter { percentKept } } endpoints { agent { host } } } } } } } } In the response, find the trace observer id. Here is an example where the value is 123456789: { \"data\": { \"actor\": { \"account\": { \"edge\": { \"tracing\": { \"traceObservers\": [ { \"endpoints\": [ { \"agent\": { \"host\": \"your-uuid-goes-here.aws-us-east-1.tracing.edge.nr-data.net\" } } ], \"id\": 123456789, \"name\": \"Production Workload, US-EAST-1\", \"providerRegion\": \"AWS_US_EAST_1\", \"status\": \"CREATED\", \"traceFilters\": { \"randomTraceFilter\": { \"percentKept\": 1 } } } ] } } } } } } Execute a mutation using the id and the percent you want to keep. For example, to raise the value to 50% for the trace observer with id 123456789 that we found in the previous step, run the following: mutation { edgeUpdateTraceObservers( accountId: YOUR_ACCOUNT_ID traceObserverConfigs: { id: 123456789, randomTraceFilterConfig: { percentKept: 50 } } ) { responses { errors { message type } traceObserver { traceFilters { randomTraceFilter { percentKept } } id endpoints { agent { host } } name status } } } } Here's the response confirming the change: { \"data\":{ \"edgeUpdateTraceObservers\":{ \"responses\":[ { \"errors\":null, \"traceObserver\":{ \"endpoints\":[ { \"agent\":{ \"host\":\"your-uuid-goes-here.aws-us-east-1.tracing.edge.nr-data.net\" } } ], \"id\":123456789, \"name\":\"Production Workload, US-EAST-1\", \"status\":\"CREATED\", \"traceFilters\":{ \"randomTraceFilter\":{ \"percentKept\":50 } } } } ] } } } Update the name on a trace observer Here's how you can change the name of a trace observer: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Find the trace observer whose name you'd like to update: { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { id name providerRegion status endpoints { agent { host } } } } } } } } In the response, find the trace observer id that is returned: { \"data\": { \"actor\": { \"account\": { \"edge\": { \"tracing\": { \"traceObservers\": [ { \"endpoints\": [ { \"agent\": { \"host\": \"your-uuid-goes-here.aws-us-east-1.tracing.edge.nr-data.net\" } } ], \"id\": 123456789, \"name\": \"Production Workload, US-EAST-1\", \"providerRegion\": \"AWS_US_EAST_1\", \"status\": \"CREATED\" } ] } } } } } } Execute a mutation that includes the new value for the name. For example, to change the name to Global Workload, US-EAST-1 for the trace observer with id 123456789, run the following: mutation { edgeUpdateTraceObservers( accountId: YOUR_ACCOUNT_ID traceObserverConfigs: { id: 123456789, name: \"Global Workload, US-EAST-1\" } ) { responses { errors { message type } traceObserver { id endpoints { agent { host } } name status } } } } Here's the response confirming the change: { \"data\":{ \"edgeUpdateTraceObservers\":{ \"responses\":[ { \"errors\":null, \"traceObserver\":{ \"endpoints\":[ { \"agent\":{ \"host\":\"your-uuid-goes-here.aws-us-east-1.tracing.edge.nr-data.net\" } } ], \"id\":123456789, \"name\":\"Global Workload, US-EAST-1\", \"status\":\"CREATED\" } } ] } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.84476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic <em>NerdGraph</em> to configure some of the settings for Infinite Tracing trace observers.",
        "category_1": "<em>NerdGraph</em>",
        "body": "You can configure many of the settings for Infinite Tracing with the New Relic Edge app. You can also perform a variety of these configuration tasks using GraphQL. With our <em>NerdGraph</em> GraphiQL explorer you can execute and see the results of queries and <em>mutations</em> for Infinite Tracing configuration",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5fb54a08e7b9d28342457a63"
    },
    {
      "category_2": "Examples",
      "nodeid": 39021,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Use NerdGraph to manage license keys and personal API keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Update keys",
        "Delete keys",
        "Query keys",
        "For more help"
      ],
      "title": "Use NerdGraph to manage license keys and personal API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "f4b228fbc3fdc408adc6d7e10a93edd0464b7762",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys",
      "published_at": "2020-11-22T00:34:41Z",
      "updated_at": "2020-10-14T08:01:58Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic NerdGraph (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
      "body": "This document contains tutorials on how to use NerdGraph to programmatically create and manage several types of New Relic keys. To build queries and see responses, use our GraphiQL explorer. For more information on our API keys, see API keys. Overview of feature description NerdGraph's ApiAccess field can be used to programmatically create and manage the following types of keys: Personal API keys License keys, including: General license key used for APM Browser license key One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. General notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Some notes about license keys: In the context of using NerdGraph, the license keys are referred to as ingest keys. This feature allows you to create up to 1,000 keys of each license key type, which allows for key rotation. You can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. License keys created through NerdGraph can't be found in the New Relic UI. They're only queryable via the API. Some notes about personal API keys: In the context of using NerdGraph, personal API keys are referred to as user keys. User keys are displayed in various UI locations (for example: the User settings UI page). Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query personal API keys (user keys) in similar ways, replacing the ingest-specific fields with fields specific to the API. To understand the structure of these objects, you can experiment with queries using the GraphiQL explorer. You can also create, view, and delete personal API keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a personal API key: Create a personal API key To create a personal API key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.07204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and personal API keys",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic <em>NerdGraph</em> (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
        "category_1": "<em>NerdGraph</em>",
        "body": " purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. General notes about this functionality: All <em>mutations</em> can accept multiple keys as arguments, and will return",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5efe0487196a6710b1766452"
    },
    {
      "nodeid": 37751,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Queries",
        "Mutations",
        "For more help"
      ],
      "title": "NerdGraph API: Examples ",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "017d6c34d340b9bc035e91483d675915fa5252eb",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples",
      "published_at": "2020-11-21T18:36:48Z",
      "updated_at": "2020-08-11T04:59:00Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how you can manage alerts conditions, policies, and muting rules using NerdGraph.",
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer: For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.28268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "info": "Read about how you can manage alerts conditions, policies, and muting rules using <em>NerdGraph</em>.",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dbad864441fd15456a9eb"
    },
    {
      "nodeid": 37711,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "NerdGraph API: NRQL condition alerts",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions",
        "For more help"
      ],
      "title": "NerdGraph API: NRQL condition alerts ",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "86591bd20017930f1e4eef1b1a76e3806298dbb9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts",
      "published_at": "2020-11-21T16:48:01Z",
      "updated_at": "2020-10-22T08:36:30Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Examples of how to use the NerdGraph API explorer to create alert conditions, queries, and mutations.",
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Update the description This will walk you through the procedure to create a description for a NRQL alert condition. 1. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } 2. Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } 3. Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.02228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: NRQL condition alerts ",
        "sections": "Update <em>mutations</em>",
        "info": "Examples of how to use the <em>NerdGraph</em> API explorer to create alert conditions, <em>queries</em>, and <em>mutations</em>.",
        "body": "You can manage alerts conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and <em>mutations</em> you can develop in our <em>NerdGraph</em> API explorer. See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps to create",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dee1128ccbc562e88dfc1"
    },
    {
      "category_2": "Manage data",
      "nodeid": 37701,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Drop data using NerdGraph",
        "Requirements",
        "Create drop data rule",
        "NRQL restrictions",
        "Example drop rules",
        "Verify your drop rule works",
        "View rules",
        "Delete drop rules",
        "Audit drop rule history",
        "Cautions when dropping data",
        "Learn more",
        "For more help"
      ],
      "title": "Drop data using NerdGraph",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "06e7cd1ec25f92d3cb16660991adb3e7e4694238",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/data-management/drop-data-using-nerdgraph",
      "published_at": "2020-11-21T17:32:48Z",
      "updated_at": "2020-11-21T17:32:48Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Manage data",
      "document_type": "page",
      "popularity": 1,
      "info": "Using the New Relic NerdGraph API, you can drop some specific types of data that meet the criteria you set. ",
      "body": "For some types of data in New Relic, you can drop (not report) that data. You might want to do this: To filter out unimportant, low-value data To filter out potentially sensitive data If you choose to drop data, only new data will be affected. Existing data cannot be edited or deleted. Requirements You must have a user role with permissions for dropping data. Currently the following types of data can be targeted by data dropping rules: APM-reported events Browser-reported events Mobile-reported events Synthetics-reported events Custom events (like those generated by the APM agent APIs or the Event API) Log data Trace spans Metrics from the metric API Currently only DROP_ATTRIBUTES, not DROP_DATA​​​​, can be used on metrics Metrics generated from events-to-metrics are not eligible Support for additional types are planned for the future. Create drop data rule Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, please review caution information below. To drop data, create a NerdGraph-format drop rule that includes: A NRQL string that specifies what data types to drop An action type specifying how to apply the NRQL string You can form and make the call in the NerdGraph explorer. There are two ways to drop data: Drop entire data types or a data subset (with optional filter). This uses the DROP_DATA action type and uses NRQL of the form: SELECT * FROM DATA_TYPE_1, DATA_TYPE_2 (WHERE OPTIONAL_FILTER) For this type of drop rule, you cannot use anything other than * in the SELECT clause. Drop attributes from data types (with optional filter). This uses the DROP_ATTRIBUTES action type and uses NRQL of the form: SELECT dropAttr1, dropAttr2 FROM DATA_TYPE (WHERE OPTIONAL_FILTER) For this type of drop rule, you must pass in a non-empty list of raw attributes names. NRQL restrictions Not all NRQL clauses make sense for generating drop rules. You can provide a WHERE clause to select data with specific attributes. Other features such as TIMESERIES, COMPARE WITH, FACET, and other clauses cannot be used. The two action types have these restrictions: DROP_DATA can use only SELECT *. DROP_ATTRIBUTES requires use of SELECT with \"raw\" attributes (attributes with no aggregator function applied). This also means you cannot use SELECT *. Additionally, there are some attributes that are integral to their data type and cannot be dropped (such as timestamp on event data). If you include them, registration will fail. Example drop rules Here are some example drop rules: Drop two event types Let's say you notice you have some event types being sent to New Relic that are not important to you. Also, stopping the source from sending those event types quickly is unrealistic, requiring changes to agents and/or API instrumentation. Using a drop rule is an easier way to accomplish the same goal. Here is an example NerdGraph call that drops two event types: Event1 and Event2. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM Event1, Event2\" description: \"Drops all data for Event1 and Event2.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Drop events meeting certain criteria Let’s say you have a high volume custom event type that arrives from multiple sources. If you don't find all of that data important, you can use a drop rule. Here is an example of a drop rule that filters out events based on specific criteria. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM MyCustomEvent WHERE appName='LoadGeneratingApp' AND environment='development'\" description: \"Drops all data for MyCustomEvent that comes from the LoadGeneratingApp in the dev environment, because there is too much and we don’t look at it.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Drop sensitive attributes while maintaining the rest of the data Let's say you noticed an event has attributes that contain Personally Identifiable Information (PII). You are working to update your services to stop sending the data, but until then, you need to cease storing further PII in New Relic. Although you could drop all of the data as it comes in the door with a DROP_DATA rule, the rest of the data still provides value. Therefore, you can register a drop rule to remove only the offending PII from your data: mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_ATTRIBUTES nrql: \"SELECT userEmail, userName FROM MyCustomEvent description: \"Removes the user name and email fields from MyCustomEvent\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Verify your drop rule works After you create a drop rule, verify that it is working as expected. The rule should take effect quickly after a successful registration, so try running a TIMESERIES version of the query you registered to see that the data drops off. Drop rule type NRQL DROP_DATA Drop rule NRQL: SELECT * FROM MyEvent WHERE foo = bar Validation NRQL: SELECT count(*) FROM MyEvent WHERE foo = bar TIMESERIES This should drop to 0. To verify that it did not affect any thing else, invert the WHERE clause. DROP_ATTRIBUTES Drop rule NRQL: SELECT dropAttr1, dropAttr2 FROM MyEvent WHERE foo = bar Validation NRQL: SELECT count(dropAttr1), count(dropAttr2) FROM MyEvent WHERE foo = bar TIMESERIES Both lines should drop to 0. To verify that it did not affect events that contained these attributes and still should, invert the WHERE clause. View rules Here is an example NerdGraph call that returns the drop rules set on an account: { actor { account(id: YOUR_ACCOUNT_ID) { nrqlDropRules { list { rules { id nrql accountId action createdBy createdAt description } error { reason description } } } } } } Delete drop rules Here is an example NerdGraph call deleting two specific drop rules: mutation { nrqlDropRulesDelete(accountId: YOUR_ACCOUNT_ID, ruleIds: [\"48\", \"98\"]) { successes { id nrql accountId action description } failures { error { reason description } submitted { ruleId accountId } } } } Audit drop rule history To see who created and deleted drop rules, query your account audit logs. The list endpoint also includes the user ID of the person who created the rule. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Only new data will be dropped. Existing data cannot be edited or deleted. Learn more Recommendations for learning more: NerdGraph basics and terminology NRQL basics Browse the Explorers Hub for community discussions about NRQL drop rules. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.1588,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Drop data using <em>NerdGraph</em>",
        "sections": "Drop data using <em>NerdGraph</em>",
        "info": "Using the New Relic <em>NerdGraph</em> API, you can drop some specific types of data that meet the criteria you set. ",
        "body": " to drop data. The data you drop is not recoverable. Before using this feature, please review caution information below. To drop data, create a <em>NerdGraph</em>-format drop rule that includes: A NRQL string that specifies what data types to drop An action type specifying how to apply the NRQL string You can"
      },
      "id": "5e7b6e26196a6714b902bd57"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 656.6897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " to <em>query</em> data from your account and add it to a dropdown menu in an application 45 min Add, <em>query</em>, and mutate data using Nerd<em>Storage</em> Nerd<em>Storage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. 20 min Add a time"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 620.03015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em> 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you’ll learn how to use Nerd<em>Storage</em> <em>SDK</em> <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "https://newrelic.com/content/dam/newrelic/documents/image/embeds/b8c712597bd4eff347de97490f8d376d0bf35df5_5-aws-well-architected-framework.jpg",
      "url": "https://newrelic.com/resources/white-papers/modernizing-aws-replatforming-your-applications",
      "sections": [
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-11-21T14:28:34Z",
      "title": "Modernizing with AWS: Getting Started with ‘Observability-Driven’ Replatforming",
      "updated_at": "2020-11-21T14:28:34Z",
      "type": "storefront",
      "external_id": "60e054bf06bdf55c4c70ff1434ab68beff3051bf",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WHITE PAPER Modernizing with AWS: Getting Started with ‘Observability-Driven’ Replatforming Part 2 of our 3-part series on legacy app modernization in the cloud Introduction What Is Replatforming and What Are the Benefits? What Are the Risks and How Can You Minimize Them? Compatibility Analysis Using Observability to Drive Replatforming Success Use Observability Before, During, and After Your Project AWS Well-Architected Framework: Performance Efficiency AWS Well-Architected Framework: Cost Optimization AWS Well-Architected Framework: Reliability AWS Well-Architected Framework: Operational Excellence AWS Well-Architected Framework: Security Next Steps Introduction   Fundamentally, organizations modernize existing applications by moving them to Amazon Web Services (AWS) in order to optimize everything from performance to reliability to customer experience and more. For the business, the goals and measurable outcomes are typically some combination of the following:  Improve the customer experience with better reliability and performance  Reduce operational cost and effort  Accelerate time-to-market for new features  Develop and enhance technical and business agility  While modernizing existing applications can take several different forms, this white paper focuses on the replatforming approach, also known as component modernization. For an introduction to the six approaches to application modernization on AWS (retire, repurchase, retain, rehost, replatform, and refactor), read our ebook The Enterprise Guide to Continuous Application Modernization. While rehosting involves moving an existing application to AWS without making changes to the business logic, replatforming requires something more—namely, optimizing the application by modernizing one or more of its components. Components are essentially an endpoint, something that the application interacts with via a standardized API, such as a web server, relational database, or messaging system. Somewhat riskier than rehosting, yet less complex than refactoring, replatforming can be categorized as a modernization “middle road” when it comes to risk and complexity, because modernizing components usually involves some level of changes to the code. Nonetheless, how do you know when the replatforming approach is the right decision? Which applications are best suited for this approach? And, more importantly, how can you further reduce project risk while streamlining the effort and maximizing all the benefits of a replatformed application on AWS?  Here’s a hint: observability and best practices. This white paper presents the knowledge and experience of New Relic working closely with AWS and explores how you can make informed decisions to optimize your efforts and outcomes. What Is Replatforming and What Are the Benefits?   While rehosting is a lift-and-shift approach with no code changes whatsoever, moving your application essentially as-is to AWS, replatforming takes this approach a little further. Based on observations about the application, you make an informed decision to change one or more components of the application, and in doing so, achieve additional optimizations.    To be clear, changing a component does not change the business logic. It does, however, require changes to the configuration, set up, tear down, and administrative practices. For instance, coding for a data connection or an API could change, but the change doesn’t impact the business logic of the application. Any component change you make as part of a replatforming project should follow this rule. On the other hand, changing an application from using a relational database to an object store requires business logic changes, which makes it a refactoring project, not a replatforming one, because it fundamentally changes how your application behaves. Let’s review a few examples of replatforming on AWS:  Changing to a managed relational database service such as Amazon Relational Database Service (RDS) or moving to a metered database such as Amazon Aurora Using AWS Elastic Beanstalk to deploy your application Moving from self-managed Apache Kafka (on-premises, AWS, or some other SaaS Kafka) to Amazon Managed Streaming for Apache Kafka (MSK) Leveraging AWS Certificate Manager instead of running your own certificate infrastructure Moving from a self-managed Kubernetes environment to Amazon Elastic Kubernetes Service (EKS) What these examples have in common is that the code is interacting with components through a fairly standardized API. While the API will likely need to be tweaked, the business logic should not be impacted.  Why undertake a replatforming project? The benefits will depend on which component you’re changing, but they can and should include outcomes such as: Improved scalability to accommodate business growth Improved reliability and performance for a better customer experience  Reduced costs for software licensing and resource usage  Reduction of the total security surface area of your application Reduction in management efforts and associated time and costs Improved ability to make informed decisions What Are the Risks and How Can You Minimize Them?   In any project, understanding the risks involved is the first step in minimizing them. While the risks for this type of modernization are relatively low, there are certain ones you might encounter when you replatform applications. These can include:      Failure to understand application dependencies and/or overly aggressive and complex project goals  Lack of cost savings due to automation not being implemented or improved during the replatforming change (manual efforts are still required to operate the application)  Negative impact on the customer experience due to poor performance or availability caused by unexpected errors Project time exceeds original plans because of unexpected errors and/or dependencies  Failure to identify application incompatibility with the new platform These risks and others can be avoided or minimized by using best practices that are informed and guided by observability data derived before, during, and after the replatforming project.  Compatibility Analysis   It’s critical that you carefully evaluate your existing application, its structure, and business requirements to determine compatibility with the new target platform. Considerations could include factors such as: The new database service does not support the same requirements as the previous one. The application is not compatible with the available operating systems on the new platform (in this case, you might need to think about using a container replatform strategy). The new platform does not meet the security requirements of the application or the business (HIPAA, FedRAMP, GDPR, etc.) Ensure you identify and establish compatibility for all relevant application factors that relate to your application and its business requirements. Incompatibilities might indicate that the application is a candidate for refactoring rather than replatforming. Using Observability to Drive Replatforming Success   Successful modernization projects require deep visibility into your applications, customer experiences, and business outcomes. This means having comprehensive telemetry data at your fingertips so that you can make informed decisions about which applications to replatform and which candidate components to change. Observability and visibility are also essential to help you reduce overall project risk, streamline the project, and measure and prove success.       For complete observability into the applications you are considering replatforming, you need to begin instrumenting them and collecting telemetry data prior to taking any action. You will continue to track data during and after the project. In general, you should gather data about:  End-user experience Application performance  Application dependencies  Application issues Resource usage Existing components  To identify candidates, you will review application endpoints, their versions, and their performance impact on the application. You’re looking for applications with clear APIs to specific functionality that is “black boxed.” The connections that depend on the component are critical to your success; it’s important to identify them all by finding the dependencies using New Relic One.  A great place to start is with a service map of your application. New Relic One service maps are visual, customizable representations of your architecture showing connections and dependencies, including applications, databases, hosts, servers, and out-of-process services.     Understand how apps and services in your architecture connect and talk to each other using Service Maps. Gain a Deep Understanding of Your Components Develop a deeper understanding of existing componentry using New Relic One host integrations on AWS, which lets you filter, analyze, and query data about your AWS services. For a complete list of AWS integrations and to learn more, visit our documentation page.   With data in hand, you can then begin working through the steps of an informed replatforming project:  Identify candidates using service maps, end-user experiences, and application performance data. Analyze the application for known issues. Install the component on host integrations to get deeper visibility into component performance. Choose a limited set of components to change.   Apply AWS Well-Architected Framework best practices.  Deploy, test, and transition using automation. Use Observability Before, During, and After Your Project   Observability is not only imperative for the decision making and planning of your project, it’s also the best way to gain the confidence and insight to successfully change components in your applications. That’s because maintaining visibility into the application, infrastructure, componentry, end-user experience, and business success throughout the project gives you multiple advantages. With the right data, you can accelerate your efforts without increasing risk, anticipate and avoid problems, minimize complexity, and maximize the optimization of the application in the AWS environment.    Here’s how to use observability at each phase of the replatforming project:   BEFORE: Begin instrumenting candidate applications in your current environment and collecting telemetry data with New Relic One to understand application performance, end-user experiences, resource consumption, error rates, application uptime, and other critical KPIs. These measurements will serve as baseline metrics for comparison during and after the replatforming. This data also allows you to create a plan for addressing systemic application issues that you’ve identified. Use the information you gather to understand the existing profile of the component you are looking to replatform and its current issues. Then prioritize the candidates based on the potential positive impact on business goals.     A baseline dashboard will bring all the KPIs together to establish the before state.   DURING: As you begin the replatforming project, it’s important to test your applications to make sure the transition isn’t introducing any problems or slowdowns. During replatforming, use New Relic One to check the performance of application code and external services and compare it against the pre-replatforming baselines established in the “before” phase. This will give you an apples-to-apples comparison.     Quickly identify issues and roadblocks during replatforming.   AFTER: Once the replatforming is complete, use New Relic One to prove and measure your success and identify opportunities to further optimize applications for performance gains, efficient use of resources, and ease of operation.     Compare your completed replatforming KPIs against your before KPIs. Don’t Underestimate the Importance of Infrastructure-as-Code  A strong infrastructure-as-code DevOps practice allows you to experiment quickly. That’s because the ability to quickly set up and tear down environments in isolation lets you rapidly determine whether you will see a benefit in moving to a new component or service. Read AWS CloudFormation to learn more about codifying your infrastructure. One way to measure and track replatforming success is by using New Relic One and New Relic Cloud Observability Framework combined with the best practices in the AWS Well-Architected Framework. The Well-Architected Framework consists of five pillars: performance efficiency, cost optimization, reliability, operational excellence, and security. It was developed to help companies build secure, high-performing, resilient, and efficient infrastructure for their applications. Since its introduction in 2012, the Well-Architected Framework has been updated eight times.    The AWS Well-Architected Framework helps cloud architects build cloud infrastructures based on a proven track record. AWS Well-Architected Framework: Performance Efficiency   A best practice related to the first pillar of the Well-Architected Framework is to monitor and observe the efficiency of resource usage before, during, and after your replatforming project. You can use New Relic One to review how resource usage has changed. How much efficiency have you gained?    While your replatforming project might not be triggered by performance improvements, you still need to understand the impact on your end users. Are you making things better? Did the change have any impact on the outcomes being driven by the application, such as more click-throughs or conversions because pages load more quickly? Gaining visibility into this information is critical to assess the impact of your efforts on revenue-generating systems.   Bring business, customer, and operations KPIs together. AWS Well-Architected Framework: Cost Optimization   Apdex is an industry standard for measuring user satisfaction with the response time of web applications and services, which helps you see how satisfied users are with your application. Use New Relic One to compare your Apdex to the costs incurred by the application. Is this an appropriate level of investment for the role the application plays? What should your targets be for the end-user experience? Your goal is to balance these with the costs, meeting your end-user experience objectives without breaking the bank.   Track AWS budgets side by side with infrastructure and application KPIs.   Keep in mind that cost optimization as part of a replatforming exercise is about more than just license fees. It is also related to the cost of labor required to self-manage a component as well as the costs of any production issues or outages related to that component. Therefore, the costs to consider should include:  The number of components (including component versions) that are being managed License cost Infrastructure cost (focusing on the balance between performance, reliability, and scalability) Operational cost Impact on the security footprint Error management and reduction of rework and issues related to the component   AWS Well-Architected Framework: Reliability   Today’s digital businesses have stringent uptime requirements for critical applications. Start with a clear understanding of your service level agreement (SLA) and uptime requirements. Then compare reliability metrics to see how the application is performing against the SLA. What is your rate of application uptime? How often are your users impacted by errors?  Also consider that your application needs to scale and be reliable for your company’s busiest day, including expected and unexpected spikes. You need both scalability and reliability, working in concert, to achieve your SLA goals and keep your customers happy.  To that end, how well is your scaling performing? For most applications, scaling requirements are difficult to anticipate, even when predicting only six months into the future. With a small number of users, you don’t need to worry much about how well the application scales, but at higher numbers, scaling must happen automatically. You shouldn’t be spending time tuning your autoscaling rules. Based on the number of users, are you using the right technologies? How ready are you for an increase or decrease in usage?  You can get in-depth scaling information on your components using New Relic One host integrations. You can look at metrics such as refused connections, queue lengths, and shards relocating—all of which are indicators of an undersized system. On the other hand, the component may be overprovisioned, using too many resources to accommodate the peaks, but wasteful during the valleys. When you take advantage of an AWS managed service, much of this work is handled for you behind the scenes.     High-level dashboard displaying availability KPIs as well as backend metrics.   Keep in mind that this pillar of the Well-Architected Framework isn’t just about measuring your current reliability, but assessing whether you’re using the right technologies to be scalable and reliable tomorrow. Compare your current user base and expected user base to how much of your application is using seamlessly scalable technologies. While not every application will be entirely serverless, with the right data you can make better choices about what you are managing yourself. Deploy Web Applications at Scale Using AWS  View this presentation from AWS Online Tech Talks to learn about how to make your web applications more scalable.   AWS Well-Architected Framework: Operational Excellence   As you go through the replatforming exercise, you should be looking for ways to increase the amount of automation. For instance, adopting managed services can free up developer time and make it easier for developers to experiment, because they can easily spin up a new environment to try out a new idea. Over time, how is development improving? How much more quickly can you deliver features? You should see that you have more time to spend on the tasks that will make a real difference to the business. If you have code sprawl in relation to a particular component, you should identify all the areas that need to change. Then start monitoring things such as: Number of lines of code How well data is componentized Issues related to data in production How quickly you can provision an environment As you componentize the data access layer, you reduce the number of lines of code you need to maintain. Less code means fewer errors, typically more rigorously tested code, and fewer areas that could be potential security risks. To achieve this, you’ll need to start leveraging strong DevOps practices.  Deploying self-managed components such as Apache Kafka will not usually be as easily scriptable as using a CloudFormation template on AWS. Streamlining deployment and maintenance processes for a component results in fewer moving parts that you have to manage. AWS Well-Architected Framework: Security   For security, an important metric to understand is how much your organization is reducing the security surface area and effort by using managed services. How many databases do you no longer need to track, manage, and patch from a security perspective? In addition to the number of databases, how many types of databases (such as MySQL, Oracle, Microsoft SQL Server), and how many different versions (1.2, 2.7, 5.4.2, etc.) do you no longer need to track? The more database types and versions you need to secure, the more your security challenge increases. For instance, with Amazon Aurora, many security tasks are handled for you, allowing you to focus on other areas. You still need to provide proper rules to protect the data and control who has access, but the lower-level security concerns, such as operating system patches and updates, are managed by AWS. Because cybersecurity is both a technical and a legal issue, it’s important to understand your organization’s security and governance requirements and how they map to what is contractually provided by AWS. Next Steps   Application modernization is an iterative process—you’re never really finished. You should be continuously looking across your applications for additional components that could benefit from replatforming. And remember that replatforming isn’t necessarily the next step in modernizing an application. Sometimes the best next step will be to refactor the application (make code-level changes to take advantage of modern cloud services, architectures, and technologies) to achieve new levels of quality, performance, scalability, reliability, and flexibility.   Regardless of where you are in your modernization efforts, New Relic One can help you optimize your applications faster, more cost-effectively, and with less risk. As an AWS Advanced Technology Partner, New Relic has been granted AWS Competency in six solution areas (Migration, DevOps, Containers, Mobile, Retail, and Government) based on our technical proficiency and proven customer success.   To learn how New Relic One can help you in replatforming or any phase of application and infrastructure modernization, visit newrelic.com/aws. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 615.7589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "logo-newrelic Search Products Pricing Solutions Help Center About <em>New</em> <em>Relic</em> for iOS or Android    <em>New</em> <em>Relic</em> Insights <em>App</em> for iOS Search icon Sign Up Log In Products <em>New</em> <em>Relic</em> <em>One</em> <em>Platform</em> Overview Telemetry Data <em>Platform</em> Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud"
      },
      "id": "5ece932e28ccbc9f4ec13590"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 612.017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using NerdStorageVault in your <em>apps</em>",
        "info": "Intro to NerdStorageVault on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em>Vault 15 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you’ll learn how to use Nerd<em>Storage</em>Vault to store data in an encrypted <em>storage</em> solution. Using Nerd<em>Storage</em>Vault in your <em>apps</em> Nerd<em>Storage</em>Vault is used to store"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery",
        "This site uses cookies 🍪"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:44:09Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 591.2223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> <em>and</em> store data",
        "sections": "<em>Query</em> <em>components</em>",
        "info": "Reference guide for <em>SDK</em> <em>query</em> <em>components</em> using NerdGraph",
        "tags": "nerdgraph <em>query</em> <em>components</em>",
        "body": "<em>Query</em> and store data 10 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. Here you can learn how to use the <em>SDK</em> <em>query</em> <em>components</em>, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip <em>Query</em>-related React <em>components</em> can"
      },
      "id": "5efa989e28ccbc2f15307deb"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "category_2": "Dashboards",
      "nodeid": 34096,
      "sections": [
        "Explore and query data",
        "Explore data",
        "Query builder",
        "Use charts",
        "Dashboards",
        "New Relic Query Language",
        "Introduction to dashboards",
        "Why it matters",
        "See your dashboards across all New Relic",
        "Get started with dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "For more help"
      ],
      "title": "Introduction to dashboards",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "Explore and query data",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards",
      "external_id": "5e395a8f159e588361e21cae1df195dfe195be37",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards",
      "published_at": "2020-11-21T18:02:40Z",
      "updated_at": "2020-11-21T18:02:40Z",
      "breadcrumb": "Contents / Query your data / Explore and query data / Dashboards",
      "document_type": "page",
      "popularity": 1,
      "info": "Introduction to New Relic One dashboards. Explore and correlate your data with customized visualizations. ",
      "body": "To use dashboards and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Switching to New Relic One from Insights? See our transition guide. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. Chart all the events and attributes from everywhere across our platform. For more information, see our documentation on default data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. See your dashboards across all New Relic New Relic One dashboards have full backwards compatibility with the original New Relic platform, so any dashboard you have created in Insights will be automatically available in dashboards from day one. Reciprocally, when you add a new dashboard, it is also created in Insights. No further action is needed. With New Relic One you can also view dashboards across your organization using cross-account search. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our entity explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By cloning an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the entity explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Clone a dashboard Clone any dashboard by clicking the Clone dashboard button that appears when you hover over any dashboard row in the index. You can clone any dashboard regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word \"copy\". For example, if you clone a dashboard named this is my dashboard, the clone will be created as this is my dashboard copy. The clone has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. The index displays dashboards according to sorting. To quickly find your cloned dashboard, sort the dashboards by creation date, the new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can clone it. Private: Only you can see the dashboard. When you create a dashboard using the Create a dashboard button or by cloning another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.505424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Dashboard <em>permissions</em>",
        "body": " organization using cross-account search. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data <em>apps</em> associated with your New Relic account. This includes"
      },
      "id": "5f2af14de7b9d27f0fbf4a26"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2020-11-23T01:38:50Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2020-07-31T01:40:49Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) © 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.438705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications",
        "This site uses cookies 🍪"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.950035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Add images and metadata to your <em>apps</em>",
        "info": "Start sharing and using the custom New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " to the <em>app</em> Handle duplicate applications Before you begin This guide requires the following: A New Relic One <em>app</em> or <em>Nerdpack</em> New Relic One CLI A <em>Nerdpack</em> <em>manager</em> role for publishing, deploying, and subscribing <em>apps</em>. Serve your <em>app</em> locally You can locally serve the <em>app</em> you create to New Relic One to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "category_2": "Original users and roles",
      "nodeid": 1101,
      "sections": [
        "Original accounts and billing",
        "Original product-based pricing",
        "Original users and roles",
        "SAML SSO (original users)",
        "Original data retention",
        "Original pricing plan usage",
        "Users and roles (original user model)",
        "Who are these docs for?",
        "View and manage users",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads",
        "For more help"
      ],
      "title": "Users and roles (original user model)",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Original accounts and billing",
      "external_id": "39c7440fe944f68b4de943d2c9619cbcc85408d2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model",
      "published_at": "2020-11-21T14:59:50Z",
      "updated_at": "2020-10-09T04:47:17Z",
      "breadcrumb": "Contents / New Relic accounts / Original accounts and billing / Original users and roles",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic original user model: explanation of how to manage users, and how user roles work. ",
      "body": "Original user model For users on our original user model, an introduction to how the user model works, including user roles and permissions. Who are these docs for? This doc and the surrounding section of docs shows you how to manage users who are on our original user model. If you were a New Relic customer before July 30 2020, you very likely have users on our original user model (and not the New Relic One user model). One way to quickly check the user model: if you can see users in the Users and roles UI, these users are on our original user model. Want to learn more about user model changes? See Overview of pricing plan and user models. View and manage users To see the users on your New Relic account and their current roles: select the account dropdown, select Account settings, and select Users and roles. Some features in the UI are visible only to account Owners and Admins. User types: basic user and full user On the Users and roles UI page, users are categorized as either full users or basic users. This only affects your account once you've switched to the New Relic One pricing plan, released July 2020. Once you've changed your pricing plan, the number of full users is a factor in your billing. Your users on our original user model remain on that user model (and use these original user docs) and additionally have the new full/basic categorization. To learn more, see Transition to new pricing. You can also bulk update changes to user type. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. Admin Can add, edit, and delete users, and can enable or set up features. User Can use (and optionally set up) New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted User One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a master account that has sub-accounts automatically have the same level of access for all sub-accounts. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select plus-circle New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select pencil Edit role or trash-o Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a master account with sub-accounts automatically have the same level of access for all sub-accounts. However, they will not receive email notifications for alerts or weekly reports for sub-accounts unless they are explicitly granted permission on these sub-accounts. Function Owner Admin User Restricted Maintain billing information. fa-check Change the account Owner. fa-check Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. fa-check fa-check Update users' job titles and roles from Account settings in the New Relic UI. fa-check fa-check Create, modify and delete sub-accounts from Account settings in the New Relic UI. fa-check fa-check Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. fa-check fa-check fa-check fa-check Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. fa-check fa-check fa-check fa-check Manage flexible data retention. fa-check Subscribe and unsubscribe applications to New Relic One fa-check fa-check Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions To give permission to delete a mobile app from New Relic, you can assign an Admin or Mobile manager role. ​​​ Synthetics permissions Here's a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.456795,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Account <em>permissions</em>",
        "info": "For New Relic original user model: explanation of how to <em>manage</em> users, and how user roles work. ",
        "body": ". For another example, you might assign the <em>Nerdpack</em> <em>manager</em> role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on <em>Manager</em> roles are available to grant <em>permissions</em> on a per-product basis"
      },
      "id": "5f3e194028ccbc18c7f56de3"
    },
    {
      "category_2": "Installation",
      "nodeid": 7371,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "PHP agent installation overview",
        "Install the agent",
        "Install PHP with partnership accounts",
        "For more help"
      ],
      "title": "PHP agent installation overview",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/php-agent/installation/php-agent-installation-overview",
      "external_id": "fd5fd5166108e5d8ebe3b622785a1352aba06d7f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/installation/php-agent-installation-overview",
      "published_at": "2020-11-21T14:11:53Z",
      "updated_at": "2020-11-21T14:11:53Z",
      "breadcrumb": "Contents / APM agents / PHP agent / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "Overview of installing the New Relic PHP agent for RedHat, CentOS, Ubuntu, or Debian, or for the tar archive.",
      "body": "To use the PHP or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Our PHP agent consists of a PHP extension (which collects data from your application) and a local proxy daemon (which transmits the data to New Relic). Your system's configuration components, including the web server, operating system, system permissions, PHP installation itself, package manager, etc., are all important factors during installation and configuration, because the agent is a part of that. For more information about supported PHP releases, frameworks, and other system requirements, see PHP compatibility and requirements. To install the agent, use our launcher or follow the instructions below. Add PHP data Install the agent Follow this general process to install the agent on your system. The agent installation package or tar archive includes the interactive newrelic-install script, which automates some installation tasks. If your application is frequently inactive, we recommend you generate some data by interacting with the application or site. This will help ensure the agent initially connects. Ensure your system meets the agent's requirements, including appropriate system permissions. If you do not already have a New Relic account, create one. From your Account settings, copy your license key information. Install the agent package or tar archive on your system. RedHat or CentOS The most common way to install the agent on RedHat or CentOS is with the installation package (.rpm) and the package manager. You can tell the package manager to get it from the New Relic repository, or you can download the .rpm file directly from the New Relic website. Install the package with your preferred package manager (yum or rpm) and then run the newrelic-install script. Ubuntu or Debian Install the package either with apt-get or with dpkg commands. Typically, running the newrelic-install script is not required. Tar archive The .tar archive method is the most generic method you can use on all supported operating systems. Download the compressed tar archive for your system if any of these situations apply to you: Your operating system is not listed here. You are not using a package manager. Other methods are unsuccessful. Install the tar archive of the agent on any supported platform. Change the default application name to a meaningful name. Optional: Change other agent configuration settings to further customize your installation. Restart your web server (Apache, Nginx, PHP-FPM, etc.). Recommendation: To help ensure the PHP agent is initiated, especially if your application has infrequent activity, generate some data by using the app for a few seconds. Wait a few minutes for your application to send data to New Relic. Then, check your app's performance in the New Relic UI. Install PHP with partnership accounts Installation procedures may be different for admins who install the PHP agent through a New Relic partnership. For more information, see: AWS Heroku Magento Shared hosting providers Other partnership installation procedures Not all partners support PHP agents. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.63991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " from your application) and a local proxy daemon (which transmits the data to New Relic). Your system&#x27;s configuration components, including the web server, operating system, system <em>permissions</em>, PHP installation itself, package <em>manager</em>, etc., are all important factors during installation"
      },
      "id": "5535dc9b0711e80f940008af"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "nodeid": 41296,
      "sections": [
        "Recent Announcements",
        "Build high-resolution charts using sliding windows"
      ],
      "title": "Build high-resolution charts using sliding windows",
      "type": "docs",
      "external_id": "8e7ed7ec7cfcd89b4c88c66f2c07a42f8ea90f94",
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/build-high-resolution-charts-using-sliding-windows",
      "published_at": "2020-11-21T17:27:22Z",
      "updated_at": "2020-11-03T19:18:50Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "Sliding windows enable you to increase chart resolution without losing the intent of the result by reducing the timeseries aggregate size, as shown below. Highly variable results can also be smoothed out by increasing the aggregate size, without losing resolution. Sliding windows generate charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. The first duration associated with TIMESERIES defines the size of the aggregation windows, which defines how many results are captured per window. The second duration associated with SLIDE BY, defines the step size between each aggregation, which then defines the charts resolution. NRQL syntax follows the following format: SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units PromQL-style queries are translated into NRQL sliding window queries. For example, rate(request_count[5m]) over the past 60 minutes with a 1-minute window overlap would be translated into the NRQL query below: SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.60965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". The second duration associated with SLIDE BY, defines the step size between each aggregation, which then defines the charts resolution. <em>NRQL</em> <em>syntax</em> follows the following format: SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units PromQL-style queries are translated into <em>NRQL</em> sliding window"
      },
      "id": "5fa1ad1ae7b9d219479de187"
    },
    {
      "category_2": "NRQL query tutorials",
      "nodeid": 40986,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "For more help"
      ],
      "title": "Create smoother charts with sliding windows",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "external_id": "931df70d3ab9a82c04cb7c8e27d3c12b018c68fe",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows",
      "published_at": "2020-11-21T17:26:38Z",
      "updated_at": "2020-10-30T13:05:41Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / NRQL query tutorials",
      "document_type": "page",
      "popularity": 1,
      "info": "Explains how to use the SLIDE BY clause with TIMESERIES to smooth out ",
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.69875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "category_2": "<em>NRQL</em> query tutorials",
        "body": " high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar <em>data</em> but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em>",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; <em>NRQL</em> query tutorials"
      },
      "id": "5f8c0dde28ccbcc5b7b5075d"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Evaluation offset",
        "Fill data gaps",
        "How to edit data gap values:",
        "Gap filling options:",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/signal-loss-ui.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-11-22T03:42:46Z",
      "updated_at": "2020-11-08T04:47:48Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Read on to learn more about how to do this. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Create a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. The default streaming aggregation window duration is 1 minute. The minimum aggregation window is 30 seconds. The maximum is 15 minutes. Baseline thresholds don't support configurable aggregation window durations. They use the 1 minute default. You can adjust the evaluation offset to coordinate the streaming algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. If your data is sporadic or has aggregation windows that may not have data, you can fill those gaps with a custom value or the last known value. The default value is None. To learn more about gap filling and how to request access to it, see this announcement Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Create a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a poliocy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Evaluation offset For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. Aggregation window and Offset evaluation toggles The total supported latency is the multiple of the aggregation window duration times the evaluation offset. In the screenshot example, the latency is 15 minutes (a 5 minute aggregation window X 3 windows). If the event type data comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. How to edit data gap values: In the NRQL conditions UI under Condition settings > Advanced signal settings > fill data gaps with, and then choose None, Last known value, or Custom static value. In the Nerdgraph API (preferred), you'll find this node located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue In the REST API Explorer, you'll see this under the \"signal\" section of the Alert NRQL conditions API. Gap filling options: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.7787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> alert conditions",
        "sections": "<em>NRQL</em> alert <em>syntax</em>",
        "info": "How to define thresholds that trigger alert notifications based on your <em>NRQL</em> queries.",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-<em>nrql</em>-alert-conditions",
        "body": " <em>syntax</em> Here&#x27;s the basic <em>syntax</em> for creating all <em>NRQL</em> alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Get started",
      "nodeid": 11431,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Start using NRQL",
        "NRQL query examples",
        "NRQL syntax",
        "For more help"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "external_id": "d44be2c7df7addda8679b4c842015223cfcbd1a3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "published_at": "2020-11-21T17:20:13Z",
      "updated_at": "2020-09-24T08:40:20Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic Query Language (NRQL) and how to use it.",
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction New Relic Browser events, like PageView New Relic Mobile events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days:​ SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.16545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "info": "An introduction to New Relic Query Language (<em>NRQL</em>) and how to use it.",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;query-your-<em>data</em>&#x2F;<em>nrql</em>-new-relic-query-language&#x2F;get-started&#x2F;introduction-<em>nrql</em>-new-relics-query-language",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; Get started"
      },
      "id": "5f2abd47196a67747343fbe1"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-11-21T18:20:34Z",
      "updated_at": "2020-10-18T07:41:12Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.35188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "Event <em>data</em> sources",
        "category_1": "Event <em>data</em> sources",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-<em>data</em>-sources&#x2F;custom-<em>data</em>&#x2F;insights-custom-<em>data</em>-requirements-limits",
        "body": " may apply based on the method you use. General requirements How long custom <em>data</em> is retained depends on your Insights subscription and its associated <em>data</em> retention. When reporting custom events and attributes, follow these general requirements for supported <em>data</em> types, naming <em>syntax</em>, and size",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event <em>data</em> sources &#x2F; Custom events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "category_2": "Browser Pro features",
      "nodeid": 11696,
      "sections": [
        "Browser monitoring",
        "Getting started",
        "Guides",
        "Installation",
        "Configuration",
        "Browser agent and SPA API",
        "Page load timing resources",
        "Browser Pro features",
        "Additional standard features",
        "Performance quality",
        "Troubleshooting",
        "Upload source maps via API",
        "Prepare for using the source map API",
        "Push source maps to New Relic",
        "Use npm module via command line or client-side script",
        "Use API via curl",
        "Troubleshoot source maps",
        "For more help"
      ],
      "title": "Upload source maps via API",
      "category_0": "Browser monitoring",
      "type": "docs",
      "category_1": "Browser monitoring",
      "external_id": "6bc1cf3a1c7f6a2b7bdf464b7a6578b093950182",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/upload-source-maps-api",
      "published_at": "2020-11-21T19:17:16Z",
      "updated_at": "2020-11-21T19:17:15Z",
      "breadcrumb": "Contents / Browser monitoring / Browser monitoring / Browser Pro features",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic browser monitoring, how to upload and use source maps with the Browser API.",
      "body": "Browser monitoring supports the uploading of source maps, which are used to un-minify error stack traces on the JS errors page. This document explains how to use the API to publish (upload) source maps to Browser. Prepare for using the source map API In order to upload source maps to Browser via the API, you'll need this information: A user API key (before November 20, 2020, the Admin API key was required; that will still work if already in place) The New Relic application ID for the deployed app The full JavaScript file URL Optionally, if the JavaScript URL doesn't automatically have release info appended to it, the release name and ID What is the JavaScript URL? Every time the agent captures an error in your code, it's associated with the URL of the JavaScript in which it occurred. This is the src attribute of the script tag in your HTML. This full JavaScript URL is required when sending source maps to Browser. You can find the URL for an error's JavaScript file in Browser, on the JS errors page. See Browser monitoring source maps for more on finding these errors in the UI. Is a release name and ID required? Many organizations include a version number or hash in the JavaScript URL. This is generally added to \"bust\" caches to ensure your users get the most recent version of your code. This type of URL might look something like: https://example.com/assets/application-59.min.js https://example.com/assets/bundle-d6d031.min.js https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js If your app's URLs automatically have the version info appended to it, the Browser agent has everything it needs in order to match errors with your code. You can move ahead to generating source maps. If this doesn't apply to you, and JS URLs do not have version info appended, you’ll have to assist the agent by specifying a release name and ID with the API. Are there limits to source map uploads? There is no limit to the overall number of source maps you can upload. However, the API is rate-limited: You can upload a maximum of 100 source maps per minute You can upload a maximum of 5,000 source maps per day Source map files can be a maximum of 50Mb in size. Push source maps to New Relic Now that you have one or more source maps, you are ready to publish it to Browser. You can use any of these methods to send source maps to Browser: Use the New Relic npm module with the API via the command line or via a client-side JavaScript build/deploy script like Gulp or Grunt. Use API curl commands. Use the Browser UI. Use npm module via command line or client-side script The easiest and recommended way to upload source maps to Browser is to use the our new @newrelic/publish-sourcemap npm module. It provides a command line tool and Javascript API to accomplish this task. More documentation is available in the npm repo. Here are some examples of using the npm module via the command line. The following examples are for US accounts. For EU accounts, the endpoint is https://sourcemaps.service.eu.newrelic.com. For more information, see Introduction to the EU region data center. npm command line: Publish Here's an example of uploading source maps using the npm module via the command line. Note that the source map can come from a local file or a remote URL. npm install -g @newrelic/publish-sourcemap publish-sourcemap PATH_TO_SOURCE_MAP_FILE (local or remote) PATH_TO_ORIGINAL_FILE --apiKey=YOUR_NEW_RELIC_USER_API_KEY --applicationId=YOUR_NEW_RELIC_APP_ID npm command line: List published maps Here's an example of listing published source maps: list-sourcemaps --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_KEY Options: --applicationId Browser application id --apiKey New Relic user API key npm command line: Delete Here's an example of deleting a source map: delete-sourcemap --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_API_KEY --sourcemapId=YOUR_SOURCE_MAP_ID Options: --applicationId Browser application id --apiKey New Relic user API key --sourcemapId Unique id generated for a source map Here are some examples of using the npm module to publish from client-side JavaScript: npm via Node.js script: Publish Here's an example of publishing a source map via a Node.js script: var publishSourcemap = require(‘@newrelic/publish-sourcemap’).publishSourcemap publishSourcemap({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY' }, function (err) { console.log(err || 'Sourcemap upload done')}) npm via Node.js script: List published maps Here's an example of listing all published source maps: var listSourcemaps = require(‘@newrelic/publish-sourcemap’).listSourcemaps listSourcemaps({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err, res) { console.log(err || res.body)}) npm via Node.js script: Delete Here's an example of deleting a source map file via a Node.js script: var deleteSourcemap = require(‘@newrelic/publish-sourcemap’).deleteSourcemap deleteSourcemap({ sourcemapId: 'SOURCE_MAP_ID', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err) { console.log(err || 'Deleted source map')}) When you're done, go to the JS errors page in Browser, select an error grouping, and see if your error stack traces have been un-minified. Use API via curl Below are some examples of using curl to publish, list, and delete source maps: curl: Upload maps An example of using API via curl to publish maps to Browser: curl -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ -F \"sourcemap=@SOURCE_MAP_PATH\" \\ -F \"javascriptUrl=JS_URL\" \\ -F \"releaseId=YOUR_RELEASE_ID\" \\ -F \"releaseName=YOUR_UI_PAGE\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps curl: List existing maps Below is an example of how to get a list of source maps previously uploaded to New Relic via curl. New Relic returns the source map's unique SOURCEMAP_ID and its components: curl \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps curl: Delete map To delete a source map: Use the GET endpoint to list existing source maps and locate the SOURCEMAP_ID. Run the following command via curl: curl -X DELETE \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps/SOURCEMAP_ID When you're done, go to the JS errors page in Browser, select an error grouping, and see if your error stack traces have been un-minified. Troubleshoot source maps If you are having trouble generating source maps from your build system, or if your errors in Browser are remaining minified, see the source maps troubleshooting documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.4064,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upload source <em>maps</em> via API",
        "sections": "<em>Page</em> load timing resources",
        "info": "For New Relic browser monitoring, how to upload and use source <em>maps</em> with the Browser API.",
        "body": " deleteSourcemap({ sourcemapId: &#x27;SOURCE_<em>MAP</em>_ID&#x27;, applicationId: YOUR_NEW_RELIC_<em>APP</em>_ID, apiKey: &#x27;YOUR_NEW_RELIC_USER_API_KEY&#x27;, }, function (err) { console.log(err || &#x27;Deleted source <em>map</em>&#x27;)}) When you&#x27;re done, go to the JS errors <em>page</em> in Browser, select an error grouping, and see if your error stack traces"
      },
      "id": "5c6905d607552356e245ca12"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.56285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": " shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query to an <em>app</em> and <em>view</em> it in a table, then add"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 38406,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Configure",
        "Metric format",
        "Metric types",
        "Add tags (attributes)",
        "Create alerts",
        "Find and use data",
        "Check the source code",
        "For more help"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "5d94989a9004778a43aba9fc5187b7904affc412",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/statsd-nrql-alert-condition-example-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2",
      "published_at": "2020-11-23T01:52:34Z",
      "updated_at": "2020-11-19T01:43:42Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if your account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Here are explanations of these fields: Field name Description <metric name> string Required. Name of the metric. <value> string Required. The metric type: c = counter g = gauge ms = timer @<sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. #<tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here’s an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic’s StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.53996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125&#x2F;udp \\ newrelic&#x2F;nri-statsd:2.0.0 If your account is in the EU data center <em>region</em>, add this to the above command: -e NR_EU_<em>REGION</em>=true \\ After installing, you can: Do optional additional configuration Define your metrics Add <em>custom</em> tags to your data"
      },
      "id": "5ece854928ccbc9dbdc13573"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications",
        "This site uses cookies 🍪"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.79924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "info": "Start sharing and using the <em>custom</em> New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " that you haven&#x27;t subscribed to, some developed by New Relic engineers to provide visualizations we think you&#x27;ll want, like Cloud Optimizer, which analyzes your cloud environment, or <em>PageView</em> <em>Map</em>, which uses Browser events to chart performance across geographies. Your apps in the catalog are created"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.97798,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "tags": "new relic one <em>apps</em>",
        "body": " as a nested key-value <em>map</em>. Data is inside documents, which are nested inside collections: { &quot;Your<em>Nerdpack</em>Uuid&quot;: { &quot;collection-1&quot;: { &quot;document-1-of-collection-1&quot;: &quot;{\\&quot;lastNumber\\&quot;: 42, \\&quot;another\\&quot;: [1]}&quot;, &quot;document-2-of-collection-1&quot;: &quot;\\&quot;userToken\\&quot;&quot; &#x2F;&#x2F; ... }, &quot;another-collection&quot;: { &quot;fruits&quot;: &quot;[\\&quot;pear"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "category_2": "Ingest APIs",
      "nodeid": 35471,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs",
        "For more help"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "47a4c8f38c1b1674504ea302d865fd499e90ea39",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/capabilities/telemetry-sdks-send-custom-telemetry-data-new-relic",
      "published_at": "2020-11-21T21:43:20Z",
      "updated_at": "2020-11-04T00:12:08Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Report custom telemetry data with New Relic's open-source Telemetry SDKs.",
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send metrics and trace data to the New Relic platform. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility To build with the Telemetry SDKs, you will need an Event API insert key. New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported data types Java Java library on GitHub New Relic Metrics New Relic Events New Relic Logs New Relic Traces Node/TypeScript NodeJS library on GitHub New Relic Metrics New Relic Traces Python Python library on GitHub New Relic Metrics New Relic Events New Relic Logs New Relic Traces Go Go library on Github New Relic Metrics New Relic Traces .NET .NET library on GitHub .NET package in NuGet New Relic Metrics New Relic Traces C C library on Github New Relic Traces Rust Rust library on Github New Relic Traces Ruby Ruby library on Github Gem on Rubygems New Relic Traces For more on the supported data types: Metrics: see the Metric API Traces: see the Trace API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.69714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "Convert <em>event</em> data to <em>metrics</em>",
        "info": "Report custom <em>telemetry</em> data with New Relic&#x27;s open-source <em>Telemetry</em> <em>SDKs</em>.",
        "category_0": "<em>Telemetry</em> Data Platform",
        "category_2": "Ingest <em>APIs</em>",
        "body": " For more on the supported data types: Metrics: see the <em>Metric</em> <em>API</em> Traces: see the <em>Trace</em> <em>API</em> Write your own <em>Telemetry</em> <em>SDK</em> or contribute to an existing one If you need a <em>Telemetry</em> <em>SDK</em> in a language that does not currently exist or want to contribute to an existing library, please see the <em>Telemetry</em> <em>SDK</em>",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Ingest APIs"
      },
      "id": "5d89fefbe7b9d2537ed30dc1"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Where to use our API keys",
        "User API key",
        "Ingest license key",
        "Ingest browser key",
        "REST API key",
        "Admin API key",
        "Insights insert API key",
        "Insights query API key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2020-11-21T21:03:37Z",
      "updated_at": "2020-11-21T21:03:36Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several types of APIs that require their own API keys. This resource describes our API keys, what they are used for, and how to access them. Where to use our API keys Different APIs use different types of API keys. Key type What it's for Where to access User API key (historically called \"personal API key\") Querying data in NerdGraph (our GraphQL API), accessing permissions for all endpoints in the New Relic REST API and API Explorer allowed for the user. View and create via the API keys screen in the UI. Ingest license key Configuring your agent so that it can send data to New Relic and getting metric, event, log, and trace API data into New Relic. View and create via the API keys screen in the UI. Ingest browser key Getting browser application API data into New Relic. View and create via the API keys screen in the UI. REST API key Required when using New Relic REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. A User API key can also be used for the REST API, and is subject to fewer limitations. View and regenerate via the REST API key page in the UI. Admin user API key Admin-only functionality with the REST API and API Explorer or with the Synthetics API. Only available for Admin users on the original user model. Access via the REST API key page in the UI. Insights insert key Inserting events into your account with HTTPS requests. Used with New Relic APIs for event, log, metric, or trace data. View and create via the Insights API keys screen in the UI. Insights query key Querying data in the Insights query API. View and create via the Insights API keys screen in the UI. User API key User keys are for querying data in NerdGraph (our GraphQL API), which allows you to query most data that New Relic collects. Users keys also grant full permissions to use any endpoints in the New Relic REST API and API Explorer that the user's permissions allow. Create a user API key Navigate to the API Keys screen and click the Create key button. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user API key Navigate to the API Keys screen. In the row of the user API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user API key Navigate to the API Keys screen. In the row of the user API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Ingest license key License keys are ingest keys used to get agent configuration and metric, event, log, and trace API data into New Relic. Create an ingest license API key Navigate to the API Keys screen and click the Create key button. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit an ingest license API key Navigate to the API Keys screen. In the row of the license API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete an ingest license API key Navigate to the API Keys screen. In the row of the license API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Ingest browser key Browser keys are ingest keys used to get browser application APIs data into New Relic. Create an insert browser key Navigate to the API Keys screen and click the Create key button. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit an ingest browser API key Navigate to the API Keys screen. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete an ingest browser API key Navigate to the API Keys screen. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key You can use a REST API key with New Relic's REST API or the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. A User API key can be used for the REST API as well, and is not subject to the one key per account limit. Activate or change REST API key Navigate to the REST API keys screen. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Navigate to the REST API keys screen. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Navigate to the REST API keys screen. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Admin API key Use the New Relic Admin API key to manage access to the REST API and API Explorer. Users can use the account REST API key to view data with the API Explorer while Owners and Admins can use an Admin user's API key to view, add, change, or delete data. The Admin user's API key grants full permissions to use the New Relic REST API and API Explorer, including GET > List, POST > Create, PUT > Add or Update, and DELETE functions. In addition, you must use your Admin API key to manage dashboards using the API Explorer functions, including CREATE > Post, UPDATE > Put, SHOW > Get, SHOW > List, and DELETE functions. Other account users cannot view dashboard data from the API Explorer or use the Dashboard API functions. Requirements and availability: Not available for users on the New Relic One user model, including accounts on our newer pricing plan. Requires an Owner or Admin user role. Each user can have one personal Admin user's API key per account. Activate or Regenerate Admin user's API key To activate Admin API access: Navigate to the REST API keys screen. Next to your name, select the generate [regenerate icon] icon to generate your Admin user's API key. Click (Show key) to view your account's new REST API key. Copy your Admin user's API key to use with New Relic's REST API. View Admin's API key An index of Admin user's API keys appears below the account's REST API key. The list includes the Admin's full name and the date their key was last used. You can view your own Admin user's API key: From the Admin index, select (Show key) for your name. You can only view other Admin's names. The keys for all other Admins are partially obscured. Regenerate Admin user's API key To change an Admin user's API key: Navigate to the REST API keys screen. Select the Admin user's [regenerate icon][repeat]icon. Confirm the deletion of the previous Admin user's API key by typing DELETION IS FOREVER in the text field. Select Regenerate. Copy the new Admin user's API key to use with New Relic's REST API. Delete an Admin's API key If you delete an Admin from the New Relic account, or change their role from Admin to User or Restricted user, this will also automatically remove their Admin user's API key. To delete an Admin user's API key: Before you delete an API key, make sure you have the correct account or sub-account. Navigate to the REST API keys screen. From the list of Admins, locate the person whose key must be deleted. Select the delete [trash can icon] icon for the REST API key or the Admin user's API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert API key This key is required for sending data via the Event API, Log API, Metric API, and Trace API, or via our integrations that use these APIs. This key reports custom data to New Relic, including event, log, metric, or trace data. Once your custom data is sent to us, you can query and visualize that data. Tips on availability and access: Because Insert API keys are associated with an account and not a specific user, anyone in the account with access to an Insert API key can use it. As a best practice for security purposes, we recommend you use different Insert API keys for different applications or different data sources. Generate an insert API key Navigate to the Insights API Key screen. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insert API key Navigate to the Insights API Key screen. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query API key Query keys are used with New Relic's query APIs to query data. You should structure your queries including your key based on the specifications for the API you're working with. Generate a query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify a Query key. Query keys are generated for an account. They are not associated with a specific user. Anyone in the account with access to the Query key can use it. To register an Query key: Navigate to the Insights API Key screen. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete a query key To edit or delete a Query key: Navigate to the Insights API Key screen. Under Query Keys, find the key you want to modify. Select Edit or Delete. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.97798,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of New Relic <em>API</em> keys",
        "sections": "Intro to <em>APIs</em>",
        "info": "Types of New Relic <em>API</em> keys, who can use them, and how to add, update, or delete <em>API</em> keys.",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "body": " Relic and getting <em>metric</em>, <em>event</em>, log, and <em>trace</em> <em>API</em> data into New Relic. View and create via the <em>API</em> keys screen in the UI. Ingest browser key Getting browser application <em>API</em> data into New Relic. View and create via the <em>API</em> keys screen in the UI. REST <em>API</em> key Required when using New Relic REST APIs"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-11-21T15:33:29Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.4449,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "<em>Event</em> data sources",
        "info": "An overview of the options for sending custom <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": " the Flex integration tool to report your own custom <em>event</em> data. Mobile <em>agent</em> Use the mobile <em>agent</em> <em>API</em> to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em>",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Get started",
      "nodeid": 36051,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications",
        "For more help"
      ],
      "title": "Get data into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "7a413b4d7e5bd81088a08507ae4bad64c7e24b2d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks",
      "published_at": "2020-11-22T01:06:15Z",
      "updated_at": "2020-08-10T23:16:39Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to how to get data into New Relic. ",
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.791534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "category_0": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Get started"
      },
      "id": "5f24aa60196a67ede394f5f3"
    },
    {
      "category_2": "Install and configure",
      "nodeid": 2651,
      "sections": [
        "Cross-product functions",
        "Install and configure",
        "Troubleshooting",
        "Networks",
        "TLS encryption",
        "APM agents",
        "Agent downloads",
        "Infrastructure agents",
        "Browser domains",
        "Mobile domains",
        "Synthetic monitor public locations",
        "Synthetic monitor private locations",
        "Alerts webhooks, api.newrelic.com, and ticketing integrations",
        "For more help"
      ],
      "title": "Networks",
      "category_0": "Using New Relic",
      "type": "docs",
      "category_1": "Cross-product functions",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/using-new-relic/cross-product-functions/install-configure/networks",
      "external_id": "cb5b979b873b79c6d543e2ec620bb7f149e987ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/install-configure/networks",
      "published_at": "2020-11-22T00:29:35Z",
      "updated_at": "2020-11-15T03:08:38Z",
      "breadcrumb": "Contents / Using New Relic / Cross-product functions / Install and configure",
      "document_type": "page",
      "popularity": 1,
      "info": "Network connections used by New Relic for sending and receiving data: IP addresses, domains, ports, endpoints. TLS is required for all domains.",
      "body": "This list is current. Last updated 13 November 2020. This is a list of the networks, IP addresses, domains, ports, and endpoints used by New Relic collectors (for example, https://collector.newrelic.com) to communicate with a New Relic agent. TLS is required for all domains. TLS encryption To ensure data security for our customers and to be in compliance with FedRAMP and other standards for data encryption, Transport Layer Security (TLS) is required for all domains. Our preferred protocol for all domains is TLS 1.2. For more information, see New Relic's Explorers Hub post about TLS 1.2. In addition, TLS 1.2 is required for most domains, except: APM agent connections Browser agent connections Mobile agent connections Event API For future updates to required and supported protocol versions, follow the Security Notifications tag in New Relic's Explorers Hub. APM agents To enhance network performance and data security, New Relic uses a CDN and DDoS prevention service with a large IP range. New Relic agents require your firewall to allow outgoing connections to the following networks and ports. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections APM data Networks US region accounts: 162.247.240.0/22 EU region accounts: 185.221.84.0/22 Ports US region accounts: Default: TCP 443 (recommended) TCP 80 EU region accounts: Default: TCP 443 (recommended) TCP 80 Endpoints US region accounts: collector*.newrelic.com EU region accounts: collector*.eu01.nr-data.net:443 (recommended) Recommendation: Use port 443, a secured channel for encrypted HTTPS traffic. Some New Relic agents also offer port 80, an unsecured channel open to all HTTP traffic. While some agents can be configured to use both port 80 and port 443, we recommend that you choose the port 443 (default). If you have an existing configuration that uses port 80, you can update it to use port 443, the default New Relic connection. Agent downloads TLS is required for all domains. Service for download.newrelic.com is provided through Fastly and is subject to change without warning. For the most current list of public IP addresses for New Relic agent downloads, see api.fastly.com/public-ip-list. Infrastructure agents In order to report data to New Relic, our infrastructure monitoring needs outbound access to these domains, networks, and ports. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Infrastructure data Domains infra-api.newrelic.com identity-api.newrelic.com infrastructure-command-api.newrelic.com log-api.newrelic.com log-api.eu.newrelic.com metric-api.newrelic.com Networks For US region accounts: 162.247.240.0/22 For EU region accounts: 185.221.84.0/22 Port 443 Domains + Port For US region accounts: infra-api.newrelic.com:443 identity-api.newrelic.com:443 infrastructure-command-api.newrelic.com:443 log-api.newrelic.com:443 metric-api.newrelic.com:443 For EU region accounts: infra-api.eu.newrelic.com:443 identity-api.eu.newrelic.com:443 infrastructure-command-api.eu.newrelic.com:443 log-api.eu.newrelic.com:443 metric-api.eu.newrelic.com:443 Proxy If your system needs a proxy to connect to this domain, use the Infrastructure proxy setting. Browser domains In addition to the IP addresses for APM agents, applications monitored by our browser agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: bam.nr-data.net js-agent.newrelic.com For EU region accounts: eu01.nr-data.net bam.eu01.nr-data.net For more information about CDN access for the js-agent.newrelic.com file to the domain bam.nr-data.net or to one of the New Relic beacons, see Security for browser monitoring. Mobile domains In addition to the IP addresses for APM agents, applications monitored by our mobile agents use outgoing connections to the following domains. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: For US region accounts: mobile-collector.newrelic.com mobile-crash.newrelic.com mobile-symbol-upload.newrelic.com For EU region accounts: mobile-collector.eu01.nr-data.net mobile-crash.eu01.nr-data.net mobile-symbol-upload.eu01.nr-data.net Synthetic monitor public locations To configure your firewall to allow synthetic monitors to access your monitored URL, use Synthetic public minion IPs. TLS is required for all domains. Synthetic monitor private locations Synthetic private minions report to a specific endpoint based on region. Configure your firewall to allow the private minion to access the endpoint or the static IP addresses associated with the endpoint. These IP addresses may change in the future. TLS is required for all domains. Use the IP connections for account data in the US or European Union region as appropriate: IP connections Synthetics private location data Endpoint For US region accounts: https://synthetics-horde.nr-data.net/ For EU region accounts: https://synthetics-horde.eu01.nr-data.net/ IP addresses For US region accounts: 13.248.153.51 76.223.21.185 For EU region accounts: 185.221.86.57 185.221.86.25 Alerts webhooks, api.newrelic.com, and ticketing integrations Endpoints that use api.newrelic.com (such as our GraphQL API for NerdGraph) and our New Relic-generated webhooks for alert policies use an IP address from designated network blocks for the US or European Union region. TLS is required for all addresses in these blocks. Network blocks for US region accounts: 162.247.240.0/22 Network blocks for EU region accounts: 158.177.65.64/29 159.122.103.184/29 161.156.125.32/28 These network blocks also apply to third-party ticketing integrations. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.401276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "APM <em>agents</em>",
        "body": ". In addition, TLS 1.2 is required for most domains, except: APM <em>agent</em> connections Browser <em>agent</em> connections Mobile <em>agent</em> connections <em>Event</em> <em>API</em> For future updates to required and supported protocol versions, follow the Security Notifications tag in New Relic&#x27;s Explorers Hub. APM agents To enhance network"
      },
      "id": "5ebc9629e7b9d2be104b8159"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Summary",
        "Related information",
        "This site uses cookies 🍪"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2020-11-23T01:51:55Z",
      "updated_at": "2020-10-30T01:47:24Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Create a \"Hello, World!\" application 15 min Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it. Related information Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can see it directly on their homepage.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 472.31128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": " default class MyAwesome<em>NerdpackNerdletNerdlet</em> extends React.Component { render() { return &lt;h1&gt;&quot;Hello, World!&quot;&lt;&#x2F;h1&gt;; } } Copy Step 4 of 9 As an optional step, you can add a custom <em>launcher</em> icon using any image <em>file</em> named icon.png. Replace the default icon.png <em>file</em> under <em>launcher</em> by dragging in your <em>new</em>"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies 🍪"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-30T01:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 309.35654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " <em>CLI</em>, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A <em>Nerdpack</em> - The package containing all the files required by your application. It contains two types of files that you customize to build your app: <em>Nerdlets</em>, and the <em>launcher</em>. <em>One</em>"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications",
        "This site uses cookies 🍪"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-11-23T01:48:07Z",
      "updated_at": "2020-10-27T02:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.9909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": " to the app Handle duplicate applications Before you begin This guide requires the following: A <em>New</em> <em>Relic</em> <em>One</em> app or <em>Nerdpack</em> <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> A <em>Nerdpack</em> manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to <em>New</em> <em>Relic</em> <em>One</em> to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 248.88902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). nr1 profiles Manages the profiles you use to run <em>CLI</em> commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-10-30T01:48:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.57886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "info": "Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app.",
        "body": " application, you need to update its unique id by invoking the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. Once you&#x27;ve assigned a <em>new</em> UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 <em>nerdpack</em>:uuid -gf # Update the app unique ID"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies 🍪"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-11-23T01:50:29Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.1508,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Where to use our API keys",
        "User API key",
        "Ingest license key",
        "Ingest browser key",
        "REST API key",
        "Admin API key",
        "Insights insert API key",
        "Insights query API key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2020-11-21T21:03:37Z",
      "updated_at": "2020-11-21T21:03:36Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several types of APIs that require their own API keys. This resource describes our API keys, what they are used for, and how to access them. Where to use our API keys Different APIs use different types of API keys. Key type What it's for Where to access User API key (historically called \"personal API key\") Querying data in NerdGraph (our GraphQL API), accessing permissions for all endpoints in the New Relic REST API and API Explorer allowed for the user. View and create via the API keys screen in the UI. Ingest license key Configuring your agent so that it can send data to New Relic and getting metric, event, log, and trace API data into New Relic. View and create via the API keys screen in the UI. Ingest browser key Getting browser application API data into New Relic. View and create via the API keys screen in the UI. REST API key Required when using New Relic REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. A User API key can also be used for the REST API, and is subject to fewer limitations. View and regenerate via the REST API key page in the UI. Admin user API key Admin-only functionality with the REST API and API Explorer or with the Synthetics API. Only available for Admin users on the original user model. Access via the REST API key page in the UI. Insights insert key Inserting events into your account with HTTPS requests. Used with New Relic APIs for event, log, metric, or trace data. View and create via the Insights API keys screen in the UI. Insights query key Querying data in the Insights query API. View and create via the Insights API keys screen in the UI. User API key User keys are for querying data in NerdGraph (our GraphQL API), which allows you to query most data that New Relic collects. Users keys also grant full permissions to use any endpoints in the New Relic REST API and API Explorer that the user's permissions allow. Create a user API key Navigate to the API Keys screen and click the Create key button. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user API key Navigate to the API Keys screen. In the row of the user API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user API key Navigate to the API Keys screen. In the row of the user API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Ingest license key License keys are ingest keys used to get agent configuration and metric, event, log, and trace API data into New Relic. Create an ingest license API key Navigate to the API Keys screen and click the Create key button. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit an ingest license API key Navigate to the API Keys screen. In the row of the license API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete an ingest license API key Navigate to the API Keys screen. In the row of the license API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Ingest browser key Browser keys are ingest keys used to get browser application APIs data into New Relic. Create an insert browser key Navigate to the API Keys screen and click the Create key button. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit an ingest browser API key Navigate to the API Keys screen. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete an ingest browser API key Navigate to the API Keys screen. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key You can use a REST API key with New Relic's REST API or the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. A User API key can be used for the REST API as well, and is not subject to the one key per account limit. Activate or change REST API key Navigate to the REST API keys screen. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Navigate to the REST API keys screen. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Navigate to the REST API keys screen. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Admin API key Use the New Relic Admin API key to manage access to the REST API and API Explorer. Users can use the account REST API key to view data with the API Explorer while Owners and Admins can use an Admin user's API key to view, add, change, or delete data. The Admin user's API key grants full permissions to use the New Relic REST API and API Explorer, including GET > List, POST > Create, PUT > Add or Update, and DELETE functions. In addition, you must use your Admin API key to manage dashboards using the API Explorer functions, including CREATE > Post, UPDATE > Put, SHOW > Get, SHOW > List, and DELETE functions. Other account users cannot view dashboard data from the API Explorer or use the Dashboard API functions. Requirements and availability: Not available for users on the New Relic One user model, including accounts on our newer pricing plan. Requires an Owner or Admin user role. Each user can have one personal Admin user's API key per account. Activate or Regenerate Admin user's API key To activate Admin API access: Navigate to the REST API keys screen. Next to your name, select the generate [regenerate icon] icon to generate your Admin user's API key. Click (Show key) to view your account's new REST API key. Copy your Admin user's API key to use with New Relic's REST API. View Admin's API key An index of Admin user's API keys appears below the account's REST API key. The list includes the Admin's full name and the date their key was last used. You can view your own Admin user's API key: From the Admin index, select (Show key) for your name. You can only view other Admin's names. The keys for all other Admins are partially obscured. Regenerate Admin user's API key To change an Admin user's API key: Navigate to the REST API keys screen. Select the Admin user's [regenerate icon][repeat]icon. Confirm the deletion of the previous Admin user's API key by typing DELETION IS FOREVER in the text field. Select Regenerate. Copy the new Admin user's API key to use with New Relic's REST API. Delete an Admin's API key If you delete an Admin from the New Relic account, or change their role from Admin to User or Restricted user, this will also automatically remove their Admin user's API key. To delete an Admin user's API key: Before you delete an API key, make sure you have the correct account or sub-account. Navigate to the REST API keys screen. From the list of Admins, locate the person whose key must be deleted. Select the delete [trash can icon] icon for the REST API key or the Admin user's API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert API key This key is required for sending data via the Event API, Log API, Metric API, and Trace API, or via our integrations that use these APIs. This key reports custom data to New Relic, including event, log, metric, or trace data. Once your custom data is sent to us, you can query and visualize that data. Tips on availability and access: Because Insert API keys are associated with an account and not a specific user, anyone in the account with access to an Insert API key can use it. As a best practice for security purposes, we recommend you use different Insert API keys for different applications or different data sources. Generate an insert API key Navigate to the Insights API Key screen. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insert API key Navigate to the Insights API Key screen. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query API key Query keys are used with New Relic's query APIs to query data. You should structure your queries including your key based on the specifications for the API you're working with. Generate a query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify a Query key. Query keys are generated for an account. They are not associated with a specific user. Anyone in the account with access to the Query key can use it. To register an Query key: Navigate to the Insights API Key screen. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete a query key To edit or delete a Query key: Navigate to the Insights API Key screen. Under Query Keys, find the key you want to modify. Select Edit or Delete. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.46828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>",
        "sections": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>",
        "info": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>, who can use them, and how to add, update, or delete <em>API</em> <em>keys</em>.",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "body": " <em>API</em> <em>key</em>. Availability: Each <em>New</em> <em>Relic</em> <em>account</em> can have only <em>one</em> REST <em>API</em> <em>key</em>. A User <em>API</em> <em>key</em> can be used for the REST <em>API</em> as well, and is not subject to the <em>one</em> <em>key</em> per <em>account</em> limit. Activate or change REST <em>API</em> <em>key</em> Navigate to the REST <em>API</em> keys screen. Click Regenerate REST <em>API</em> <em>key</em>. Click (Show <em>key</em>"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "category_2": "Browser Pro features",
      "nodeid": 11696,
      "sections": [
        "Browser monitoring",
        "Getting started",
        "Guides",
        "Installation",
        "Configuration",
        "Browser agent and SPA API",
        "Page load timing resources",
        "Browser Pro features",
        "Additional standard features",
        "Performance quality",
        "Troubleshooting",
        "Upload source maps via API",
        "Prepare for using the source map API",
        "Push source maps to New Relic",
        "Use npm module via command line or client-side script",
        "Use API via curl",
        "Troubleshoot source maps",
        "For more help"
      ],
      "title": "Upload source maps via API",
      "category_0": "Browser monitoring",
      "type": "docs",
      "category_1": "Browser monitoring",
      "external_id": "6bc1cf3a1c7f6a2b7bdf464b7a6578b093950182",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/upload-source-maps-api",
      "published_at": "2020-11-21T19:17:16Z",
      "updated_at": "2020-11-21T19:17:15Z",
      "breadcrumb": "Contents / Browser monitoring / Browser monitoring / Browser Pro features",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic browser monitoring, how to upload and use source maps with the Browser API.",
      "body": "Browser monitoring supports the uploading of source maps, which are used to un-minify error stack traces on the JS errors page. This document explains how to use the API to publish (upload) source maps to Browser. Prepare for using the source map API In order to upload source maps to Browser via the API, you'll need this information: A user API key (before November 20, 2020, the Admin API key was required; that will still work if already in place) The New Relic application ID for the deployed app The full JavaScript file URL Optionally, if the JavaScript URL doesn't automatically have release info appended to it, the release name and ID What is the JavaScript URL? Every time the agent captures an error in your code, it's associated with the URL of the JavaScript in which it occurred. This is the src attribute of the script tag in your HTML. This full JavaScript URL is required when sending source maps to Browser. You can find the URL for an error's JavaScript file in Browser, on the JS errors page. See Browser monitoring source maps for more on finding these errors in the UI. Is a release name and ID required? Many organizations include a version number or hash in the JavaScript URL. This is generally added to \"bust\" caches to ensure your users get the most recent version of your code. This type of URL might look something like: https://example.com/assets/application-59.min.js https://example.com/assets/bundle-d6d031.min.js https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js If your app's URLs automatically have the version info appended to it, the Browser agent has everything it needs in order to match errors with your code. You can move ahead to generating source maps. If this doesn't apply to you, and JS URLs do not have version info appended, you’ll have to assist the agent by specifying a release name and ID with the API. Are there limits to source map uploads? There is no limit to the overall number of source maps you can upload. However, the API is rate-limited: You can upload a maximum of 100 source maps per minute You can upload a maximum of 5,000 source maps per day Source map files can be a maximum of 50Mb in size. Push source maps to New Relic Now that you have one or more source maps, you are ready to publish it to Browser. You can use any of these methods to send source maps to Browser: Use the New Relic npm module with the API via the command line or via a client-side JavaScript build/deploy script like Gulp or Grunt. Use API curl commands. Use the Browser UI. Use npm module via command line or client-side script The easiest and recommended way to upload source maps to Browser is to use the our new @newrelic/publish-sourcemap npm module. It provides a command line tool and Javascript API to accomplish this task. More documentation is available in the npm repo. Here are some examples of using the npm module via the command line. The following examples are for US accounts. For EU accounts, the endpoint is https://sourcemaps.service.eu.newrelic.com. For more information, see Introduction to the EU region data center. npm command line: Publish Here's an example of uploading source maps using the npm module via the command line. Note that the source map can come from a local file or a remote URL. npm install -g @newrelic/publish-sourcemap publish-sourcemap PATH_TO_SOURCE_MAP_FILE (local or remote) PATH_TO_ORIGINAL_FILE --apiKey=YOUR_NEW_RELIC_USER_API_KEY --applicationId=YOUR_NEW_RELIC_APP_ID npm command line: List published maps Here's an example of listing published source maps: list-sourcemaps --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_KEY Options: --applicationId Browser application id --apiKey New Relic user API key npm command line: Delete Here's an example of deleting a source map: delete-sourcemap --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_API_KEY --sourcemapId=YOUR_SOURCE_MAP_ID Options: --applicationId Browser application id --apiKey New Relic user API key --sourcemapId Unique id generated for a source map Here are some examples of using the npm module to publish from client-side JavaScript: npm via Node.js script: Publish Here's an example of publishing a source map via a Node.js script: var publishSourcemap = require(‘@newrelic/publish-sourcemap’).publishSourcemap publishSourcemap({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY' }, function (err) { console.log(err || 'Sourcemap upload done')}) npm via Node.js script: List published maps Here's an example of listing all published source maps: var listSourcemaps = require(‘@newrelic/publish-sourcemap’).listSourcemaps listSourcemaps({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err, res) { console.log(err || res.body)}) npm via Node.js script: Delete Here's an example of deleting a source map file via a Node.js script: var deleteSourcemap = require(‘@newrelic/publish-sourcemap’).deleteSourcemap deleteSourcemap({ sourcemapId: 'SOURCE_MAP_ID', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err) { console.log(err || 'Deleted source map')}) When you're done, go to the JS errors page in Browser, select an error grouping, and see if your error stack traces have been un-minified. Use API via curl Below are some examples of using curl to publish, list, and delete source maps: curl: Upload maps An example of using API via curl to publish maps to Browser: curl -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ -F \"sourcemap=@SOURCE_MAP_PATH\" \\ -F \"javascriptUrl=JS_URL\" \\ -F \"releaseId=YOUR_RELEASE_ID\" \\ -F \"releaseName=YOUR_UI_PAGE\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps curl: List existing maps Below is an example of how to get a list of source maps previously uploaded to New Relic via curl. New Relic returns the source map's unique SOURCEMAP_ID and its components: curl \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps curl: Delete map To delete a source map: Use the GET endpoint to list existing source maps and locate the SOURCEMAP_ID. Run the following command via curl: curl -X DELETE \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps/SOURCEMAP_ID When you're done, go to the JS errors page in Browser, select an error grouping, and see if your error stack traces have been un-minified. Troubleshoot source maps If you are having trouble generating source maps from your build system, or if your errors in Browser are remaining minified, see the source maps troubleshooting documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.3905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upload source maps via <em>API</em>",
        "sections": "Push source maps to <em>New</em> <em>Relic</em>",
        "info": "For <em>New</em> <em>Relic</em> browser monitoring, how to upload and use source maps with the Browser <em>API</em>.",
        "body": " the <em>API</em>, you&#x27;ll need this information: A user <em>API</em> <em>key</em> (before November 20, 2020, the Admin <em>API</em> <em>key</em> was required; that will still work if already in place) The <em>New</em> <em>Relic</em> application ID for the deployed app The full JavaScript file URL Optionally, if the JavaScript URL doesn&#x27;t automatically have release"
      },
      "id": "5c6905d607552356e245ca12"
    },
    {
      "category_2": "Label examples",
      "nodeid": 8916,
      "sections": [
        "Synthetics REST API",
        "Monitor examples",
        "Label examples",
        "Secure credentials examples",
        "Use Synthetics label APIs",
        "Requirements",
        "API examples",
        "For more help"
      ],
      "title": "Use Synthetics label APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Synthetics REST API",
      "external_id": "bbd777a90bfc7c2af48dfa8ff28aca91b4d7cb71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/label-examples/use-synthetics-label-apis",
      "published_at": "2020-11-22T00:06:23Z",
      "updated_at": "2020-11-22T00:06:23Z",
      "breadcrumb": "Contents / APIs / Synthetics REST API / Label examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Deprecated: Using the New Relic REST API to manage synthetic monitor labels. ",
      "body": "DEPRECATED On July 20, 2020, the New Relic One tagging functionality replaces synthetic labels and the ability to organize Synthetics and APM tags into groups. For more information, including how to migrate your existing tags through the UI or NerdGraph tagging API, see New Relic's Explorers Hub post. You can make API calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls from the command line. You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. API examples The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Add a label to a monitor To add a label to a monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X POST -H 'X-Api-Key:Admin_User_Key' -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels -d 'category:label' Get all monitors using a specific label To view a list of all monitors in New Relic that have the same label, replace category:label in the following example with the specific value. curl -v -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/labels/category:label Dissociate a label from a monitor To dissociate a label from an existing monitor in New Relic, replace the monitor_uuid and category:label in the following example with your specific values. curl -v -X DELETE -H 'X-Api-Key:Admin_User_Key' https://synthetics.newrelic.com/synthetics/api/v4/monitors/monitor_uuid/labels/category:label For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.94098,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Synthetics label <em>APIs</em>",
        "sections": "Synthetics REST <em>API</em>",
        "info": "Deprecated: Using the <em>New</em> <em>Relic</em> REST <em>API</em> to manage synthetic monitor labels. ",
        "category_0": "<em>APIs</em>",
        "category_1": "Synthetics REST <em>API</em>",
        "body": " post. You can make <em>API</em> calls for synthetic monitors or for monitor labels. These examples show curl commands. Requirements To use the REST <em>API</em> for <em>New</em> <em>Relic</em>&#x27;s synthetic monitoring, you must activate <em>API</em> access and generate your Admin User&#x27;s <em>API</em> <em>key</em> from your <em>account</em> settings. Then you can make",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; Synthetics REST <em>API</em> &#x2F; Label examples"
      },
      "id": "57036374e621f41ff8000162"
    },
    {
      "nodeid": 40561,
      "sections": [
        "AWS Lambda monitoring",
        "Get started",
        "Enable Lambda monitoring",
        "UI and data",
        "Troubleshooting",
        "Enable serverless monitoring using the Lambda layer",
        "How does it work",
        "What's in the New Relic Lambda layer?",
        "What do you need",
        "Enable serverless monitoring",
        "Link your AWS account with your New Relic account",
        "Install or upgrade the Lambda layer",
        "Cannot Use AWS Secrets Manager",
        "Multiple AWS regions and accounts",
        "Failure to retrieve license key AccessDeniedException",
        "What's next?",
        "For more help"
      ],
      "title": "Enable serverless monitoring using the Lambda layer",
      "category_0": "Serverless function monitoring",
      "type": "docs",
      "category_1": "AWS Lambda monitoring",
      "external_id": "4e02284071d72a72b07b32710264bf17efefe3c1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-using-lambda-layer",
      "published_at": "2020-11-21T22:46:11Z",
      "updated_at": "2020-11-15T11:00:24Z",
      "breadcrumb": "Contents / Serverless function monitoring / AWS Lambda monitoring / Enable Lambda monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to enable Lambda monitoring using our Lambda layer and get started using it.",
      "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. Read on to learn how to enable this feature using our Lambda layer and get started using it. Using this feature may result in AWS charges. See Lambda monitoring requirements.​​​​​​​​​​ How does it work When you enable serverless monitoring using our Lambda extension, this is what happens: Lambda monitoring with the New Relic Lambda layer You configure your Lambda function to include our layer for the runtime you've chosen. As your code runs, our Lambda layer gathers telemetry data about the invocation and its execution. Just before execution finishes, the Lambda layer sends the data it has gathered to the New Relic Lambda extension, which is bundled with the layer. The extension sends the data to New Relic, along with additional information from AWS Lambda. What's in the New Relic Lambda layer? The layer for your runtime contains the New Relic Lambda extension. This executable extends your Lambda function. The extension sends telemetry data to New Relic, and interacts with AWS directly to enhance the data we gather, while minimizing the impact of instrumentation on your application's performance. For Node.js and Python, the layer contains the New Relic agent code, and a wrapper for your Lambda handler. For other runtimes, we take an SDK approach, providing you with the tools to instrument your code, while taking advantage of emerging standards like OpenTracing and OpenTelemetry. What do you need To enable serverless monitoring using our Lambda layer, you need the following: AWS CLI v2 installed and configured using aws configure. Python version 3.3 or higher installed. newrelic-lambda CLI, which you can install by running pip install newrelic-lambda-cli. A New Relic account. You must be an admin, or have the Infrastructure manager add-on role. A personal API key. An AWS account with permissions for creating IAM resources, managed secrets, and Lambdas. You also need permissions for creating CloudFormation stacks and S3 buckets. Note that you may need to use pip3 instead of pip if your system uses Python 2 by default. Enable serverless monitoring There are a few things that have to happen to let New Relic gather telemetry from your Lambda functions. Link your AWS account with your New Relic account. Configure each of your functions to include our Lambda extension. While there are several ways to accomplish both steps, this guide focuses on the most frequent setup scenario. Link your AWS account with your New Relic account When you link your AWS account to New Relic, you're granting permission to New Relic to create an inventory of your AWS account, and gather CloudWatch metrics for your Lambda functions. Resources in your AWS account then show up as entities in the entity explorer, decorated with config information. When all the requirements are in place, link your AWS account with your New Relic account by running the following command using your personal API key (replace all the highlighted values): newrelic-lambda integrations install --nr-account-id YOUR_NR_ACCOUNT_ID \\ --linked-account-name YOUR_LINKED_ACCOUNT_NAME \\ --nr-api-key YOUR_NR_API_KEY The newrelic-lambda CLI adds your New Relic License Key as a secret in AWS Secret Manager for greater security. The --linked-account-name parameter is to name the integration that will appear in New Relic. Storing the New Relic license key in the AWS Secrets Manager Your New Relic license key identifies and authenticates you to New Relic, allowing us to associate your telemetry with your New Relic account. Each function that sends telemetry needs access to this value, and it needs to be managed securely. The AWS Secrets Manager solves these problems. If your organization prevents you from using AWS Secrets Manager, see below for an alternative method to set your license key. Install or upgrade the Lambda layer After linking your accounts, you have to install or upgrade the New Relic Lambda layer to the latest version. All future layers versions will include the Lambda extension by default. To install/upgrade the layer, run: newrelic-lambda layers install --nr-account-id YOUR_NR_ACCOUNT_ID --function my-function --upgrade This command automatically finds the available layer for your Lambda's region and runtime. If the layer can't be found, you can add a layer manually. To add the layer manually, read our example code. Deploy our examples and verify they work Once you've linked your AWS and New Relic accounts, instrumenting your Lambda function using our Lambda extension involves a series of steps: Pick an example and install it. Invoke the Lambda and see data in New Relic. Clean up and adapt the example to your code. We recommend trying out our example code for the following languages: Node.js Python Go Java .NET Each example contains instructions, sample code, and a deploy script to get started. After you've gotten the example to work for you, you can clean up by deleting the CloudFormation stack, using either the AWS Console, or the AWS CLI: aws cloudformation delete-stack --stack-name <stack-name> Our examples are based on the AWS SAM CLI. There are other tools available for managing and deploying Lambda functions. New Relic offers a plugin for the Serverless Framework, and the CLI can modify your existing Lambda functions to add instrumentation. You can integrate the necessary Lambda layer and function permission using whatever AWS resource management tool you choose. Troubleshooting Cannot Use AWS Secrets Manager If your organization does not allow the use of AWS Secrets Manager, the New Relic Lambda Extension will accept a NEW_RELIC_LICENSE_KEY environment variable. Add the --disable-license-key-secret flag from the newrelic-lambda integrations install command. Then Set this environment variable to your New Relic License Key in your Lambda function configuration. Multiple AWS regions and accounts The newrelic-lambda CLI should be run once per region, with the --aws-region parameter. Use the same linked account name, and the tool will detect that the account link has been created already. The license key secret needs to be created in each region. Similarly, several AWS accounts can be linked to a New Relic account. Give each account a different linked account name. The --aws-profile argument to the CLI tool will select the named profile. The tool uses the same configuration as the AWS CLI. Failure to retrieve license key AccessDeniedException Your lambda code requires the execution role which has permission to read AWS Secrets Manager. If you find a log like the following, add the appropriate permission to the policy of the execution role. In our examples, check out the template.yaml file to see an easy way to grant this permission. Failed to retrieve license key AccessDeniedException: User: <ARN> is not authorized to perform: secretsmanager:GetSecretValue on resource: <ARN> What's next? After you complete these steps, here's what you can do next: Adapt the example code to your Lambda functions to start monitoring production code. See data reporting in the Lambda monitoring UI. If you're having trouble finding your data, see Lambda enable troubleshooting. Use configuration settings to fine-tune your data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.40552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Link your AWS <em>account</em> with your <em>New</em> <em>Relic</em> <em>account</em>",
        "body": " your personal <em>API</em> <em>key</em> (replace all the highlighted values): newrelic-lambda integrations install --nr-<em>account</em>-id YOUR_NR_<em>ACCOUNT</em>_ID \\ --linked-<em>account</em>-name YOUR_LINKED_<em>ACCOUNT</em>_NAME \\ --nr-<em>api</em>-<em>key</em> YOUR_NR_<em>API_KEY</em> The newrelic-lambda <em>CLI</em> adds your <em>New</em> <em>Relic</em> License <em>Key</em> as a secret in AWS Secret Manager"
      },
      "id": "5f8146e5e7b9d24ea5451141"
    }
  ],
  "/collect-data/custom-events": [
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-11-21T18:20:34Z",
      "updated_at": "2020-10-18T07:41:12Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.59103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> <em>events</em> to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> <em>APIs</em>, Browser <em>agent</em> <em>APIs</em>, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Manage data",
      "nodeid": 37701,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Drop data using NerdGraph",
        "Requirements",
        "Create drop data rule",
        "NRQL restrictions",
        "Example drop rules",
        "Verify your drop rule works",
        "View rules",
        "Delete drop rules",
        "Audit drop rule history",
        "Cautions when dropping data",
        "Learn more",
        "For more help"
      ],
      "title": "Drop data using NerdGraph",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "06e7cd1ec25f92d3cb16660991adb3e7e4694238",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/data-management/drop-data-using-nerdgraph",
      "published_at": "2020-11-21T17:32:48Z",
      "updated_at": "2020-11-21T17:32:48Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Manage data",
      "document_type": "page",
      "popularity": 1,
      "info": "Using the New Relic NerdGraph API, you can drop some specific types of data that meet the criteria you set. ",
      "body": "For some types of data in New Relic, you can drop (not report) that data. You might want to do this: To filter out unimportant, low-value data To filter out potentially sensitive data If you choose to drop data, only new data will be affected. Existing data cannot be edited or deleted. Requirements You must have a user role with permissions for dropping data. Currently the following types of data can be targeted by data dropping rules: APM-reported events Browser-reported events Mobile-reported events Synthetics-reported events Custom events (like those generated by the APM agent APIs or the Event API) Log data Trace spans Metrics from the metric API Currently only DROP_ATTRIBUTES, not DROP_DATA​​​​, can be used on metrics Metrics generated from events-to-metrics are not eligible Support for additional types are planned for the future. Create drop data rule Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, please review caution information below. To drop data, create a NerdGraph-format drop rule that includes: A NRQL string that specifies what data types to drop An action type specifying how to apply the NRQL string You can form and make the call in the NerdGraph explorer. There are two ways to drop data: Drop entire data types or a data subset (with optional filter). This uses the DROP_DATA action type and uses NRQL of the form: SELECT * FROM DATA_TYPE_1, DATA_TYPE_2 (WHERE OPTIONAL_FILTER) For this type of drop rule, you cannot use anything other than * in the SELECT clause. Drop attributes from data types (with optional filter). This uses the DROP_ATTRIBUTES action type and uses NRQL of the form: SELECT dropAttr1, dropAttr2 FROM DATA_TYPE (WHERE OPTIONAL_FILTER) For this type of drop rule, you must pass in a non-empty list of raw attributes names. NRQL restrictions Not all NRQL clauses make sense for generating drop rules. You can provide a WHERE clause to select data with specific attributes. Other features such as TIMESERIES, COMPARE WITH, FACET, and other clauses cannot be used. The two action types have these restrictions: DROP_DATA can use only SELECT *. DROP_ATTRIBUTES requires use of SELECT with \"raw\" attributes (attributes with no aggregator function applied). This also means you cannot use SELECT *. Additionally, there are some attributes that are integral to their data type and cannot be dropped (such as timestamp on event data). If you include them, registration will fail. Example drop rules Here are some example drop rules: Drop two event types Let's say you notice you have some event types being sent to New Relic that are not important to you. Also, stopping the source from sending those event types quickly is unrealistic, requiring changes to agents and/or API instrumentation. Using a drop rule is an easier way to accomplish the same goal. Here is an example NerdGraph call that drops two event types: Event1 and Event2. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM Event1, Event2\" description: \"Drops all data for Event1 and Event2.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Drop events meeting certain criteria Let’s say you have a high volume custom event type that arrives from multiple sources. If you don't find all of that data important, you can use a drop rule. Here is an example of a drop rule that filters out events based on specific criteria. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM MyCustomEvent WHERE appName='LoadGeneratingApp' AND environment='development'\" description: \"Drops all data for MyCustomEvent that comes from the LoadGeneratingApp in the dev environment, because there is too much and we don’t look at it.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Drop sensitive attributes while maintaining the rest of the data Let's say you noticed an event has attributes that contain Personally Identifiable Information (PII). You are working to update your services to stop sending the data, but until then, you need to cease storing further PII in New Relic. Although you could drop all of the data as it comes in the door with a DROP_DATA rule, the rest of the data still provides value. Therefore, you can register a drop rule to remove only the offending PII from your data: mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_ATTRIBUTES nrql: \"SELECT userEmail, userName FROM MyCustomEvent description: \"Removes the user name and email fields from MyCustomEvent\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Verify your drop rule works After you create a drop rule, verify that it is working as expected. The rule should take effect quickly after a successful registration, so try running a TIMESERIES version of the query you registered to see that the data drops off. Drop rule type NRQL DROP_DATA Drop rule NRQL: SELECT * FROM MyEvent WHERE foo = bar Validation NRQL: SELECT count(*) FROM MyEvent WHERE foo = bar TIMESERIES This should drop to 0. To verify that it did not affect any thing else, invert the WHERE clause. DROP_ATTRIBUTES Drop rule NRQL: SELECT dropAttr1, dropAttr2 FROM MyEvent WHERE foo = bar Validation NRQL: SELECT count(dropAttr1), count(dropAttr2) FROM MyEvent WHERE foo = bar TIMESERIES Both lines should drop to 0. To verify that it did not affect events that contained these attributes and still should, invert the WHERE clause. View rules Here is an example NerdGraph call that returns the drop rules set on an account: { actor { account(id: YOUR_ACCOUNT_ID) { nrqlDropRules { list { rules { id nrql accountId action createdBy createdAt description } error { reason description } } } } } } Delete drop rules Here is an example NerdGraph call deleting two specific drop rules: mutation { nrqlDropRulesDelete(accountId: YOUR_ACCOUNT_ID, ruleIds: [\"48\", \"98\"]) { successes { id nrql accountId action description } failures { error { reason description } submitted { ruleId accountId } } } } Audit drop rule history To see who created and deleted drop rules, query your account audit logs. The list endpoint also includes the user ID of the person who created the rule. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Only new data will be dropped. Existing data cannot be edited or deleted. Learn more Recommendations for learning more: NerdGraph basics and terminology NRQL basics Browse the Explorers Hub for community discussions about NRQL drop rules. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.241405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Convert <em>event</em> data to metrics",
        "info": "Using the New Relic NerdGraph <em>API</em>, you can drop some specific types of data that meet the criteria you set. ",
        "body": " You must have a user role with permissions for dropping data. Currently the following types of data can be targeted by data dropping rules: APM-reported <em>events</em> Browser-reported <em>events</em> Mobile-reported <em>events</em> Synthetics-reported <em>events</em> <em>Custom</em> <em>events</em> (like those generated by the APM <em>agent</em> <em>APIs</em>"
      },
      "id": "5e7b6e26196a6714b902bd57"
    },
    {
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API",
        "This site uses cookies 🍪"
      ],
      "title": "Collect data from any source",
      "type": "developer",
      "tags": [
        "Agent API",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API"
      ],
      "external_id": "5bfb043fffe42ea4a78d5a90bf8e92aa8b8f8c33",
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/",
      "published_at": "2020-11-23T01:45:56Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Open source emitters. APIs. New Relic agents. Get data from anywhere. ",
      "body": "Collect data from any source 15 min New Relic products report a lot of data “out of the box.” When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don’t have Zipkin-format data, you’d use this) bash Copy $ curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -H 'Data-Format: newrelic' \\ > -H 'Data-Format-Version: 1' \\ > -d '[ $ { $ \"common\": { $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host123.test.com\" $ } $ }, $ \"spans\": [ $ { $ \"trace.id\": \"123456\", $ \"id\": \"ABC\", $ \"attributes\": { $ \"duration.ms\": 12.53, $ \"name\": \"/home\" $ } $ }, $ { $ \"trace.id\": \"123456\", $ \"id\": \"DEF\", $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host456.test.com\", $ \"duration.ms\": 2.97, $ \"name\": \"/auth\", $ \"parent.id\": \"ABC\" $ } $ } $ ] $ } $ ]' Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. bash Copy $ curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"metrics\": [ $ { $ \"name\": \"memory.heap\", $ \"type\": \"gauge\", $ \"value\": 2.3, $ \"timestamp\": 1531414060739, $ \"attributes\": { $ \"host.name\": \"dev.server.com\" $ } $ } $ ] $ } $ ]' Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) bash Copy $ curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ > -H \"Content-Type: application/json\" \\ > -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"eventType\": \"LoginEvent\", $ \"service\": \"login-service\", $ \"customerId\": \"xyz\" $ } $ ]' Step 6 of 6 Log API If our existing logging integrations don’t meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) bash Copy $ curl -i -X POST https://log-api.newrelic.com/log/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ \"logs\": [ $ { $ \"timestamp\": 1593538496000, $ \"message\": \"User xyz logged in\", $ \"service\": \"login-service\", $ \"hostname\": \"login.example.com\" $ } $ ] $ ]'",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.225086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "info": "Open source emitters. <em>APIs</em>. New Relic <em>agents</em>. Get data from anywhere. ",
        "tags": "<em>Agent</em> <em>API</em>",
        "body": " agents to report data, you can use their associated <em>APIs</em> to report <em>custom</em> data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up <em>custom</em> instrumentation. See the <em>agent</em> <em>APIs</em>. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language"
      },
      "id": "5efa997128ccbc3c9a307dfd"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-11-21T15:33:29Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.97159,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "An overview of the options for sending <em>custom</em> <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "body": " retention policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Custom events",
      "nodeid": 6256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "APM: Report custom events",
        "Data considerations",
        "Record a custom event",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words",
        "For more help"
      ],
      "title": "APM: Report custom events",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "external_id": "0c3f09d0d0e04ad50bedcdf7088eed7c171001d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "published_at": "2020-11-21T23:20:04Z",
      "updated_at": "2020-10-18T15:16:18Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic APM: how to report custom events and attributes.",
      "body": "If you have APM, you can report custom event data, which is then available for querying in New Relic. Related documentation: Add custom attributes to existing events Send custom events using the Event API (without need for APM) Custom events sent with the agent APIs are not compatible with high security mode. Data considerations The New Relic agents sends event data to New Relic as part of its normal harvest cycle every 5 seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record a custom event To record a custom event, follow the procedure for your New Relic language agent: C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 To disable custom events entirely, add the following to your newrelic.yml:​ custom_insights_events: enabled: false For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see Limits and restricted characters and Reserved words. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see Limits and restricted characters and Reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.39061,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em>",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "New Relic APM: how to report <em>custom</em> <em>events</em> and attributes.",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;<em>event</em>-data-sources&#x2F;<em>custom</em>-<em>events</em>&#x2F;apm-report-<em>custom</em>-<em>events</em>",
        "body": "If you have APM, you can report <em>custom</em> <em>event</em> data, which is then available for querying in New Relic. Related documentation: Add <em>custom</em> attributes to existing <em>events</em> Send <em>custom</em> <em>events</em> using the <em>Event</em> <em>API</em> (without need for APM) <em>Custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5f480a5a64441f578bfdcdb1"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-header-cell/",
      "sections": [
        "TableHeaderCell",
        "Usage",
        "Props",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:45:56Z",
      "title": "TableHeaderCell",
      "updated_at": "2020-08-03T04:46:36Z",
      "type": "developer",
      "external_id": "2a4be1419d1a6e501a8eed915b8acf7c9798259d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableHeaderCell component!",
      "body": "TableHeaderCell Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 445.59958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableHeaderCell</em>",
        "sections": "<em>TableHeaderCell</em>",
        "info": "A <em>TableHeaderCell</em> <em>component</em>!",
        "body": "<em>TableHeaderCell</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa9906196a67523e76646e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-row/",
      "sections": [
        "TableRow",
        "Usage",
        "Props",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:47:03Z",
      "title": "TableRow",
      "updated_at": "2020-08-03T04:45:42Z",
      "type": "developer",
      "external_id": "b9ca0d4e07a506dd961eb2194c5344bfa9ab770d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableRow component!",
      "body": "TableRow Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 373.37186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableRow</em>",
        "sections": "<em>TableRow</em>",
        "info": "A <em>TableRow</em> <em>component</em>!",
        "body": "<em>TableRow</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa98d564441f93435f7e24"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 317.54315,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the NerdGraphQuery <em>component</em> to an <em>application</em>",
        "body": " picker to your <em>app</em> Add a time picker to a sample application 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to New Relic One 30 min Add a <em>table</em> to your <em>app</em> Add a <em>table</em> to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "Installation",
      "nodeid": 36841,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Configure control plane monitoring",
        "Features",
        "Compatibility and requirements",
        "Discovery of master nodes and control plane components",
        "Configuration",
        "ETCD",
        "API server",
        "OpenShift configuration",
        "Set up mTLS from the ETCD client CA",
        "Set up mTLS for ETCD in OpenShift",
        "See your data",
        "For more help"
      ],
      "title": "Configure control plane monitoring",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "6bfd11636535081afb3ef8058362d6bd3296e3ce",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/new-relic-one-k8s-cluster-explorer-control-plane-parameters.png?itok=cLymrxv6",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring",
      "published_at": "2020-11-21T20:01:23Z",
      "updated_at": "2020-11-18T21:15:35Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to configure control plane monitoring for your Kubernetes integration with New Relic.",
      "body": "New Relic provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster's Control Plane components. That data can then be found in New Relic and used to create queries and charts. Control plane monitoring requires Kubernetes integration version 1.11.0 or higher. Features We monitor and collect metrics from the following control plane components: ETCD: leader information, resident memory size, number of OS threads, consensus proposals data, etc. For a list of supported metrics, see ETCD data. API server: rate of apiserver requests, breakdown of apiserver requests by HTTP method and response code, etc. For the complete list of supported metrics, see API server data. Scheduler: requested CPU/memory vs available on the node, tolerations to taints, any set affinity or anti-affinity, etc. For the complete list of supported metrics, see Scheduler data. Controller manager: resident memory size, number of OS threads created, goroutines currently existing, etc. For the complete list of supported metrics, see Controller manager data. Compatibility and requirements Control plane monitoring requires Kubernetes integration version 1.11.0 or higher. Control plane monitoring support is not enabled for managed clusters. This is because providers (EKS, GKE, AKS, etc.) abstract away the concept of master nodes and control plane components, so that access to them is limited or non-existent. The unprivileged version of the Kubernetes integration does not support control plane monitoring. OpenShift 4.x uses control plane component metric endpoints that are different than the default. Discovery of master nodes and control plane components The Kubernetes integration relies on the kubeadm labeling conventions to discover the master nodes and the control plane components. This means that master nodes should be labeled with node-role.kubernetes.io/master=\"\" or kubernetes.io/role=\"master\". The control plane components should have either the k8s-app or the tier and component labels. Refer to the following table for accepted label combinations and values: Component Label Endpoint API server Kubeadm / Kops / ClusterAPI k8s-app=kube-apiserver tier=control-plane component=kube-apiserver OpenShift app=openshift-kube-apiserver apiserver=true localhost:443/metrics by default (can be configured) if the request fails falls back to localhost:8080/metrics ETCD Kubeadm / Kops / ClusterAPI k8s-app=etcd-manager-main tier=control-plane component=etcd OpenShift k8s-app=etcd localhost:4001/metrics Scheduler Kubeadm / Kops / ClusterAPI k8s-app=kube-scheduler tier=control-plane component=kube-scheduler OpenShift app=openshift-kube-scheduler scheduler=true localhost:10251/metrics Controller manager Kubeadm / Kops / ClusterAPI k8s-app=kube-controller-manager tier=control-plane component=kube-controller-manager​ OpenShift app=kube-controller-manager kube-controller-manager=true localhost:10252/metrics When the integration detects that it is running inside a master node, it tries to find which components are running on the node by looking for pods that match the labels listed in the table above. For every running component, the integration makes a request to its metrics endpoint. Configuration Control plane monitoring is automatic for agents running inside master nodes. The only component that requires an extra step to run is ETCD, because it uses mutual TLS authentication (mTLS) for client requests. The API Server can also be configured to be queried using the Secure Port. Control plane monitoring for OpenShift 4.x requires additional configuration. For more information, see the OpenShift 4.x Configuration section. ETCD In order to set mTLS for querying ETCD, there are two configuration options that need to be set: Option Value ETCD_TLS_SECRET_NAME Name of a Kubernetes secret that contains the mTLS configuration. The secret should contain the following keys: cert: the certificate that identifies the client making the request. It should be signed by an ETCD trusted CA. key: the private key used to generate the client certificate. cacert: the root CA used to identify the ETCD server certificate. If the ETCD_TLS_SECRET_NAME option is not set, ETCD metrics won't be fetched. For step by step instructions on how to create a certificate and sign it with the ETCD client CA, see Set up mTLS from the ETCD client CA. ETCD_TLS_SECRET_NAMESPACE The namespace where the secret specified in the ETCD_TLS_SECRET_NAME was created. If not set, the default namespace is used. API server By default, the API server metrics are queried using the localhost:8080 unsecured endpoint. If this port is disabled, you can also query these metrics over the secure port. To enable this, set the following configuration option in the Kubernetes integration manifest file: Option Value API_SERVER_ENDPOINT_URL The (secure) URL to query the metrics. The API server uses localhost:443 by default Ensure that the ClusterRole has been updated to the newest version found in the manifest Added in version 1.15.0 Note that the port can be different according to the secure port used by the API server. For example, in Minikube the API server secure port is 8443 and therefore API_SERVER_ENDPOINT_URL should be set to https://localhost:8443 OpenShift configuration Control plane components on OpenShift 4.x use endpoint URLs that require SSL and service account based authentication. Therefore, the default endpoint URLs can not be used. To configure control plane monitoring on OpenShift, uncomment the following environment variables in the customized manifest. URL values are pre-configured to the default base URLs for the control plane monitoring metrics endpoints in OpenShift 4.x. - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259 - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" Even though the custom ETCD_ENDPOINT_URL is defined, ETCD requires HTTPS and mTLS authentication to be configured. For more on configuring mTLS for ETCD in OpenShift, see Set up mTLS for ETCD in OpenShift. When installing through Helm openshift, specify the config to automatically include these endpoints. Setting openshift.enabled=true and openshift.version=\"4.x\" will include the secure endpoints and enable the /var/run/crio.sock runtime. Set up mTLS from the ETCD client CA The instructions below are based on the Kubernetes documentation. For more information, see Managing TLS certificates in a cluster. For OpenShift, see Set up mTLS for ETCD in OpenShift. To set up mTLS from the ETCD client CA: Download and install the tool cfssl, selecting the correct binaries for your OS from the list. Once installed, execute the following command: cat <<EOF | cfssl genkey - | cfssljson -bare server { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF This command generates two files; server.csr containing the PEM encoded pkcs#10 certification request and server-key.pem containing the PEM encoded key to the certificate to be created. Use the generated certificate authority (CA) of ETCD to sign your CSR. Depending on your cluster configuration, you may already have this information. For default install configuration, download the CA certificate and the private key directly from ETCD with the following commands: kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system This requires that the etcd-manager-main pod has the label k8s-app=etcd-manager-main, which is a requirement for control plane monitoring . If your etc-manager-main pod is located in a different namespace, change the -n kube-system flags accordingly. With those files downloaded, use the following command to sign your CSRF: cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert Create the secret that is used to retrieve the TLS config for making requests to ETC. We recommend renaming the certificate and the private key: cp cert.pem cert && cp server-key.pem key kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert To ease future installations Use the following commands to simultaneously create the CSR, retrieve the CA, generate the certificate by signing the CSR, and create the secret with all the required fields: cat <<EOF | cfssl genkey - | cfssljson -bare server && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system && \\ cp server-key.pem key && \\ cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert && \\ cp cert.pem cert && \\ kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF The last step is to update the configuration in the manifest and apply it. In the configuration section, there are two options related to ETCD mTLS: ETCD_TLS_SECRET_NAME with the name of the secret that we just created. ETCD_TLS_SECRET_NAMESPACE with the namespace that we used to create the secret. To complete the installation, add these variables to the container spec of the integration DaemonSet and apply the changes: - name: \"ETCD_TLS_SECRET_NAME” value: \"newrelic-infra-etcd-tls-secret\" - name: \"ETCD_TLS_SECRET_NAMESPACE\" value: \"default\" Set up mTLS for ETCD in OpenShift Follow these instructions to set up mutual TLS authentication for ETCD in OpenShift 4.x: Export the ETCD client certificates from the cluster to an opaque secret. In a default managed OpenShift cluster, the secret is named kube-etcd-client-certs and it is stored in the openshift-monitoring namespace. kubectl get secret/kube-etcd-client-certs -n openshift-monitoring -o yaml > etcd-secret.yaml Open the secret file and change the keys: Rename the certificate authority to cacert. Rename the client certificate to cert. Rename the client key to key. Optional: change the secret name and namespace to something meaningful. Remove these unnecessary keys in the metadata section: creationTimestamp resourceVersion selfLink uid Install the manifest with its new name and namespace: kubectl apply -f etcd-secret.yaml Go to Update manifest configuration (the last step under Set up MTL from ETCD client) to configure the required environment variables. See your data If the integration has been been set up correctly, the Kubernetes cluster explorer contains all the Control Plane components and their status in a dedicated section, as shown below. one.newrelic.com > Kubernetes Cluster Explorer: Use the Kubernetes cluster explorer to monitor and collect metrics from your cluster's Control Plane components You can also check for Control Plane data with this NRQL query: SELECT latest(timestamp) FROM K8sApiServerSample, K8sEtcdSample, K8sSchedulerSample, K8sControllerManagerSample FACET entityName where clusterName = 'MY_CLUSTER_NAME' If you still can't see Control Plane data, try the solution described in Kubernetes integration troubleshooting: Not seeing data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.9256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Discovery of master nodes and control plane <em>components</em>",
        "info": "How to configure control plane monitoring for your Kubernetes <em>integration</em> with New <em>Relic</em>.",
        "category_0": "<em>Integrations</em>",
        "category_1": "Kubernetes <em>integration</em>",
        "category_2": "<em>Installation</em>",
        "body": " the master nodes and the control plane components. This means that master nodes should be labeled with node-role.kubernetes.io&#x2F;master=&quot;&quot; or kubernetes.io&#x2F;role=&quot;master&quot;. The control plane components should have either the k8s-<em>app</em> or the tier and <em>component</em> labels. Refer to the following <em>table</em> for accepted"
      },
      "id": "5df47acc64441f8fea39263b"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code",
        "This site uses cookies 🍪"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-11-23T01:51:56Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ✔ Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ✔ PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ✔ pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ✔ pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! ★ Starting as orchestrator... ✔ Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 77 return ( 78 <Map 79 className=\"containerMap\" 80 center={defaultMapCenter} 81 zoom={2} 82 zoomControl 83 > 84 <TileLayer 85 attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' 86 url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" 87 /> 88 {results.map((pt, i) => { 89 const center = [pt.lat, pt.lng]; 90 return ( 91 <CircleMarker 92 key={`circle-${i}`} 93 center={center} 94 color={this.getMarkerColor(pt.y)} 95 radius={Math.log(pt.x) * 3} 96 onClick={() => { 97 alert(JSON.stringify(pt)); 98 }} 99 /> 100 ); 101 })} 102 </Map> 103 ); 104 }} 105 </NerdGraphQuery> 106 </div> 107 <TableChart 108 accountId={accountId} 109 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 110 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 111 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 112 fullWidth 113 className=\"chart\" 114 /> 115 </div> 116 </div> 117 ); 118 } 119 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.47876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by <em>region</em> <em>in</em> a custom <em>app</em>",
        "sections": "Import the <em>TableChart</em> <em>component</em>",
        "info": "Build a New <em>Relic</em> <em>app</em> showing page view data on a world map.",
        "tags": "custom <em>app</em>",
        "body": " { <em>Table</em>Chart } from &#x27;nr1&#x27;; 3 4 const accountId = 0; &#x2F;&#x2F; Replace with your account ID 5 6 export default class PageView<em>App</em> extends React.<em>Component</em> { 7 render() { 8 return ( 9 &lt;div className=&quot;container&quot;&gt; 10 &lt;div className=&quot;<em>row</em>&quot;&gt;&lt;&#x2F;div&gt; 11 &lt;&#x2F;div&gt; 12 ); 13 } 14 } pageview-<em>app</em>-nerdlet&#x2F;index.js Copy 1 .container { 2"
      },
      "id": "5efa993c196a67066b766469"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "https://developer.newrelic.com/static/aws-reinvent-5bef5590566002047600cc1b7bb6dac3.jpg",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Attending AWS re:Invent? We'll see you there.",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:37:06Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-23T01:37:06Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Attending AWS re:Invent? We'll see you there. Demos, fireside chats, product presentations, and an exclusive conversation with Celebrity Twitch Streamer, Shorty Award Finalist, and Minecraft disrupter, AnneMunition. Nerd out with us during one of the following dates: December 3rd at 3:00PM PST/6:00PM EST December 9th at 3:00PM PST/6:00PM EST December 15th at 3:00PM PST/6:00PM EST 10 Days : 8 Hours : 47 Minutes : 4 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.02408,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " a time picker to a sample application   Add <em>custom</em> <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis Show 24 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:52:51Z",
      "title": "Collect data",
      "updated_at": "2020-10-31T01:54:19Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data   Add custom attributes Use custom attributes for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.0219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " data   Add <em>custom</em> <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create <em>custom</em> events Define, visualize, and get alerts on the data you want using <em>custom</em> events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with <em>NRQL</em> Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "API guides",
      "nodeid": 1596,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Extend your instrumentation",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Node.js agent API",
        "Request names",
        "Requirements",
        "Avoid metric grouping issues",
        "Guidelines",
        "Load the request naming API",
        "Request API calls",
        "Custom instrumentation API calls",
        "Custom metrics API calls",
        "Custom events API calls",
        "Transaction handle methods",
        "Other API calls",
        "Rules for naming and ignoring requests",
        "Optional rules attributes",
        "Testing your naming rules",
        "Naming rule examples",
        "API calls for rules",
        "For more help"
      ],
      "title": "Node.js agent API",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "fb49a4025c716c56046403d960b0802bc7485af2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/nodejs-agent-api",
      "published_at": "2020-11-21T15:56:54Z",
      "updated_at": "2020-11-12T00:46:49Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use the Node.js API to name, rename, and ignore requests, and to read router names with New Relic's Node.js agent.",
      "body": "New Relic offers several tools to help obtain the information needed to provide useful metrics about your Node.js application. These include: Reading the route names (if used) from the Express and Restify routers Using the API to name the current request, either with simple names or groups of controllers with actions Support rules that are stored in your agent's configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request's raw URLs (also available as API calls) The number of names that New Relic tracks needs to be small enough so that the user experience is robust. It also needs to be large enough to provide the right amount of information (without overwhelming you with data) so that you can identify problem spots in your applications more easily. For more information, see the Node.js agent configuration documentation and the Node.js agent API documentation on Github. Request names The Node.js agent captures the HTTP method along with a potentially parameterized path (such as /user/:id) or a regular expression (such as /^/user/([-0-9a-f]+)$/). These pieces of information become part of the request name. If you have support for slow transaction traces and have enabled capture_params in your config file, the transaction trace will also have the request's parameters and their values attached to it. If you are dissatisfied with the request names that the Node.js agent uses, you can use API calls to create more descriptive names. If grouping your requests under the generic name, then /* is sufficient, and you do not need to customize your configuration file or API calls. Requirements New Relic uses request names to group requests for many charts and tables. The value of these visualizations will drop as the number of different request names increases. For example, do not include potentially dynamic data like GUIDs, numerical IDs, or timestamps in the request names you create. If your request is slow enough to generate a transaction trace, that trace will contain the original URL. If you enable parameter capture, the parameters will also be attached to the trace. Avoid having more than 50 different transaction names. For example, if you have more than a couple hundred different request names, rethink your naming strategy. Avoid metric grouping issues The request naming API helps New Relic avoid problems with trying to handle too many metrics, which sometimes is referred to as \"metric explosion.\" New Relic has several strategies to deal with these issues; the most severe is simply to add offending applications to your deny list. The main reason for you to be careful in using these request-naming tools is to prevent that from happening to your applications. For more information, see Metric grouping issues. Guidelines Define your configuration rules from the most specific to the most general. The first rules listed in your config file or added with the Node.js transaction naming API will be applied first and should be narrowly targeted. More general \"fall-through\" rules should be added toward the end of the list, because they will be evaluated in the order they were configured or added using the Node.js transaction naming API. URL pattern matching An online retailer has a URL pattern like this: /user/customers/all/prospects /user/customers/all/current /user/customers/all/returning /user/customers/John /user/customers/Jane The retailer could create rules like this: // newrelic.js exports.config={ //other configuration rules:{ name:[ { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }, { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" }, { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" } ] } } With these rules, the retailer would create three transaction names: /user/customers/:customer /user/customers/all /user/customers/all/prospects If the retailer reversed the order, the rules would catch all transactions in :customer, which would not be as useful. Load the request naming API Make sure that loading the New Relic module is the first thing your application does, as it needs to bootstrap itself before the rest of your application loads: var newrelic = require('newrelic'); This returns the request naming API. You can safely require the module from multiple modules in your application, as it only initializes itself once. Request API calls Here is a summary of the Request API calls for New Relic's Node.js agent. newrelic.setTransactionName(name) Name the current request, following the request naming requirements. You can call this function anywhere within the context of an HTTP request handler, at any time after handling of the request has started, but before the request has finished. In general, if the request and response objects are in scope, you can set the name. Explicitly calling newrelic.setTransactionName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. newrelic.setControllerName(name, [action]) Name the current request using a controller-style pattern, optionally including the current controller action. If the action is omitted, New Relic will include the HTTP method (GET, POST, etc.) as the action. The rules for when you can call newrelic.setControllerName() are the same as they are for newrelic.setTransactionName(), including the request naming requirements. Explicitly calling newrelic.setControllerName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. Custom instrumentation API calls Use these API calls to expand your instrumentation with custom instrumentation. newrelic.instrument(moduleName, onRequire [, onError]) Sets an instrumentation callback for a specific module. The provided onRequire callback will be fired when the given module is loaded with require. The moduleName parameter should be the string that will be passed to require; for example, 'express' or 'amqplib/callback_api'. The optional onError callback is called if the onRequire parameters throws an error. This is useful for debugging your instrumentation. Use this method to: Add instrumentation for modules not currently instrumented by New Relic. Instrument your own code. Replace the Node.js agent's built-in instrumentation with your own. For more information, see New Relic's Node.js instrumentation tutorial on Github. newrelic.instrumentDatastore(moduleName, onRequire [, onError]) Sets an instrumentation callback for a datastore module. This method is just like newrelic.instrument(), except it provides a datastore-specialized shim. For more information, see New Relic's Node.js datastore instrumentation tutorial on Github. newrelic.instrumentLoadedModule(moduleName, moduleInstance) The instrumentLoadedModule method allows you to add stock instrumentation to specific modules in situations where it's impossible to have require('newrelic'); as the first line of your app's main module. // load the agent const newrelic = require('newrelic') // module loaded before newrelic const expressModule = require('express') // instrument express _after_ the agent has been loaded newrelic.instrumentLoadedModule( 'express', // the module's name, as a string expressModule // the module instance ); This method cannot instrument any arbitrary module. Its purpose is to add modules that were missed because the agent was not loaded as the first thing in your program. The instrumentLoadedModule method can only instrument modules the agent would normally instrument. You can see a list of these modules in the agent's lib/instrumentations module. newrelic.instrumentMessages(moduleName, onRequire [, onError]) Sets an instrumentation callback for a message service client module. This method is just like newrelic.instrument(), except it provides a message-service-specialized shim. For more information, see New Relic's Node.js message service instrumentation tutorial on Github. newrelic.instrumentWebframework(moduleName, onRequire [, onError]) Sets an instrumentation callback for a web framework module. This method is just like newrelic.instrument(), except it provides a web-framework-specialized shim. For more information, see New Relic's Node.js web framework instrumentation tutorial on Github. newrelic.startWebTransaction(url, handle) Instrument the specified web transaction. Using this API call, you can instrument transactions that New Relic does not automatically detect. The url defines the transaction name and needs to be static. Do not include variable data such as user ID. The handle defines the function you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startWebTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.startBackgroundTransaction(name, [group], handle) Instrument the specified background transaction. Using this API call, you can expand New Relic's instrumentation to capture data from background transactions. The name defines the transaction name and needs to be static. Do not include variable data such as user ID. The group is optional, and it allows you to group similar jobs together via the transaction type in the user interface. Like name, the group needs to be static. The handle defines a function that includes the entire background job you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startBackgroundTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.getTransaction() Returns a handle on the currently executing transaction. This handle can then be used to interact with a given transaction safely from any context. It is best used with newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Please refer to the transaction handle section for more details. newrelic.endTransaction() End the current web or background custom transaction. This method requires being in the correct transaction context when called. This API call takes no arguments. newrelic.startSegment(name, record, handler, callback) Instrument a particular method to improve visibility into a transaction, or optionally turn it into a metric. The name defines a name for the segment. This name will be visible in transaction traces and as a new metric in the New Relic UI. The record flag defines whether the segment should be recorded as a metric. The handler is the function you want to track as a segment. The optional callback is a function passed to the handler to fire after its work is done. The agent begins timing the segment when startSegment is called. The segment is ended when either the handler finishes executing, or callback is fired, if it is provided. Custom metrics API calls Use these API calls to record additional arbitrary metrics: newrelic.recordMetric(name, value) Use recordMetric to record an event-based metric, usually associated with a particular duration. The name must be a string following standard metric naming rules. The value will usually be a number, but it can also be an object. When value is a numeric value, it should represent the magnitude of a measurement associated with an event; for example, the duration for a particular method call. When value is an object, it must contain count, total, min, max, and sumOfSquares keys, all with number values. This form is useful to aggregate metrics on your own and report them periodically; for example, from a setInterval. These values will be aggregated with any previously collected values for the same metric. The names of these keys match the names of the keys used by the platform API. newrelic.incrementMetric(name, [amount]) Use incrementMetric to update a metric that acts as a simple counter. The count of the selected metric will be incremented by the specified amount, defaulting to 1. Custom events API calls Use these API calls to record additional events: newrelic.recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. Recording a custom event The following example demonstrates recording a custom event with multiple attributes. const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.recordCustomEvent('MessagingEvent', attributes) Transaction handle methods This section details the methods provided by the TransactionHandle class instance that can be obtained through newrelic.getTransaction(). Use these methods to interact directly with the current transaction: transactionHandle.end([callback]) Use transactionHandle.end to end the transaction referenced by the handle instance. The callback is invoked when the transaction has fully ended. The finished transaction passed to the callback as the first argument. transactionHandle.ignore() Use transactionHandle.ignore to ignore the transaction referenced by the handle instance. transactionHandle.insertDistributedTraceHeaders(headers) This API requires distributed tracing to be enabled. For context on how to use this call and its partner call acceptDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.insertDistributedTraceHeaders is used to implement distributed tracing. It modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with distributed_tracing.exclude_newrelic_header: true in the config. This method replaces the deprecated createDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Generating distributed trace headers In the following example, by calling insertDistributedTraceHeaders with an empty object, the appropriate Distributed Trace headers and W3C Trace Context headers will be generated for the transaction. // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() // This could be a header object from an incoming request as well const headersObject = {} newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // generate the headers transaction.insertDistributedTraceHeaders(headersObject) }) transactionHandle.acceptDistributedTraceHeaders(transportType, headers) This API requires distributed tracing to be enabled. For context on how to use this call and its partner call insertDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by insertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated (and now removed as of version 7.0.0) acceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. transportType should be one of the following strings: AMQP HTTP HTTPS IronMQ JMS Kafka Other Queue Unknown headers should be an object containing all the headers in the incoming request. The keys must be lowercase. Accept incoming distributed trace headers The following example demonstrates adding distributed trace headers retrieved from a Kafka message. In this example, we assume that the incoming Kafka message has Distributed Trace headers inserted. // incoming Kafka message headers const headersObject = message.headers // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // accept the headers transaction.acceptDistributedTraceHeaders('Kafka', headersObject) }) transactionHandle.createDistributedTracePayload() This method is deprecated and was removed in version 7.0.0! Please use insertDistributedTraceHeaders. This API requires distributed tracing to be enabled. For instructions on how to use this call, along with its partner call acceptDistributedTracePayload, see Enable distributed tracing with agent APIs. This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with acceptDistributedTracePayload. Note: In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it. The DistributedTracePayload object has two available methods used for generating the payload in different formats: DistributedTracePayload#text: returns a JSON representation of the payload. Link a nested background transaction // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() var jsonPayload = payload.text() newrelic.startBackgroundTransaction('background task', function executeTransaction() { var backgroundHandle = newrelic.getTransaction() // Link the nested transaction by accepting the payload with the background transaction's handle backgroundHandle.acceptDistributedTracePayload(jsonPayload) }) DistributedTracePayload#httpSafe: returns a base64 encoded JSON representation of the payload. Place payload on an outgoing request // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() // Place the base64 encoded value on an outbound request header. req.headers[myTracingHeader] = payload.httpSafe() transactionHandle.acceptDistributedTracePayload(payload) This method is deprecated and was removed in version 7.0.0! Please use acceptDistributedTraceHeaders. This API requires distributed tracing to be enabled. For context on how to use this call and its partner call createDistributedTracePayload, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTracePayload is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting the payload generated by createDistributedTracePayload. transactionHandle.isSampled() Returns whether this trace is being sampled. Other API calls New Relic's Node.js agent includes additional API calls. newrelic.addCustomAttribute(name, value) Set a custom attribute value to be displayed along with the transaction trace in the New Relic UI. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in New Relic APM's transaction trace detail view and in errors for the transaction. Add custom attribute newrelic.addCustomAttribute('attribute1', 'value1') If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomAttributes(attributes) Set multiple custom attribute values to be displayed along with the transaction trace in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in the transaction trace detail view and in errors for the transaction. Adding custom attributes const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.addCustomAttributes(attributes) If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttribute(name, value) Set a custom span attribute value to be displayed along with a transaction trace span in the New Relic UI. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attribute newrelic.addCustomSpanAttribute('attribute1', 'value') This API requires distributed tracing and span events to be enabled. If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttributes(attributes) Set multiple custom span attribute values to be displayed along with the transaction trace spans in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attributes const attributes = { attribute1: 'value1', attribute2: 'value2' } newrelic.addCustomSpanAttributes(attributes) This API requires distributed tracing and span events to be enabled. If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.getBrowserTimingHeader() Returns the HTML snippet to be inserted into the header of HTML pages to enable New Relic Browser. The HTML will instruct the browser to fetch a small JavaScript file and start the page timer. newrelic.setIgnoreTransaction(ignored) Tell the module whether or not to ignore a given request. This allows you to explicitly filter long-polling, irrelevant routes or requests you know will be time-consuming. This also allows you to gather metrics for requests that otherwise would be ignored. To ignore the transaction, set the parameter to true will ignore the transaction. To prevent a transaction from being ignored with this function, pass the parameter false. Passing null or undefined will not change whether the transaction is ignored. This method is deprecated and was removed in version 7.0.0. newrelic.noticeError(error, [customParameters]) Use this call if your app is doing its own error handling with domains or try/catch clauses, but you want all of the information about how many errors are coming out of the app to be centrally managed. Unlike other Node.js calls, this can be used outside of route handlers, but it will have additional context if called from within transaction scope. Errors recorded using this method do not obey the ignore_status_codes configuration value. newrelic.shutdown([options], callback) Use this method to gracefully shut down the agent. options options.collectPendingData - type boolean - Tell the agent whether to send any pending data to the New Relic collector before shutting down. options.timeout - type number (ms) - The default time before forcing a shutdown. When collectPendingData is true, the agent will wait for a connection before shutting down. This timeout is useful for short lived processes, like AWS Lambda, in order to keep the process from staying open too long, while trying to connect. Example: newrelic.shutdown({collectPendingData: true, timeout: 3000}, (error) => { process.exit() }) newrelic.getLinkingMetadata() Returns key/value pairs which can be used to link traces or entities. It will only contain items with meaningful values. For instance, if distributed tracing is disabled, trace.id will not be included. newrelic.getTraceMetadata() Returns and object containing the current trace ID and span ID. This API requires distributed tracing to be enabled or an empty object will be returned. Rules for naming and ignoring requests If you do not want to put calls to the New Relic module directly into your application code, you can use pattern-based rules to name requests. There are two sets of rules: one for renaming requests, and one to mark requests to be ignored by New Relic's instrumentation. Here is the structure for rules in New Relic's Node.js agent. rules.name A list of rules of the format {pattern : \"pattern\", name : \"name\"} for matching incoming request URLs to pattern and naming the matching New Relic transaction's name. This acts as a regex replace, where you can set the pattern either as a string, or as a JavaScript regular expression literal, and both pattern and name are required. When passing a regex as a string, escape backslashes, as the agent does not keep them when given as a string in a pattern. Define your configuration rules from the most specific to the most general, as the patterns will be evaluated in order and are terminal in nature. For more information, see the naming guidelines. This can also be set with the environment variable NEW_RELIC_NAMING_RULES, with multiple rules passed in as a list of comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Optional rules attributes Additional optional attributes are available: Optional rules attributes Description terminate_chain Default: true When set to true (default), no further rules will be evaluated if this rule is a match. Setting this to false is useful when multiple rules should be used together. For example, one rule could be replacing a common pattern in many different URLs, while subsequent rule(s) would be more specific. replace_all Default: false When set to true, all matches of the pattern will be replaced. Otherwise, only the first match will be replaced. Using the g flag with regular expression literal will have the same effect. For example: pattern: '[0-9]+', replace_all: true This has the same effect as pattern: /[0-9]+/g. precedence By default the rules are evaluated in order, from first to last. If you prefer to have complete control over the order, you can give each rule a precedence attribute. The precedence is an integer number, and rules are evaluated in ascending order. If precedence is not explicitly defined, it will be set to 500 by default. Additional attributes are ignored. Testing your naming rules The Node.js agent comes with a command-line tool for testing naming rules. For more information, run the following command in terminal window in a directory where your app is installed: node node_modules/.bin/newrelic-naming-rules Naming rule examples Here are some examples of naming rules and the results. Match full URL pattern: \"^/items/[0-9]+$\", name: \"/items/:id\" will result in: /items/123 => /items/:id /orders/123 => /orders/123 (not replaced since the rule is a full match) Replace first match in URL pattern: \"[0-9]+\", name: \":id\" will result in: /orders/123 => /orders/:id /items/123 => /items/:id /orders/123/items/123 => /orders/:id/items/123 Replace all matches in any URL pattern: \"[0-9]+\", name: \":id\", replace_all: true will result in: /orders/123/items/123 => /orders/:id/items/:id Match group references Using regular expression match group references: pattern: '^/(items|orders)/[0-9]+$', name: '/\\\\1/:id' will result in: /orders/123 => /orders/:id /items/123 => /items/:id rules.ignore This can also be set via the environment variable NEW_RELIC_IGNORING_RULES, with multiple rules passed in as a list of comma-delimited patterns. Currently there is no way to escape commas in patterns. NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me' Here are full examples of how rules are included in the configuration file: Naming rule example // newrelic.js exports.config = { // other configuration rules : { name : [ { pattern: \"/tables/name-here\", name: \"/name-hererule1\" } ] } Ignoring rule example If you are using socket.io, you will have a use case for ignoring rules right out of the box. To keep socket.io long-polling from dominating your response-time metrics and affecting the Apdex metrics for your application, add a rule such as: // newrelic.js exports.config = { // other configuration rules : { ignore : [ '^\\/socket\\.io\\/.*\\/xhr-polling' ] } }; API calls for rules Here are the API calls for naming and ignoring rules with New Relic's Node.js agent. newrelic.addNamingRule(pattern, name) Programmatic version of rules.name. Once naming rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. Both parameters are required. newrelic.addIgnoringRule(pattern) Programmatic version of rules.ignore. Once ignoring rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. This parameter is required. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.69786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Attributes</em>",
        "body": " <em>attributes</em>. <em>Custom</em> <em>attributes</em> will appear in New Relic APM&#x27;s transaction trace detail view and in errors for the transaction. Add <em>custom</em> attribute newrelic.add<em>Custom</em>Attribute(&#x27;attribute1&#x27;, &#x27;value1&#x27;) If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em> when naming"
      },
      "id": "540a92a2c75d073d3d0006f7"
    },
    {
      "category_2": "NRQL query tutorials",
      "nodeid": 11451,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Simulate SQL JOIN functions in Insights",
        "Simulate SQL JOIN with custom attributes",
        "For more help"
      ],
      "title": "Simulate SQL JOIN functions in Insights",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "external_id": "9ace89658c3020db08f87be5f031a1eadc742b27",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/simulate-sql-join-functions-insights",
      "published_at": "2020-11-21T21:50:06Z",
      "updated_at": "2020-10-09T11:48:22Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / NRQL query tutorials",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic NRQL: simulating SQL-like JOIN functions using custom attributes.",
      "body": "NRQL does not have an equivalent SQL-like JOIN function. You can simulate a JOIN by using custom attributes in a query's WHERE or FACET clause. Simulate SQL JOIN with custom attributes To gain more in-depth data, you can add custom attributes to some data types. For example, you want to know which browser types are experiencing the highest web duration for a specific product purchase. You could add a custom attribute named Product to your application's purchase transaction method. Then you could run this NRQL query: SELECT max(duration), average(duration), max(backendDuration), average(backendDuration) FROM PageView WHERE Product = 'Hat' FACET userAgentName SINCE 7 days ago For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.041504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Simulate SQL JOIN with <em>custom</em> <em>attributes</em>",
        "info": "New Relic <em>NRQL</em>: simulating SQL-like JOIN functions using <em>custom</em> <em>attributes</em>.",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "category_2": "<em>NRQL</em> query tutorials",
        "body": "<em>NRQL</em> does not have an equivalent SQL-like JOIN function. You can simulate a JOIN by using <em>custom</em> <em>attributes</em> in a query&#x27;s WHERE or FACET clause. Simulate SQL JOIN with <em>custom</em> <em>attributes</em> To gain more in-depth data, you can add <em>custom</em> <em>attributes</em> to some data types. For example, you want to know which",
        "breadcrumb": "Contents &#x2F; Query your data &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; <em>NRQL</em> query tutorials"
      },
      "id": "5f306fd3196a67d6a4fbd6d1"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/course_series/1bprhm3hdt1kx/promo-image.1546472283.png?1546473540",
      "url": "https://learn.newrelic.com/series/webcasts",
      "sections": [
        "Format",
        "Product",
        "Level",
        "Live and Recorded Webcasts"
      ],
      "published_at": "2020-11-22T01:47:05Z",
      "title": "Webcasts",
      "updated_at": "2020-11-21T14:08:54Z",
      "type": "",
      "external_id": "bf9dfa83b37c99dd5ece2b37408635c0660648ea",
      "popularity": 1,
      "body": "Sign In Back to Catalog View Results All -- results Reset Format Recorded Webcast Upcoming Webcasts Product APM Insights Level Introductory Power User Searching... Courses Lessons Live and Recorded Webcasts Learn with New Relic University instructors in free 30 minute sessions on a variety of topics. Register to attend a scheduled webcast and learn from instructors in a live training session, or watch a pre-recorded webcast and work at your own pace. Check back each month to stay on top of new courses and offerings! Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. FREE GraphQL APIAPIUpcoming WebcastsNew Relic OneNew Relic APIs Live Learncast: Alerts New Relic Alerts is a flexible and centralized notification system that unlocks the operational potential of New Relic. With a single tool to manage alert policies and alert conditions, you can focus on the metrics you care about most. FREE AlertsGet StartedAPMLive Virtual TrainingUpcoming WebcastsNew Relic APM Live Learncast: Get More Out of New Relic Synthetics with NRQL Learn how to unlock the power of New Relic Synthetics by using Dashboards and NRQL Alerting. FREE Monitor PerformanceAPIUpcoming WebcastsSyntheticsDashboards and Data Apps Live Learncast: REST API New Relic provides you with multiple APIs to manage and extract your data. Learn how you can use the REST API to make your life easier by automating tasks. FREE APIUpcoming WebcastsBrowserMobile monitoringNew Relic Browser Recorded Webcast: Getting Started with New Relic Application Performance Monitoring (APM) Start here to learn the basics about how New Relic collects application metrics and other features to get you up and running on Application Performance Monitoring (APM). IntroductoryAPMGetting-StartedRecorded Webcast Recorded Webcast: Getting Started with New Relic Insights New Relic captures a ton of information about your application. Wouldn’t it be great if you could mine the information in your applications to help make business decisions? Learn how to use New Relic Insights to get answers to questions you didn't even know you had! IntroductoryInsightsRecorded Webcast Recorded Webcast: Getting Started with New Relic Synthetics Learn how to create scripts to exercise your site and to detect problems before your users see them. IntroductoryRecorded WebcastSyntheticsNew Relic Synthetics Recorded Webcast: Getting Started with New Relic Browser Did you know that 80% or more of your application’s response time is spent on the front end? While optimizing your application server is important, monitoring client-side performance is also critical. Discover how to use New Relic Browser to monitor and analyze your end users’ experience. IntroductoryRecorded WebcastBrowserNew Relic Browser Recorded Webcast: Configuring Alert Policies New Relic dashboards are super cool, but who has time to sit around watching them all day? New Relic Alerting is a flexible, centralized alerting system that allows you to create and manage alert policies that fit your environment and the metrics you care about most. AlertsIntroductoryPower UserRecorded Webcast Recorded Webcast: Improving Performance with Mobile Monitoring Mobile developers want to spend less time troubleshooting and more time building cool new features and products. Learn how to use New Relic Mobile to quickly troubleshoot mobile application performance problems and get back to the good stuff. IntroductoryRecorded WebcastMobile monitoring Effective Alerting with New Relic In this engaging FREE 2 hour session we move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you. With scenario based labs you’ll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. FREE New Relic APIs Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. FREE IntroductoryCustomize DataAdvancedTutorialGraphQL APIAPINew Relic APIs Navigating APM Learn how to navigate New Relic APM UI and interpret chart data so you can improve your application's performance and troubleshoot complex applications faster. FREE Telemetry Data Platform Learn more about how the Telemetry Data Platform lets you analyze, visualize, and alert on all your metrics, events, logs, and traces from any source with the world’s most powerful, managed, open, and unified telemetry database. FREE PrometheusGrafana New Relic Infrastructure Fundamentals In this course, you'll learn how New Relic Infrastructure provides deep visibility into cloud and on-premises environments. New Relic Infrastructure connects the health and performance of infrastructure to the richest metrics, events, logs, and traces to provide context for supporting our customers’ applications. FREE APM for Power Users Level up your digital intelligence and become an APM Power User. In this course, you learn to use advanced performance monitoring features. FREE Become a power userAPMPower UserAdvancedTutorialAPM for Power Users New Relic APM Fundamentals In this course, you'll learn how to use New Relic APM to see what's happening in your application, understand where the problems are, discover opportunities for optimizing your entire application ecosystem, and make sure you never miss an issue that needs attention. FREE New Relic APM Fundamentals New Relic Insights + APM Fundamentals In this course, you'll learn how to create an Insights dashboard in the UI and from a JSON template, add APM charts, and edit your Dashboard. This course culminates in a live virtual training where you'll learn how to analyze your APM data in Insights. FREE New Relic Insights + APM FundamentalsNew Relic APM Fundamentalsabracadabra Live Webinar: Introduction to New Relic Full Stack Observability Full-Stack Observability delivers on our vision of true observability for all. With Full-Stack Observability, you get simple, intuitive, out-of-the-box curated monitoring experiences—all in one platform. Don't miss out on learning more. Register today for an upcoming session. FREE New Relic Alerts Fundamentals Learn how to use the New Relic platform Alerts tool to monitor performance and know when leading performance indicators spike or drop so you can catch problems before they reach your end user. Enable team members to get the alerts they need faster and achieve lower response times. FREE New Relic Alerts Fundamentals Overview New Relic One is the industry’s largest and most comprehensive cloud-based observability platform built to help customers create more perfect software. In the pursuit of our vision, we have enhanced New Relic One to provide a simplified and frictionless experience for customers. FREE Live Webinar: Introduction to New Relic Applied Intelligence (AI) Applied Intelligence empowers you with AIOps capabilities to proactively detect and resolve incidents faster by finding problems earlier, enriching triggered incidents with context and guidance, and bringing you closer to the root cause. It gives you the ability to automatically correlate, aggregate, and prioritize your incident data across the tools you already use to eliminate alert noise and drive faster MTTR. Now that's powerful. Join one of our sessions to learn more. FREE Performance Monitoring Fundamentals In this course, you’ll learn how you can use the New Relic Digital Intelligence Platform to get end-to-end visibility into the performance of your websites and apps, the customer experiences they deliver, and their effect on your business. FREE APMTutorialBrowserself-serveNew Relic InsightsNew Relic InfrastructureNew Relic FundamentalsPerformance Monitoring Fundamentals Live Webinar: What’s New at New Relic We recently shared the exciting news about our New Relic One launch, including some long awaited user experience changes. Join us as we walk you through the new user experience and answer your questions! FREE Getting Started with Synthetics Learn how to use Synthetics to test your app from different global locations, simulate user flows and interactions, check the performance of individual page components, and fix problems before they affect the end-user's experience. FREE Get StartedMonitor PerformancePower UserTutorialSyntheticsNew Relic Synthetics Getting Started with Insights Learn how to use New Relic Insights to analyze and present custom, real-time data visualizations. FREE Get StartedIntroductoryInsightsTutorialNew Relic Insights Getting Started with Infrastructure Learn New Relic Infrastructure fundamentals to get a precise picture of your dynamically changing systems. New Relic Infrastructure delivers real-time health metrics correlated with recent configuration changes, so you can quickly resolve issues, scale rapidly, and deploy intelligently. FREE Get StartedInfrastructureMonitor PerformancePower UserTutorialNew Relic Infrastructure Custom Data with Insights Learn how to take your application performance analysis to the next level. Add context and get more detailed results with custom attributes, or by importing additional datasets. This course will show you how to import JSON data to the Insights API endpoint, alongside default data captured natively. FREE Power UserInsightsCustomize DataAdvancedTutorialCustom Data with Insights Get Started with APM Let's get started together. We're going to take you through the basics to manage your application and services. FREE Get StartedGet CertifiedIntroductoryAPMTutorialGetting-Startedself-serveGet Started with APMNew Relic APM Insights Dashboards and Data Apps Learn how to use Insights Dashboards and Data Apps to analyze any data type from across all New Relic products in real-time and present a variety of metrics and visualizations in a meeting or on the go, embed charts into your own application, or create self-service dashboards for other teams. FREE Get StartedMonitor PerformanceGet CertifiedPower UserInsightsTutorialInsights DashboardsDashboards and Data Apps Writing NRQL Queries Learn how to ask questions about your data using NRQL, New Relic's SQL-flavored query language, and create beautiful visualizations for analyzing your data in real-time. FREE Get StartedBecome a power userGet CertifiedIntroductoryInsightsTutorialCloud AdoptionApplication Baselineself-serveWriting NRQL Queries New Relic Alerts Learn how to use the New Relic platform Alerts tool to monitor performance and know when leading performance indicators spike or drop so you can catch problems before they reach your end user. Enable team members to get the alerts they need faster and achieve lower response times. FREE AlertsGet StartedIntroductoryAPMPower UserTutorialNew Relic Alerts Performance Monitoring with New Relic In this course, you’ll learn how you can use the New Relic Digital Intelligence Platform to get end-to-end visibility into the performance of your websites and apps, the customer experiences they deliver, and their effect on your business. FREE AlertsGet StartedInfrastructureIntroductoryAPMInsightsTutorialSyntheticsBrowserMobile monitoringself-servePerformance Monitoring with New Relic Part of: © 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.382706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " analysis to the next level. Add context and get more detailed results with <em>custom</em> <em>attributes</em>, or by importing additional datasets. This course will show you how to import JSON data to the Insights API endpoint, alongside default data captured natively. FREE Power UserInsightsCustomize"
      },
      "id": "5c2eb9f50cc37f4f3ff9ab03"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies 🍪"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-27T02:42:11Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.44081,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " components, see our app building guides and the New Relic <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies 🍪"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-11-23T01:48:08Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.56587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": " Relic or third-party data. Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:49:16Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.54105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " Nerdpacks and their <em>file</em> <em>structure</em>, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. For more on how to set up your Nerdpacks, see our <em>Nerdpack</em> <em>CLI</em> commands. Usage $ <em>nr1</em> create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing",
        "This site uses cookies 🍪"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-11-23T01:45:56Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they’ve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren’t an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.776375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to apps",
        "tags": "<em>nerdpack</em> manager",
        "body": "Permissions for managing <em>applications</em> When you create an app, you&#x27;ll likely want to share it. From New Relic <em>One</em>&#x27;s Apps page, you can <em>subscribe</em> to apps you create, publish, and deploy, and to other publicly available apps. You must have the <em>Nerdpack</em> manager role to subcribe accounts to apps. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "category_2": "Get started",
      "nodeid": 2481,
      "sections": [
        "Welcome to New Relic",
        "Get started",
        "New Relic University",
        "Glossary",
        "For more help"
      ],
      "title": "Glossary",
      "category_0": "Using New Relic",
      "type": "docs",
      "category_1": "Welcome to New Relic",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/using-new-relic/welcome-new-relic/get-started/glossary",
      "external_id": "b6199b4bb822a19cf31503ffe077d8a13b3632b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary",
      "published_at": "2020-11-21T19:29:19Z",
      "updated_at": "2020-10-27T03:07:54Z",
      "breadcrumb": "Contents / Using New Relic / Welcome to New Relic / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "This glossary defines common New Relic terminology, and provides links to relevant content to help better understand each subject.",
      "body": "A glossary of common terminology you may encounter. account dropdown When you're logged into New Relic, the account dropdown menu displays your login name and is located at the top right of the UI. Clicking this gives you access to various account-related abilities. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the Mobile agent, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure Monitoring By connecting changes in host performance to changes in your configuration, Infrastructure Monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights At New Relic, Insights used to be the primary way to query and chart your New Relic-reported data. Now, we have the improved query builder. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our Mobile Monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account A master account is a New Relic account that has one or more subordinate accounts (sub-accounts). For details, see Account structure. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile Monitoring, and Browser Monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile Monitoring Mobile Monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile Monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at https://api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. Tier may also refer to our pricing tiers. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.19647,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " by a React JavaScript package. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. <em>Nerdpack</em> A <em>Nerdpack</em> is a component of a New Relic <em>One</em> application. It&#x27;s the package containing all the files needed by that application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. New Relic Edge with Infinite"
      },
      "id": "5d0314cd4bb81c77f2eedaea"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies 🍪"
      ],
      "published_at": "2020-11-23T01:51:55Z",
      "title": "Build apps",
      "updated_at": "2020-11-19T01:47:24Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map   Permissions for managing applications Learn about permissions for subscribing to apps 30 min Publish and deploy apps Start sharing the apps you build 20 min Set up your development environment Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 595.0944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 20 minutes Add the <em>NerdGraphQuery</em> <em>component</em> to an application The <em>NerdGraphQuery</em> <em>component</em> allows you"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "Manage data",
      "nodeid": 37701,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Drop data using NerdGraph",
        "Requirements",
        "Create drop data rule",
        "NRQL restrictions",
        "Example drop rules",
        "Verify your drop rule works",
        "View rules",
        "Delete drop rules",
        "Audit drop rule history",
        "Cautions when dropping data",
        "Learn more",
        "For more help"
      ],
      "title": "Drop data using NerdGraph",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "06e7cd1ec25f92d3cb16660991adb3e7e4694238",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/data-management/drop-data-using-nerdgraph",
      "published_at": "2020-11-21T17:32:48Z",
      "updated_at": "2020-11-21T17:32:48Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Manage data",
      "document_type": "page",
      "popularity": 1,
      "info": "Using the New Relic NerdGraph API, you can drop some specific types of data that meet the criteria you set. ",
      "body": "For some types of data in New Relic, you can drop (not report) that data. You might want to do this: To filter out unimportant, low-value data To filter out potentially sensitive data If you choose to drop data, only new data will be affected. Existing data cannot be edited or deleted. Requirements You must have a user role with permissions for dropping data. Currently the following types of data can be targeted by data dropping rules: APM-reported events Browser-reported events Mobile-reported events Synthetics-reported events Custom events (like those generated by the APM agent APIs or the Event API) Log data Trace spans Metrics from the metric API Currently only DROP_ATTRIBUTES, not DROP_DATA​​​​, can be used on metrics Metrics generated from events-to-metrics are not eligible Support for additional types are planned for the future. Create drop data rule Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, please review caution information below. To drop data, create a NerdGraph-format drop rule that includes: A NRQL string that specifies what data types to drop An action type specifying how to apply the NRQL string You can form and make the call in the NerdGraph explorer. There are two ways to drop data: Drop entire data types or a data subset (with optional filter). This uses the DROP_DATA action type and uses NRQL of the form: SELECT * FROM DATA_TYPE_1, DATA_TYPE_2 (WHERE OPTIONAL_FILTER) For this type of drop rule, you cannot use anything other than * in the SELECT clause. Drop attributes from data types (with optional filter). This uses the DROP_ATTRIBUTES action type and uses NRQL of the form: SELECT dropAttr1, dropAttr2 FROM DATA_TYPE (WHERE OPTIONAL_FILTER) For this type of drop rule, you must pass in a non-empty list of raw attributes names. NRQL restrictions Not all NRQL clauses make sense for generating drop rules. You can provide a WHERE clause to select data with specific attributes. Other features such as TIMESERIES, COMPARE WITH, FACET, and other clauses cannot be used. The two action types have these restrictions: DROP_DATA can use only SELECT *. DROP_ATTRIBUTES requires use of SELECT with \"raw\" attributes (attributes with no aggregator function applied). This also means you cannot use SELECT *. Additionally, there are some attributes that are integral to their data type and cannot be dropped (such as timestamp on event data). If you include them, registration will fail. Example drop rules Here are some example drop rules: Drop two event types Let's say you notice you have some event types being sent to New Relic that are not important to you. Also, stopping the source from sending those event types quickly is unrealistic, requiring changes to agents and/or API instrumentation. Using a drop rule is an easier way to accomplish the same goal. Here is an example NerdGraph call that drops two event types: Event1 and Event2. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM Event1, Event2\" description: \"Drops all data for Event1 and Event2.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Drop events meeting certain criteria Let’s say you have a high volume custom event type that arrives from multiple sources. If you don't find all of that data important, you can use a drop rule. Here is an example of a drop rule that filters out events based on specific criteria. mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_DATA nrql: \"SELECT * FROM MyCustomEvent WHERE appName='LoadGeneratingApp' AND environment='development'\" description: \"Drops all data for MyCustomEvent that comes from the LoadGeneratingApp in the dev environment, because there is too much and we don’t look at it.\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Drop sensitive attributes while maintaining the rest of the data Let's say you noticed an event has attributes that contain Personally Identifiable Information (PII). You are working to update your services to stop sending the data, but until then, you need to cease storing further PII in New Relic. Although you could drop all of the data as it comes in the door with a DROP_DATA rule, the rest of the data still provides value. Therefore, you can register a drop rule to remove only the offending PII from your data: mutation { nrqlDropRulesCreate(accountId: YOUR_ACCOUNT_ID, rules: [ { action: DROP_ATTRIBUTES nrql: \"SELECT userEmail, userName FROM MyCustomEvent description: \"Removes the user name and email fields from MyCustomEvent\" } ]) { successes { id } failures { submitted { nrql } error { reason description } } } } Verify your drop rule works After you create a drop rule, verify that it is working as expected. The rule should take effect quickly after a successful registration, so try running a TIMESERIES version of the query you registered to see that the data drops off. Drop rule type NRQL DROP_DATA Drop rule NRQL: SELECT * FROM MyEvent WHERE foo = bar Validation NRQL: SELECT count(*) FROM MyEvent WHERE foo = bar TIMESERIES This should drop to 0. To verify that it did not affect any thing else, invert the WHERE clause. DROP_ATTRIBUTES Drop rule NRQL: SELECT dropAttr1, dropAttr2 FROM MyEvent WHERE foo = bar Validation NRQL: SELECT count(dropAttr1), count(dropAttr2) FROM MyEvent WHERE foo = bar TIMESERIES Both lines should drop to 0. To verify that it did not affect events that contained these attributes and still should, invert the WHERE clause. View rules Here is an example NerdGraph call that returns the drop rules set on an account: { actor { account(id: YOUR_ACCOUNT_ID) { nrqlDropRules { list { rules { id nrql accountId action createdBy createdAt description } error { reason description } } } } } } Delete drop rules Here is an example NerdGraph call deleting two specific drop rules: mutation { nrqlDropRulesDelete(accountId: YOUR_ACCOUNT_ID, ruleIds: [\"48\", \"98\"]) { successes { id nrql accountId action description } failures { error { reason description } submitted { ruleId accountId } } } } Audit drop rule history To see who created and deleted drop rules, query your account audit logs. The list endpoint also includes the user ID of the person who created the rule. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Only new data will be dropped. Existing data cannot be edited or deleted. Learn more Recommendations for learning more: NerdGraph basics and terminology NRQL basics Browse the Explorers Hub for community discussions about NRQL drop rules. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 402.5962,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Drop</em> <em>data</em> using <em>NerdGraph</em>",
        "sections": "<em>Drop</em> <em>data</em> using <em>NerdGraph</em>",
        "info": "Using the New Relic <em>NerdGraph</em> API, you can <em>drop</em> some specific types of <em>data</em> that <em>meet</em> the criteria you set. ",
        "category_0": "Telemetry <em>Data</em> Platform",
        "category_1": "Ingest and manage <em>data</em>",
        "category_2": "Manage <em>data</em>",
        "body": " to <em>drop</em> <em>data</em>. The <em>data</em> you <em>drop</em> is not recoverable. Before using this feature, please review caution information below. To <em>drop</em> <em>data</em>, create a <em>NerdGraph</em>-format <em>drop</em> rule that includes: A NRQL string that specifies what <em>data</em> types to <em>drop</em> An action type specifying how to apply the NRQL string You can",
        "breadcrumb": "Contents &#x2F; Telemetry <em>Data</em> Platform &#x2F; Ingest and manage <em>data</em> &#x2F; Manage <em>data</em>"
      },
      "id": "5e7b6e26196a6714b902bd57"
    },
    {
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery",
        "This site uses cookies 🍪"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-27T02:44:09Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 319.42398,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> and store <em>data</em>",
        "sections": "<em>Components</em> <em>overview</em>",
        "info": "Reference guide for SDK <em>query</em> <em>components</em> using <em>NerdGraph</em>",
        "tags": "<em>nerdgraph</em> <em>query</em> <em>components</em>",
        "body": " be identified by the <em>Query</em> suffix. Mutation-related components can be identified by the Mutation prefix. Components <em>overview</em> Our <em>data</em> components are based on React Apollo. The most basic <em>component</em> is <em>NerdGraphQuery</em>, which accepts any <em>Graph</em>QL (or <em>Graph</em>QL AST generated by the graphql-tag library"
      },
      "id": "5efa989e28ccbc2f15307deb"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code",
        "This site uses cookies 🍪"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-11-23T01:51:56Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ✔ Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ✔ PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ✔ pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ✔ pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! ★ Starting as orchestrator... ✔ Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 77 return ( 78 <Map 79 className=\"containerMap\" 80 center={defaultMapCenter} 81 zoom={2} 82 zoomControl 83 > 84 <TileLayer 85 attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' 86 url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" 87 /> 88 {results.map((pt, i) => { 89 const center = [pt.lat, pt.lng]; 90 return ( 91 <CircleMarker 92 key={`circle-${i}`} 93 center={center} 94 color={this.getMarkerColor(pt.y)} 95 radius={Math.log(pt.x) * 3} 96 onClick={() => { 97 alert(JSON.stringify(pt)); 98 }} 99 /> 100 ); 101 })} 102 </Map> 103 ); 104 }} 105 </NerdGraphQuery> 106 </div> 107 <TableChart 108 accountId={accountId} 109 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 110 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 111 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 112 fullWidth 113 className=\"chart\" 114 /> 115 </div> 116 </div> 117 ); 118 } 119 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 283.78748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by region in a custom <em>app</em>",
        "sections": "<em>Query</em> your browser <em>data</em>",
        "info": "Build a New Relic <em>app</em> showing page view <em>data</em> on a world map.",
        "tags": "custom <em>app</em>",
        "body": ": event.target.value }); 62 }} 63 &#x2F;&gt; 64 &lt;&#x2F;div&gt; 65 &lt;div className=&quot;row&quot;&gt; 66 &lt;<em>NerdGraphQuery</em> <em>query</em>={this.map<em>Data</em>()}&gt; 67 {({ loading, error, <em>data</em> }) =&gt; { 68 if (loading) { 69 return &lt;Spinner fillContainer &#x2F;&gt;; 70 } 71 if (error) { 72 return &#x27;Error&#x27;; 73 } 74 const { results } = <em>data.actor.account.mapData</em>; 75"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps",
        "This site uses cookies 🍪"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-11-23T01:49:16Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer’s Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.73758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Explore <em>NerdGraph</em> using the API Explorer",
        "sections": "Try your <em>NerdGraph</em> <em>query</em> in the terminal",
        "info": "Explore <em>NerdGraph</em>, our <em>GraphQL</em> API, and build the <em>queries</em> you need.",
        "tags": "<em>nerdgraph</em> <em>query</em> terminal",
        "body": " the <em>account</em> id and email fields. Once again, running the <em>Graph</em>QL <em>query</em> results in just the <em>data</em> you need, without over or under-fetching <em>data</em>. Notice that the id field has an argument: passing arguments is a powerful way of customizing your <em>NerdGraph</em> queries. Every field and object can contain"
      },
      "id": "5efa9973196a6791f4766402"
    }
  ]
}